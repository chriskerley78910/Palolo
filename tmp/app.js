/**
 * @license Proprietary text 2.0.15 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/text/LICENSE
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, components, FileUtils */

define('text',['module'], function (module) {
    'use strict';

    var text, fs, Cc, Ci, xpcIsWindows,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = {},
        masterConfig = (module.config && module.config()) || {};

    function useDefault(value, defaultValue) {
        return value === undefined || value === '' ? defaultValue : value;
    }

    //Allow for default ports for http and https.
    function isSamePort(protocol1, port1, protocol2, port2) {
        if (port1 === port2) {
            return true;
        } else if (protocol1 === protocol2) {
            if (protocol1 === 'http') {
                return useDefault(port1, '80') === useDefault(port2, '80');
            } else if (protocol1 === 'https') {
                return useDefault(port1, '443') === useDefault(port2, '443');
            }
        }
        return false;
    }

    text = {
        version: '2.0.15',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.lastIndexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || isSamePort(uProtocol, uPort, protocol, port));
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config && config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config && config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            // Do not load if it is an empty: url
            if (url.indexOf('empty:') === 0) {
                onLoad();
                return;
            }

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node &&
            !process.versions['node-webkit'] &&
            !process.versions['atom-shell'])) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback, errback) {
            try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file[0] === '\uFEFF') {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                if (errback) {
                    errback(e);
                }
            }
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status || 0;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        if (errback) {
                            errback(err);
                        }
                    } else {
                        callback(xhr.responseText);
                    }

                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                if (line !== null) {
                    stringBuffer.append(line);
                }

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
            typeof components !== 'undefined' && components.classes &&
            components.interfaces)) {
        //Avert your gaze!
        Cc = components.classes;
        Ci = components.interfaces;
        components.utils['import']('resource://gre/modules/FileUtils.jsm');
        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);

        text.get = function (url, callback) {
            var inStream, convertStream, fileObj,
                readData = {};

            if (xpcIsWindows) {
                url = url.replace(/\//g, '\\');
            }

            fileObj = new FileUtils.File(url);

            //XPCOM, you so crazy
            try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                           .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);

                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                                .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
            }
        };
    }
    return text;
});

/*!
 * Knockout JavaScript library v3.4.2
 * (c) The Knockout.js team - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {(function(n){var x=this||(0,eval)("this"),t=x.document,M=x.navigator,u=x.jQuery,H=x.JSON;(function(n){"function"===typeof define&&define.amd?define('ko',["exports","require"],n):"object"===typeof exports&&"object"===typeof module?n(module.exports||exports):n(x.ko={})})(function(N,O){function J(a,c){return null===a||typeof a in R?a===c:!1}function S(b,c){var d;return function(){d||(d=a.a.setTimeout(function(){d=n;b()},c))}}function T(b,c){var d;return function(){clearTimeout(d);d=a.a.setTimeout(b,c)}}function U(a,
c){c&&c!==E?"beforeChange"===c?this.Ob(a):this.Ja(a,c):this.Pb(a)}function V(a,c){null!==c&&c.k&&c.k()}function W(a,c){var d=this.Mc,e=d[s];e.T||(this.ob&&this.Oa[c]?(d.Sb(c,a,this.Oa[c]),this.Oa[c]=null,--this.ob):e.s[c]||d.Sb(c,a,e.t?{$:a}:d.yc(a)),a.Ha&&a.Hc())}function K(b,c,d,e){a.d[b]={init:function(b,g,h,l,m){var k,r;a.m(function(){var q=g(),p=a.a.c(q),p=!d!==!p,A=!r;if(A||c||p!==k)A&&a.xa.Ca()&&(r=a.a.wa(a.f.childNodes(b),!0)),p?(A||a.f.fa(b,a.a.wa(r)),a.hb(e?e(m,q):m,b)):a.f.za(b),k=p},null,
{i:b});return{controlsDescendantBindings:!0}}};a.h.va[b]=!1;a.f.aa[b]=!0}var a="undefined"!==typeof N?N:{};a.b=function(b,c){for(var d=b.split("."),e=a,f=0;f<d.length-1;f++)e=e[d[f]];e[d[d.length-1]]=c};a.H=function(a,c,d){a[c]=d};a.version="3.4.2";a.b("version",a.version);a.options={deferUpdates:!1,useOnlyNativeEvents:!1};a.a=function(){function b(a,b){for(var c in a)a.hasOwnProperty(c)&&b(c,a[c])}function c(a,b){if(b)for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return a}function d(a,b){a.__proto__=
b;return a}function e(b,c,d,e){var m=b[c].match(r)||[];a.a.r(d.match(r),function(b){a.a.ra(m,b,e)});b[c]=m.join(" ")}var f={__proto__:[]}instanceof Array,g="function"===typeof Symbol,h={},l={};h[M&&/Firefox\/2/i.test(M.userAgent)?"KeyboardEvent":"UIEvents"]=["keyup","keydown","keypress"];h.MouseEvents="click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");b(h,function(a,b){if(b.length)for(var c=0,d=b.length;c<d;c++)l[b[c]]=a});var m={propertychange:!0},k=
t&&function(){for(var a=3,b=t.createElement("div"),c=b.getElementsByTagName("i");b.innerHTML="\x3c!--[if gt IE "+ ++a+"]><i></i><![endif]--\x3e",c[0];);return 4<a?a:n}(),r=/\S+/g;return{gc:["authenticity_token",/^__RequestVerificationToken(_.*)?$/],r:function(a,b){for(var c=0,d=a.length;c<d;c++)b(a[c],c)},o:function(a,b){if("function"==typeof Array.prototype.indexOf)return Array.prototype.indexOf.call(a,b);for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},Vb:function(a,b,c){for(var d=
0,e=a.length;d<e;d++)if(b.call(c,a[d],d))return a[d];return null},Na:function(b,c){var d=a.a.o(b,c);0<d?b.splice(d,1):0===d&&b.shift()},Wb:function(b){b=b||[];for(var c=[],d=0,e=b.length;d<e;d++)0>a.a.o(c,b[d])&&c.push(b[d]);return c},ib:function(a,b){a=a||[];for(var c=[],d=0,e=a.length;d<e;d++)c.push(b(a[d],d));return c},Ma:function(a,b){a=a||[];for(var c=[],d=0,e=a.length;d<e;d++)b(a[d],d)&&c.push(a[d]);return c},ta:function(a,b){if(b instanceof Array)a.push.apply(a,b);else for(var c=0,d=b.length;c<
d;c++)a.push(b[c]);return a},ra:function(b,c,d){var e=a.a.o(a.a.Bb(b),c);0>e?d&&b.push(c):d||b.splice(e,1)},la:f,extend:c,$a:d,ab:f?d:c,D:b,Ea:function(a,b){if(!a)return a;var c={},d;for(d in a)a.hasOwnProperty(d)&&(c[d]=b(a[d],d,a));return c},rb:function(b){for(;b.firstChild;)a.removeNode(b.firstChild)},nc:function(b){b=a.a.W(b);for(var c=(b[0]&&b[0].ownerDocument||t).createElement("div"),d=0,e=b.length;d<e;d++)c.appendChild(a.ba(b[d]));return c},wa:function(b,c){for(var d=0,e=b.length,m=[];d<e;d++){var k=
b[d].cloneNode(!0);m.push(c?a.ba(k):k)}return m},fa:function(b,c){a.a.rb(b);if(c)for(var d=0,e=c.length;d<e;d++)b.appendChild(c[d])},uc:function(b,c){var d=b.nodeType?[b]:b;if(0<d.length){for(var e=d[0],m=e.parentNode,k=0,f=c.length;k<f;k++)m.insertBefore(c[k],e);k=0;for(f=d.length;k<f;k++)a.removeNode(d[k])}},Ba:function(a,b){if(a.length){for(b=8===b.nodeType&&b.parentNode||b;a.length&&a[0].parentNode!==b;)a.splice(0,1);for(;1<a.length&&a[a.length-1].parentNode!==b;)a.length--;if(1<a.length){var c=
a[0],d=a[a.length-1];for(a.length=0;c!==d;)a.push(c),c=c.nextSibling;a.push(d)}}return a},wc:function(a,b){7>k?a.setAttribute("selected",b):a.selected=b},cb:function(a){return null===a||a===n?"":a.trim?a.trim():a.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},sd:function(a,b){a=a||"";return b.length>a.length?!1:a.substring(0,b.length)===b},Rc:function(a,b){if(a===b)return!0;if(11===a.nodeType)return!1;if(b.contains)return b.contains(3===a.nodeType?a.parentNode:a);if(b.compareDocumentPosition)return 16==
(b.compareDocumentPosition(a)&16);for(;a&&a!=b;)a=a.parentNode;return!!a},qb:function(b){return a.a.Rc(b,b.ownerDocument.documentElement)},Tb:function(b){return!!a.a.Vb(b,a.a.qb)},A:function(a){return a&&a.tagName&&a.tagName.toLowerCase()},Zb:function(b){return a.onError?function(){try{return b.apply(this,arguments)}catch(c){throw a.onError&&a.onError(c),c;}}:b},setTimeout:function(b,c){return setTimeout(a.a.Zb(b),c)},dc:function(b){setTimeout(function(){a.onError&&a.onError(b);throw b;},0)},q:function(b,
c,d){var e=a.a.Zb(d);d=k&&m[c];if(a.options.useOnlyNativeEvents||d||!u)if(d||"function"!=typeof b.addEventListener)if("undefined"!=typeof b.attachEvent){var f=function(a){e.call(b,a)},l="on"+c;b.attachEvent(l,f);a.a.G.qa(b,function(){b.detachEvent(l,f)})}else throw Error("Browser doesn't support addEventListener or attachEvent");else b.addEventListener(c,e,!1);else u(b).bind(c,e)},Fa:function(b,c){if(!b||!b.nodeType)throw Error("element must be a DOM node when calling triggerEvent");var d;"input"===
a.a.A(b)&&b.type&&"click"==c.toLowerCase()?(d=b.type,d="checkbox"==d||"radio"==d):d=!1;if(a.options.useOnlyNativeEvents||!u||d)if("function"==typeof t.createEvent)if("function"==typeof b.dispatchEvent)d=t.createEvent(l[c]||"HTMLEvents"),d.initEvent(c,!0,!0,x,0,0,0,0,0,!1,!1,!1,!1,0,b),b.dispatchEvent(d);else throw Error("The supplied element doesn't support dispatchEvent");else if(d&&b.click)b.click();else if("undefined"!=typeof b.fireEvent)b.fireEvent("on"+c);else throw Error("Browser doesn't support triggering events");
else u(b).trigger(c)},c:function(b){return a.I(b)?b():b},Bb:function(b){return a.I(b)?b.p():b},fb:function(b,c,d){var k;c&&("object"===typeof b.classList?(k=b.classList[d?"add":"remove"],a.a.r(c.match(r),function(a){k.call(b.classList,a)})):"string"===typeof b.className.baseVal?e(b.className,"baseVal",c,d):e(b,"className",c,d))},bb:function(b,c){var d=a.a.c(c);if(null===d||d===n)d="";var e=a.f.firstChild(b);!e||3!=e.nodeType||a.f.nextSibling(e)?a.f.fa(b,[b.ownerDocument.createTextNode(d)]):e.data=
d;a.a.Wc(b)},vc:function(a,b){a.name=b;if(7>=k)try{a.mergeAttributes(t.createElement("<input name='"+a.name+"'/>"),!1)}catch(c){}},Wc:function(a){9<=k&&(a=1==a.nodeType?a:a.parentNode,a.style&&(a.style.zoom=a.style.zoom))},Sc:function(a){if(k){var b=a.style.width;a.style.width=0;a.style.width=b}},nd:function(b,c){b=a.a.c(b);c=a.a.c(c);for(var d=[],e=b;e<=c;e++)d.push(e);return d},W:function(a){for(var b=[],c=0,d=a.length;c<d;c++)b.push(a[c]);return b},bc:function(a){return g?Symbol(a):a},xd:6===k,
yd:7===k,C:k,ic:function(b,c){for(var d=a.a.W(b.getElementsByTagName("input")).concat(a.a.W(b.getElementsByTagName("textarea"))),e="string"==typeof c?function(a){return a.name===c}:function(a){return c.test(a.name)},k=[],m=d.length-1;0<=m;m--)e(d[m])&&k.push(d[m]);return k},kd:function(b){return"string"==typeof b&&(b=a.a.cb(b))?H&&H.parse?H.parse(b):(new Function("return "+b))():null},Gb:function(b,c,d){if(!H||!H.stringify)throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
return H.stringify(a.a.c(b),c,d)},ld:function(c,d,e){e=e||{};var k=e.params||{},m=e.includeFields||this.gc,f=c;if("object"==typeof c&&"form"===a.a.A(c))for(var f=c.action,l=m.length-1;0<=l;l--)for(var g=a.a.ic(c,m[l]),h=g.length-1;0<=h;h--)k[g[h].name]=g[h].value;d=a.a.c(d);var r=t.createElement("form");r.style.display="none";r.action=f;r.method="post";for(var n in d)c=t.createElement("input"),c.type="hidden",c.name=n,c.value=a.a.Gb(a.a.c(d[n])),r.appendChild(c);b(k,function(a,b){var c=t.createElement("input");
c.type="hidden";c.name=a;c.value=b;r.appendChild(c)});t.body.appendChild(r);e.submitter?e.submitter(r):r.submit();setTimeout(function(){r.parentNode.removeChild(r)},0)}}}();a.b("utils",a.a);a.b("utils.arrayForEach",a.a.r);a.b("utils.arrayFirst",a.a.Vb);a.b("utils.arrayFilter",a.a.Ma);a.b("utils.arrayGetDistinctValues",a.a.Wb);a.b("utils.arrayIndexOf",a.a.o);a.b("utils.arrayMap",a.a.ib);a.b("utils.arrayPushAll",a.a.ta);a.b("utils.arrayRemoveItem",a.a.Na);a.b("utils.extend",a.a.extend);a.b("utils.fieldsIncludedWithJsonPost",
a.a.gc);a.b("utils.getFormFields",a.a.ic);a.b("utils.peekObservable",a.a.Bb);a.b("utils.postJson",a.a.ld);a.b("utils.parseJson",a.a.kd);a.b("utils.registerEventHandler",a.a.q);a.b("utils.stringifyJson",a.a.Gb);a.b("utils.range",a.a.nd);a.b("utils.toggleDomNodeCssClass",a.a.fb);a.b("utils.triggerEvent",a.a.Fa);a.b("utils.unwrapObservable",a.a.c);a.b("utils.objectForEach",a.a.D);a.b("utils.addOrRemoveItem",a.a.ra);a.b("utils.setTextContent",a.a.bb);a.b("unwrap",a.a.c);Function.prototype.bind||(Function.prototype.bind=
function(a){var c=this;if(1===arguments.length)return function(){return c.apply(a,arguments)};var d=Array.prototype.slice.call(arguments,1);return function(){var e=d.slice(0);e.push.apply(e,arguments);return c.apply(a,e)}});a.a.e=new function(){function a(b,g){var h=b[d];if(!h||"null"===h||!e[h]){if(!g)return n;h=b[d]="ko"+c++;e[h]={}}return e[h]}var c=0,d="__ko__"+(new Date).getTime(),e={};return{get:function(c,d){var e=a(c,!1);return e===n?n:e[d]},set:function(c,d,e){if(e!==n||a(c,!1)!==n)a(c,!0)[d]=
e},clear:function(a){var b=a[d];return b?(delete e[b],a[d]=null,!0):!1},J:function(){return c++ +d}}};a.b("utils.domData",a.a.e);a.b("utils.domData.clear",a.a.e.clear);a.a.G=new function(){function b(b,c){var e=a.a.e.get(b,d);e===n&&c&&(e=[],a.a.e.set(b,d,e));return e}function c(d){var e=b(d,!1);if(e)for(var e=e.slice(0),l=0;l<e.length;l++)e[l](d);a.a.e.clear(d);a.a.G.cleanExternalData(d);if(f[d.nodeType])for(e=d.firstChild;d=e;)e=d.nextSibling,8===d.nodeType&&c(d)}var d=a.a.e.J(),e={1:!0,8:!0,9:!0},
f={1:!0,9:!0};return{qa:function(a,c){if("function"!=typeof c)throw Error("Callback must be a function");b(a,!0).push(c)},tc:function(c,e){var f=b(c,!1);f&&(a.a.Na(f,e),0==f.length&&a.a.e.set(c,d,n))},ba:function(b){if(e[b.nodeType]&&(c(b),f[b.nodeType])){var d=[];a.a.ta(d,b.getElementsByTagName("*"));for(var l=0,m=d.length;l<m;l++)c(d[l])}return b},removeNode:function(b){a.ba(b);b.parentNode&&b.parentNode.removeChild(b)},cleanExternalData:function(a){u&&"function"==typeof u.cleanData&&u.cleanData([a])}}};
a.ba=a.a.G.ba;a.removeNode=a.a.G.removeNode;a.b("cleanNode",a.ba);a.b("removeNode",a.removeNode);a.b("utils.domNodeDisposal",a.a.G);a.b("utils.domNodeDisposal.addDisposeCallback",a.a.G.qa);a.b("utils.domNodeDisposal.removeDisposeCallback",a.a.G.tc);(function(){var b=[0,"",""],c=[1,"<table>","</table>"],d=[3,"<table><tbody><tr>","</tr></tbody></table>"],e=[1,"<select multiple='multiple'>","</select>"],f={thead:c,tbody:c,tfoot:c,tr:[2,"<table><tbody>","</tbody></table>"],td:d,th:d,option:e,optgroup:e},
g=8>=a.a.C;a.a.na=function(c,d){var e;if(u)if(u.parseHTML)e=u.parseHTML(c,d)||[];else{if((e=u.clean([c],d))&&e[0]){for(var k=e[0];k.parentNode&&11!==k.parentNode.nodeType;)k=k.parentNode;k.parentNode&&k.parentNode.removeChild(k)}}else{(e=d)||(e=t);var k=e.parentWindow||e.defaultView||x,r=a.a.cb(c).toLowerCase(),q=e.createElement("div"),p;p=(r=r.match(/^<([a-z]+)[ >]/))&&f[r[1]]||b;r=p[0];p="ignored<div>"+p[1]+c+p[2]+"</div>";"function"==typeof k.innerShiv?q.appendChild(k.innerShiv(p)):(g&&e.appendChild(q),
q.innerHTML=p,g&&q.parentNode.removeChild(q));for(;r--;)q=q.lastChild;e=a.a.W(q.lastChild.childNodes)}return e};a.a.Eb=function(b,c){a.a.rb(b);c=a.a.c(c);if(null!==c&&c!==n)if("string"!=typeof c&&(c=c.toString()),u)u(b).html(c);else for(var d=a.a.na(c,b.ownerDocument),e=0;e<d.length;e++)b.appendChild(d[e])}})();a.b("utils.parseHtmlFragment",a.a.na);a.b("utils.setHtml",a.a.Eb);a.N=function(){function b(c,e){if(c)if(8==c.nodeType){var f=a.N.pc(c.nodeValue);null!=f&&e.push({Qc:c,hd:f})}else if(1==c.nodeType)for(var f=
0,g=c.childNodes,h=g.length;f<h;f++)b(g[f],e)}var c={};return{yb:function(a){if("function"!=typeof a)throw Error("You can only pass a function to ko.memoization.memoize()");var b=(4294967296*(1+Math.random())|0).toString(16).substring(1)+(4294967296*(1+Math.random())|0).toString(16).substring(1);c[b]=a;return"\x3c!--[ko_memo:"+b+"]--\x3e"},Bc:function(a,b){var f=c[a];if(f===n)throw Error("Couldn't find any memo with ID "+a+". Perhaps it's already been unmemoized.");try{return f.apply(null,b||[]),
!0}finally{delete c[a]}},Cc:function(c,e){var f=[];b(c,f);for(var g=0,h=f.length;g<h;g++){var l=f[g].Qc,m=[l];e&&a.a.ta(m,e);a.N.Bc(f[g].hd,m);l.nodeValue="";l.parentNode&&l.parentNode.removeChild(l)}},pc:function(a){return(a=a.match(/^\[ko_memo\:(.*?)\]$/))?a[1]:null}}}();a.b("memoization",a.N);a.b("memoization.memoize",a.N.yb);a.b("memoization.unmemoize",a.N.Bc);a.b("memoization.parseMemoText",a.N.pc);a.b("memoization.unmemoizeDomNodeAndDescendants",a.N.Cc);a.Z=function(){function b(){if(e)for(var b=
e,c=0,m;g<e;)if(m=d[g++]){if(g>b){if(5E3<=++c){g=e;a.a.dc(Error("'Too much recursion' after processing "+c+" task groups."));break}b=e}try{m()}catch(k){a.a.dc(k)}}}function c(){b();g=e=d.length=0}var d=[],e=0,f=1,g=0;return{scheduler:x.MutationObserver?function(a){var b=t.createElement("div");(new MutationObserver(a)).observe(b,{attributes:!0});return function(){b.classList.toggle("foo")}}(c):t&&"onreadystatechange"in t.createElement("script")?function(a){var b=t.createElement("script");b.onreadystatechange=
function(){b.onreadystatechange=null;t.documentElement.removeChild(b);b=null;a()};t.documentElement.appendChild(b)}:function(a){setTimeout(a,0)},Za:function(b){e||a.Z.scheduler(c);d[e++]=b;return f++},cancel:function(a){a-=f-e;a>=g&&a<e&&(d[a]=null)},resetForTesting:function(){var a=e-g;g=e=d.length=0;return a},rd:b}}();a.b("tasks",a.Z);a.b("tasks.schedule",a.Z.Za);a.b("tasks.runEarly",a.Z.rd);a.Aa={throttle:function(b,c){b.throttleEvaluation=c;var d=null;return a.B({read:b,write:function(e){clearTimeout(d);
d=a.a.setTimeout(function(){b(e)},c)}})},rateLimit:function(a,c){var d,e,f;"number"==typeof c?d=c:(d=c.timeout,e=c.method);a.gb=!1;f="notifyWhenChangesStop"==e?T:S;a.Wa(function(a){return f(a,d)})},deferred:function(b,c){if(!0!==c)throw Error("The 'deferred' extender only accepts the value 'true', because it is not supported to turn deferral off once enabled.");b.gb||(b.gb=!0,b.Wa(function(c){var e,f=!1;return function(){if(!f){a.Z.cancel(e);e=a.Z.Za(c);try{f=!0,b.notifySubscribers(n,"dirty")}finally{f=
!1}}}}))},notify:function(a,c){a.equalityComparer="always"==c?null:J}};var R={undefined:1,"boolean":1,number:1,string:1};a.b("extenders",a.Aa);a.zc=function(b,c,d){this.$=b;this.jb=c;this.Pc=d;this.T=!1;a.H(this,"dispose",this.k)};a.zc.prototype.k=function(){this.T=!0;this.Pc()};a.K=function(){a.a.ab(this,D);D.ub(this)};var E="change",D={ub:function(a){a.F={change:[]};a.Qb=1},Y:function(b,c,d){var e=this;d=d||E;var f=new a.zc(e,c?b.bind(c):b,function(){a.a.Na(e.F[d],f);e.Ka&&e.Ka(d)});e.ua&&e.ua(d);
e.F[d]||(e.F[d]=[]);e.F[d].push(f);return f},notifySubscribers:function(b,c){c=c||E;c===E&&this.Kb();if(this.Ra(c)){var d=c===E&&this.Fc||this.F[c].slice(0);try{a.l.Xb();for(var e=0,f;f=d[e];++e)f.T||f.jb(b)}finally{a.l.end()}}},Pa:function(){return this.Qb},Zc:function(a){return this.Pa()!==a},Kb:function(){++this.Qb},Wa:function(b){var c=this,d=a.I(c),e,f,g,h;c.Ja||(c.Ja=c.notifySubscribers,c.notifySubscribers=U);var l=b(function(){c.Ha=!1;d&&h===c&&(h=c.Mb?c.Mb():c());var a=f||c.Ua(g,h);f=e=!1;
a&&c.Ja(g=h)});c.Pb=function(a){c.Fc=c.F[E].slice(0);c.Ha=e=!0;h=a;l()};c.Ob=function(a){e||(g=a,c.Ja(a,"beforeChange"))};c.Hc=function(){c.Ua(g,c.p(!0))&&(f=!0)}},Ra:function(a){return this.F[a]&&this.F[a].length},Xc:function(b){if(b)return this.F[b]&&this.F[b].length||0;var c=0;a.a.D(this.F,function(a,b){"dirty"!==a&&(c+=b.length)});return c},Ua:function(a,c){return!this.equalityComparer||!this.equalityComparer(a,c)},extend:function(b){var c=this;b&&a.a.D(b,function(b,e){var f=a.Aa[b];"function"==
typeof f&&(c=f(c,e)||c)});return c}};a.H(D,"subscribe",D.Y);a.H(D,"extend",D.extend);a.H(D,"getSubscriptionsCount",D.Xc);a.a.la&&a.a.$a(D,Function.prototype);a.K.fn=D;a.lc=function(a){return null!=a&&"function"==typeof a.Y&&"function"==typeof a.notifySubscribers};a.b("subscribable",a.K);a.b("isSubscribable",a.lc);a.xa=a.l=function(){function b(a){d.push(e);e=a}function c(){e=d.pop()}var d=[],e,f=0;return{Xb:b,end:c,sc:function(b){if(e){if(!a.lc(b))throw Error("Only subscribable things can act as dependencies");
e.jb.call(e.Lc,b,b.Gc||(b.Gc=++f))}},w:function(a,d,e){try{return b(),a.apply(d,e||[])}finally{c()}},Ca:function(){if(e)return e.m.Ca()},Va:function(){if(e)return e.Va}}}();a.b("computedContext",a.xa);a.b("computedContext.getDependenciesCount",a.xa.Ca);a.b("computedContext.isInitial",a.xa.Va);a.b("ignoreDependencies",a.wd=a.l.w);var F=a.a.bc("_latestValue");a.O=function(b){function c(){if(0<arguments.length)return c.Ua(c[F],arguments[0])&&(c.ia(),c[F]=arguments[0],c.ha()),this;a.l.sc(c);return c[F]}
c[F]=b;a.a.la||a.a.extend(c,a.K.fn);a.K.fn.ub(c);a.a.ab(c,B);a.options.deferUpdates&&a.Aa.deferred(c,!0);return c};var B={equalityComparer:J,p:function(){return this[F]},ha:function(){this.notifySubscribers(this[F])},ia:function(){this.notifySubscribers(this[F],"beforeChange")}};a.a.la&&a.a.$a(B,a.K.fn);var I=a.O.md="__ko_proto__";B[I]=a.O;a.Qa=function(b,c){return null===b||b===n||b[I]===n?!1:b[I]===c?!0:a.Qa(b[I],c)};a.I=function(b){return a.Qa(b,a.O)};a.Da=function(b){return"function"==typeof b&&
b[I]===a.O||"function"==typeof b&&b[I]===a.B&&b.$c?!0:!1};a.b("observable",a.O);a.b("isObservable",a.I);a.b("isWriteableObservable",a.Da);a.b("isWritableObservable",a.Da);a.b("observable.fn",B);a.H(B,"peek",B.p);a.H(B,"valueHasMutated",B.ha);a.H(B,"valueWillMutate",B.ia);a.ma=function(b){b=b||[];if("object"!=typeof b||!("length"in b))throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");b=a.O(b);a.a.ab(b,a.ma.fn);return b.extend({trackArrayChanges:!0})};
a.ma.fn={remove:function(b){for(var c=this.p(),d=[],e="function"!=typeof b||a.I(b)?function(a){return a===b}:b,f=0;f<c.length;f++){var g=c[f];e(g)&&(0===d.length&&this.ia(),d.push(g),c.splice(f,1),f--)}d.length&&this.ha();return d},removeAll:function(b){if(b===n){var c=this.p(),d=c.slice(0);this.ia();c.splice(0,c.length);this.ha();return d}return b?this.remove(function(c){return 0<=a.a.o(b,c)}):[]},destroy:function(b){var c=this.p(),d="function"!=typeof b||a.I(b)?function(a){return a===b}:b;this.ia();
for(var e=c.length-1;0<=e;e--)d(c[e])&&(c[e]._destroy=!0);this.ha()},destroyAll:function(b){return b===n?this.destroy(function(){return!0}):b?this.destroy(function(c){return 0<=a.a.o(b,c)}):[]},indexOf:function(b){var c=this();return a.a.o(c,b)},replace:function(a,c){var d=this.indexOf(a);0<=d&&(this.ia(),this.p()[d]=c,this.ha())}};a.a.la&&a.a.$a(a.ma.fn,a.O.fn);a.a.r("pop push reverse shift sort splice unshift".split(" "),function(b){a.ma.fn[b]=function(){var a=this.p();this.ia();this.Yb(a,b,arguments);
var d=a[b].apply(a,arguments);this.ha();return d===a?this:d}});a.a.r(["slice"],function(b){a.ma.fn[b]=function(){var a=this();return a[b].apply(a,arguments)}});a.b("observableArray",a.ma);a.Aa.trackArrayChanges=function(b,c){function d(){if(!e){e=!0;l=b.notifySubscribers;b.notifySubscribers=function(a,b){b&&b!==E||++h;return l.apply(this,arguments)};var c=[].concat(b.p()||[]);f=null;g=b.Y(function(d){d=[].concat(d||[]);if(b.Ra("arrayChange")){var e;if(!f||1<h)f=a.a.lb(c,d,b.kb);e=f}c=d;f=null;h=0;
e&&e.length&&b.notifySubscribers(e,"arrayChange")})}}b.kb={};c&&"object"==typeof c&&a.a.extend(b.kb,c);b.kb.sparse=!0;if(!b.Yb){var e=!1,f=null,g,h=0,l,m=b.ua,k=b.Ka;b.ua=function(a){m&&m.call(b,a);"arrayChange"===a&&d()};b.Ka=function(a){k&&k.call(b,a);"arrayChange"!==a||b.Ra("arrayChange")||(l&&(b.notifySubscribers=l,l=n),g.k(),e=!1)};b.Yb=function(b,c,d){function k(a,b,c){return m[m.length]={status:a,value:b,index:c}}if(e&&!h){var m=[],l=b.length,g=d.length,G=0;switch(c){case "push":G=l;case "unshift":for(c=
0;c<g;c++)k("added",d[c],G+c);break;case "pop":G=l-1;case "shift":l&&k("deleted",b[G],G);break;case "splice":c=Math.min(Math.max(0,0>d[0]?l+d[0]:d[0]),l);for(var l=1===g?l:Math.min(c+(d[1]||0),l),g=c+g-2,G=Math.max(l,g),n=[],s=[],w=2;c<G;++c,++w)c<l&&s.push(k("deleted",b[c],c)),c<g&&n.push(k("added",d[w],c));a.a.hc(s,n);break;default:return}f=m}}}};var s=a.a.bc("_state");a.m=a.B=function(b,c,d){function e(){if(0<arguments.length){if("function"===typeof f)f.apply(g.sb,arguments);else throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");
return this}a.l.sc(e);(g.V||g.t&&e.Sa())&&e.U();return g.M}"object"===typeof b?d=b:(d=d||{},b&&(d.read=b));if("function"!=typeof d.read)throw Error("Pass a function that returns the value of the ko.computed");var f=d.write,g={M:n,da:!0,V:!0,Ta:!1,Hb:!1,T:!1,Ya:!1,t:!1,od:d.read,sb:c||d.owner,i:d.disposeWhenNodeIsRemoved||d.i||null,ya:d.disposeWhen||d.ya,pb:null,s:{},L:0,fc:null};e[s]=g;e.$c="function"===typeof f;a.a.la||a.a.extend(e,a.K.fn);a.K.fn.ub(e);a.a.ab(e,z);d.pure?(g.Ya=!0,g.t=!0,a.a.extend(e,
Y)):d.deferEvaluation&&a.a.extend(e,Z);a.options.deferUpdates&&a.Aa.deferred(e,!0);g.i&&(g.Hb=!0,g.i.nodeType||(g.i=null));g.t||d.deferEvaluation||e.U();g.i&&e.ca()&&a.a.G.qa(g.i,g.pb=function(){e.k()});return e};var z={equalityComparer:J,Ca:function(){return this[s].L},Sb:function(a,c,d){if(this[s].Ya&&c===this)throw Error("A 'pure' computed must not be called recursively");this[s].s[a]=d;d.Ia=this[s].L++;d.pa=c.Pa()},Sa:function(){var a,c,d=this[s].s;for(a in d)if(d.hasOwnProperty(a)&&(c=d[a],this.oa&&
c.$.Ha||c.$.Zc(c.pa)))return!0},gd:function(){this.oa&&!this[s].Ta&&this.oa(!1)},ca:function(){var a=this[s];return a.V||0<a.L},qd:function(){this.Ha?this[s].V&&(this[s].da=!0):this.ec()},yc:function(a){if(a.gb&&!this[s].i){var c=a.Y(this.gd,this,"dirty"),d=a.Y(this.qd,this);return{$:a,k:function(){c.k();d.k()}}}return a.Y(this.ec,this)},ec:function(){var b=this,c=b.throttleEvaluation;c&&0<=c?(clearTimeout(this[s].fc),this[s].fc=a.a.setTimeout(function(){b.U(!0)},c)):b.oa?b.oa(!0):b.U(!0)},U:function(b){var c=
this[s],d=c.ya,e=!1;if(!c.Ta&&!c.T){if(c.i&&!a.a.qb(c.i)||d&&d()){if(!c.Hb){this.k();return}}else c.Hb=!1;c.Ta=!0;try{e=this.Vc(b)}finally{c.Ta=!1}c.L||this.k();return e}},Vc:function(b){var c=this[s],d=!1,e=c.Ya?n:!c.L,f={Mc:this,Oa:c.s,ob:c.L};a.l.Xb({Lc:f,jb:W,m:this,Va:e});c.s={};c.L=0;f=this.Uc(c,f);this.Ua(c.M,f)&&(c.t||this.notifySubscribers(c.M,"beforeChange"),c.M=f,c.t?this.Kb():b&&this.notifySubscribers(c.M),d=!0);e&&this.notifySubscribers(c.M,"awake");return d},Uc:function(b,c){try{var d=
b.od;return b.sb?d.call(b.sb):d()}finally{a.l.end(),c.ob&&!b.t&&a.a.D(c.Oa,V),b.da=b.V=!1}},p:function(a){var c=this[s];(c.V&&(a||!c.L)||c.t&&this.Sa())&&this.U();return c.M},Wa:function(b){a.K.fn.Wa.call(this,b);this.Mb=function(){this[s].da?this.U():this[s].V=!1;return this[s].M};this.oa=function(a){this.Ob(this[s].M);this[s].V=!0;a&&(this[s].da=!0);this.Pb(this)}},k:function(){var b=this[s];!b.t&&b.s&&a.a.D(b.s,function(a,b){b.k&&b.k()});b.i&&b.pb&&a.a.G.tc(b.i,b.pb);b.s=null;b.L=0;b.T=!0;b.da=
!1;b.V=!1;b.t=!1;b.i=null}},Y={ua:function(b){var c=this,d=c[s];if(!d.T&&d.t&&"change"==b){d.t=!1;if(d.da||c.Sa())d.s=null,d.L=0,c.U()&&c.Kb();else{var e=[];a.a.D(d.s,function(a,b){e[b.Ia]=a});a.a.r(e,function(a,b){var e=d.s[a],l=c.yc(e.$);l.Ia=b;l.pa=e.pa;d.s[a]=l})}d.T||c.notifySubscribers(d.M,"awake")}},Ka:function(b){var c=this[s];c.T||"change"!=b||this.Ra("change")||(a.a.D(c.s,function(a,b){b.k&&(c.s[a]={$:b.$,Ia:b.Ia,pa:b.pa},b.k())}),c.t=!0,this.notifySubscribers(n,"asleep"))},Pa:function(){var b=
this[s];b.t&&(b.da||this.Sa())&&this.U();return a.K.fn.Pa.call(this)}},Z={ua:function(a){"change"!=a&&"beforeChange"!=a||this.p()}};a.a.la&&a.a.$a(z,a.K.fn);var P=a.O.md;a.m[P]=a.O;z[P]=a.m;a.bd=function(b){return a.Qa(b,a.m)};a.cd=function(b){return a.Qa(b,a.m)&&b[s]&&b[s].Ya};a.b("computed",a.m);a.b("dependentObservable",a.m);a.b("isComputed",a.bd);a.b("isPureComputed",a.cd);a.b("computed.fn",z);a.H(z,"peek",z.p);a.H(z,"dispose",z.k);a.H(z,"isActive",z.ca);a.H(z,"getDependenciesCount",z.Ca);a.rc=
function(b,c){if("function"===typeof b)return a.m(b,c,{pure:!0});b=a.a.extend({},b);b.pure=!0;return a.m(b,c)};a.b("pureComputed",a.rc);(function(){function b(a,f,g){g=g||new d;a=f(a);if("object"!=typeof a||null===a||a===n||a instanceof RegExp||a instanceof Date||a instanceof String||a instanceof Number||a instanceof Boolean)return a;var h=a instanceof Array?[]:{};g.save(a,h);c(a,function(c){var d=f(a[c]);switch(typeof d){case "boolean":case "number":case "string":case "function":h[c]=d;break;case "object":case "undefined":var k=
g.get(d);h[c]=k!==n?k:b(d,f,g)}});return h}function c(a,b){if(a instanceof Array){for(var c=0;c<a.length;c++)b(c);"function"==typeof a.toJSON&&b("toJSON")}else for(c in a)b(c)}function d(){this.keys=[];this.Lb=[]}a.Ac=function(c){if(0==arguments.length)throw Error("When calling ko.toJS, pass the object you want to convert.");return b(c,function(b){for(var c=0;a.I(b)&&10>c;c++)b=b();return b})};a.toJSON=function(b,c,d){b=a.Ac(b);return a.a.Gb(b,c,d)};d.prototype={save:function(b,c){var d=a.a.o(this.keys,
b);0<=d?this.Lb[d]=c:(this.keys.push(b),this.Lb.push(c))},get:function(b){b=a.a.o(this.keys,b);return 0<=b?this.Lb[b]:n}}})();a.b("toJS",a.Ac);a.b("toJSON",a.toJSON);(function(){a.j={u:function(b){switch(a.a.A(b)){case "option":return!0===b.__ko__hasDomDataOptionValue__?a.a.e.get(b,a.d.options.zb):7>=a.a.C?b.getAttributeNode("value")&&b.getAttributeNode("value").specified?b.value:b.text:b.value;case "select":return 0<=b.selectedIndex?a.j.u(b.options[b.selectedIndex]):n;default:return b.value}},ja:function(b,
c,d){switch(a.a.A(b)){case "option":switch(typeof c){case "string":a.a.e.set(b,a.d.options.zb,n);"__ko__hasDomDataOptionValue__"in b&&delete b.__ko__hasDomDataOptionValue__;b.value=c;break;default:a.a.e.set(b,a.d.options.zb,c),b.__ko__hasDomDataOptionValue__=!0,b.value="number"===typeof c?c:""}break;case "select":if(""===c||null===c)c=n;for(var e=-1,f=0,g=b.options.length,h;f<g;++f)if(h=a.j.u(b.options[f]),h==c||""==h&&c===n){e=f;break}if(d||0<=e||c===n&&1<b.size)b.selectedIndex=e;break;default:if(null===
c||c===n)c="";b.value=c}}}})();a.b("selectExtensions",a.j);a.b("selectExtensions.readValue",a.j.u);a.b("selectExtensions.writeValue",a.j.ja);a.h=function(){function b(b){b=a.a.cb(b);123===b.charCodeAt(0)&&(b=b.slice(1,-1));var c=[],d=b.match(e),r,h=[],p=0;if(d){d.push(",");for(var A=0,y;y=d[A];++A){var v=y.charCodeAt(0);if(44===v){if(0>=p){c.push(r&&h.length?{key:r,value:h.join("")}:{unknown:r||h.join("")});r=p=0;h=[];continue}}else if(58===v){if(!p&&!r&&1===h.length){r=h.pop();continue}}else 47===
v&&A&&1<y.length?(v=d[A-1].match(f))&&!g[v[0]]&&(b=b.substr(b.indexOf(y)+1),d=b.match(e),d.push(","),A=-1,y="/"):40===v||123===v||91===v?++p:41===v||125===v||93===v?--p:r||h.length||34!==v&&39!==v||(y=y.slice(1,-1));h.push(y)}}return c}var c=["true","false","null","undefined"],d=/^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i,e=RegExp("\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'|/(?:[^/\\\\]|\\\\.)*/w*|[^\\s:,/][^,\"'{}()/:[\\]]*[^\\s,\"'{}()/:[\\]]|[^\\s]","g"),f=/[\])"'A-Za-z0-9_$]+$/,
g={"in":1,"return":1,"typeof":1},h={};return{va:[],ga:h,Ab:b,Xa:function(e,m){function k(b,e){var m;if(!A){var l=a.getBindingHandler(b);if(l&&l.preprocess&&!(e=l.preprocess(e,b,k)))return;if(l=h[b])m=e,0<=a.a.o(c,m)?m=!1:(l=m.match(d),m=null===l?!1:l[1]?"Object("+l[1]+")"+l[2]:m),l=m;l&&g.push("'"+b+"':function(_z){"+m+"=_z}")}p&&(e="function(){return "+e+" }");f.push("'"+b+"':"+e)}m=m||{};var f=[],g=[],p=m.valueAccessors,A=m.bindingParams,y="string"===typeof e?b(e):e;a.a.r(y,function(a){k(a.key||
a.unknown,a.value)});g.length&&k("_ko_property_writers","{"+g.join(",")+" }");return f.join(",")},fd:function(a,b){for(var c=0;c<a.length;c++)if(a[c].key==b)return!0;return!1},Ga:function(b,c,d,e,f){if(b&&a.I(b))!a.Da(b)||f&&b.p()===e||b(e);else if((b=c.get("_ko_property_writers"))&&b[d])b[d](e)}}}();a.b("expressionRewriting",a.h);a.b("expressionRewriting.bindingRewriteValidators",a.h.va);a.b("expressionRewriting.parseObjectLiteral",a.h.Ab);a.b("expressionRewriting.preProcessBindings",a.h.Xa);a.b("expressionRewriting._twoWayBindings",
a.h.ga);a.b("jsonExpressionRewriting",a.h);a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson",a.h.Xa);(function(){function b(a){return 8==a.nodeType&&g.test(f?a.text:a.nodeValue)}function c(a){return 8==a.nodeType&&h.test(f?a.text:a.nodeValue)}function d(a,d){for(var e=a,f=1,l=[];e=e.nextSibling;){if(c(e)&&(f--,0===f))return l;l.push(e);b(e)&&f++}if(!d)throw Error("Cannot find closing comment tag to match: "+a.nodeValue);return null}function e(a,b){var c=d(a,b);return c?0<c.length?c[c.length-
1].nextSibling:a.nextSibling:null}var f=t&&"\x3c!--test--\x3e"===t.createComment("test").text,g=f?/^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/:/^\s*ko(?:\s+([\s\S]+))?\s*$/,h=f?/^\x3c!--\s*\/ko\s*--\x3e$/:/^\s*\/ko\s*$/,l={ul:!0,ol:!0};a.f={aa:{},childNodes:function(a){return b(a)?d(a):a.childNodes},za:function(c){if(b(c)){c=a.f.childNodes(c);for(var d=0,e=c.length;d<e;d++)a.removeNode(c[d])}else a.a.rb(c)},fa:function(c,d){if(b(c)){a.f.za(c);for(var e=c.nextSibling,f=0,l=d.length;f<l;f++)e.parentNode.insertBefore(d[f],
e)}else a.a.fa(c,d)},qc:function(a,c){b(a)?a.parentNode.insertBefore(c,a.nextSibling):a.firstChild?a.insertBefore(c,a.firstChild):a.appendChild(c)},kc:function(c,d,e){e?b(c)?c.parentNode.insertBefore(d,e.nextSibling):e.nextSibling?c.insertBefore(d,e.nextSibling):c.appendChild(d):a.f.qc(c,d)},firstChild:function(a){return b(a)?!a.nextSibling||c(a.nextSibling)?null:a.nextSibling:a.firstChild},nextSibling:function(a){b(a)&&(a=e(a));return a.nextSibling&&c(a.nextSibling)?null:a.nextSibling},Yc:b,vd:function(a){return(a=
(f?a.text:a.nodeValue).match(g))?a[1]:null},oc:function(d){if(l[a.a.A(d)]){var k=d.firstChild;if(k){do if(1===k.nodeType){var f;f=k.firstChild;var g=null;if(f){do if(g)g.push(f);else if(b(f)){var h=e(f,!0);h?f=h:g=[f]}else c(f)&&(g=[f]);while(f=f.nextSibling)}if(f=g)for(g=k.nextSibling,h=0;h<f.length;h++)g?d.insertBefore(f[h],g):d.appendChild(f[h])}while(k=k.nextSibling)}}}}})();a.b("virtualElements",a.f);a.b("virtualElements.allowedBindings",a.f.aa);a.b("virtualElements.emptyNode",a.f.za);a.b("virtualElements.insertAfter",
a.f.kc);a.b("virtualElements.prepend",a.f.qc);a.b("virtualElements.setDomNodeChildren",a.f.fa);(function(){a.S=function(){this.Kc={}};a.a.extend(a.S.prototype,{nodeHasBindings:function(b){switch(b.nodeType){case 1:return null!=b.getAttribute("data-bind")||a.g.getComponentNameForNode(b);case 8:return a.f.Yc(b);default:return!1}},getBindings:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b):null;return a.g.Rb(d,b,c,!1)},getBindingAccessors:function(b,c){var d=this.getBindingsString(b,
c),d=d?this.parseBindingsString(d,c,b,{valueAccessors:!0}):null;return a.g.Rb(d,b,c,!0)},getBindingsString:function(b){switch(b.nodeType){case 1:return b.getAttribute("data-bind");case 8:return a.f.vd(b);default:return null}},parseBindingsString:function(b,c,d,e){try{var f=this.Kc,g=b+(e&&e.valueAccessors||""),h;if(!(h=f[g])){var l,m="with($context){with($data||{}){return{"+a.h.Xa(b,e)+"}}}";l=new Function("$context","$element",m);h=f[g]=l}return h(c,d)}catch(k){throw k.message="Unable to parse bindings.\nBindings value: "+
b+"\nMessage: "+k.message,k;}}});a.S.instance=new a.S})();a.b("bindingProvider",a.S);(function(){function b(a){return function(){return a}}function c(a){return a()}function d(b){return a.a.Ea(a.l.w(b),function(a,c){return function(){return b()[c]}})}function e(c,e,k){return"function"===typeof c?d(c.bind(null,e,k)):a.a.Ea(c,b)}function f(a,b){return d(this.getBindings.bind(this,a,b))}function g(b,c,d){var e,k=a.f.firstChild(c),f=a.S.instance,m=f.preprocessNode;if(m){for(;e=k;)k=a.f.nextSibling(e),
m.call(f,e);k=a.f.firstChild(c)}for(;e=k;)k=a.f.nextSibling(e),h(b,e,d)}function h(b,c,d){var e=!0,k=1===c.nodeType;k&&a.f.oc(c);if(k&&d||a.S.instance.nodeHasBindings(c))e=m(c,null,b,d).shouldBindDescendants;e&&!r[a.a.A(c)]&&g(b,c,!k)}function l(b){var c=[],d={},e=[];a.a.D(b,function X(k){if(!d[k]){var f=a.getBindingHandler(k);f&&(f.after&&(e.push(k),a.a.r(f.after,function(c){if(b[c]){if(-1!==a.a.o(e,c))throw Error("Cannot combine the following bindings, because they have a cyclic dependency: "+e.join(", "));
X(c)}}),e.length--),c.push({key:k,jc:f}));d[k]=!0}});return c}function m(b,d,e,k){var m=a.a.e.get(b,q);if(!d){if(m)throw Error("You cannot apply bindings multiple times to the same element.");a.a.e.set(b,q,!0)}!m&&k&&a.xc(b,e);var g;if(d&&"function"!==typeof d)g=d;else{var h=a.S.instance,r=h.getBindingAccessors||f,p=a.B(function(){(g=d?d(e,b):r.call(h,b,e))&&e.Q&&e.Q();return g},null,{i:b});g&&p.ca()||(p=null)}var s;if(g){var t=p?function(a){return function(){return c(p()[a])}}:function(a){return g[a]},
u=function(){return a.a.Ea(p?p():g,c)};u.get=function(a){return g[a]&&c(t(a))};u.has=function(a){return a in g};k=l(g);a.a.r(k,function(c){var d=c.jc.init,k=c.jc.update,f=c.key;if(8===b.nodeType&&!a.f.aa[f])throw Error("The binding '"+f+"' cannot be used with virtual elements");try{"function"==typeof d&&a.l.w(function(){var a=d(b,t(f),u,e.$data,e);if(a&&a.controlsDescendantBindings){if(s!==n)throw Error("Multiple bindings ("+s+" and "+f+") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");
s=f}}),"function"==typeof k&&a.B(function(){k(b,t(f),u,e.$data,e)},null,{i:b})}catch(m){throw m.message='Unable to process binding "'+f+": "+g[f]+'"\nMessage: '+m.message,m;}})}return{shouldBindDescendants:s===n}}function k(b){return b&&b instanceof a.R?b:new a.R(b)}a.d={};var r={script:!0,textarea:!0,template:!0};a.getBindingHandler=function(b){return a.d[b]};a.R=function(b,c,d,e,k){function f(){var k=g?b():b,m=a.a.c(k);c?(c.Q&&c.Q(),a.a.extend(l,c),l.Q=r):(l.$parents=[],l.$root=m,l.ko=a);l.$rawData=
k;l.$data=m;d&&(l[d]=m);e&&e(l,c,m);return l.$data}function m(){return h&&!a.a.Tb(h)}var l=this,g="function"==typeof b&&!a.I(b),h,r;k&&k.exportDependencies?f():(r=a.B(f,null,{ya:m,i:!0}),r.ca()&&(l.Q=r,r.equalityComparer=null,h=[],r.Dc=function(b){h.push(b);a.a.G.qa(b,function(b){a.a.Na(h,b);h.length||(r.k(),l.Q=r=n)})}))};a.R.prototype.createChildContext=function(b,c,d,e){return new a.R(b,this,c,function(a,b){a.$parentContext=b;a.$parent=b.$data;a.$parents=(b.$parents||[]).slice(0);a.$parents.unshift(a.$parent);
d&&d(a)},e)};a.R.prototype.extend=function(b){return new a.R(this.Q||this.$data,this,null,function(c,d){c.$rawData=d.$rawData;a.a.extend(c,"function"==typeof b?b():b)})};a.R.prototype.ac=function(a,b){return this.createChildContext(a,b,null,{exportDependencies:!0})};var q=a.a.e.J(),p=a.a.e.J();a.xc=function(b,c){if(2==arguments.length)a.a.e.set(b,p,c),c.Q&&c.Q.Dc(b);else return a.a.e.get(b,p)};a.La=function(b,c,d){1===b.nodeType&&a.f.oc(b);return m(b,c,k(d),!0)};a.Ic=function(b,c,d){d=k(d);return a.La(b,
e(c,d,b),d)};a.hb=function(a,b){1!==b.nodeType&&8!==b.nodeType||g(k(a),b,!0)};a.Ub=function(a,b){!u&&x.jQuery&&(u=x.jQuery);if(b&&1!==b.nodeType&&8!==b.nodeType)throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");b=b||x.document.body;h(k(a),b,!0)};a.nb=function(b){switch(b.nodeType){case 1:case 8:var c=a.xc(b);if(c)return c;if(b.parentNode)return a.nb(b.parentNode)}return n};a.Oc=function(b){return(b=a.nb(b))?b.$data:n};a.b("bindingHandlers",
a.d);a.b("applyBindings",a.Ub);a.b("applyBindingsToDescendants",a.hb);a.b("applyBindingAccessorsToNode",a.La);a.b("applyBindingsToNode",a.Ic);a.b("contextFor",a.nb);a.b("dataFor",a.Oc)})();(function(b){function c(c,e){var m=f.hasOwnProperty(c)?f[c]:b,k;m?m.Y(e):(m=f[c]=new a.K,m.Y(e),d(c,function(b,d){var e=!(!d||!d.synchronous);g[c]={definition:b,dd:e};delete f[c];k||e?m.notifySubscribers(b):a.Z.Za(function(){m.notifySubscribers(b)})}),k=!0)}function d(a,b){e("getConfig",[a],function(c){c?e("loadComponent",
[a,c],function(a){b(a,c)}):b(null,null)})}function e(c,d,f,k){k||(k=a.g.loaders.slice(0));var g=k.shift();if(g){var q=g[c];if(q){var p=!1;if(q.apply(g,d.concat(function(a){p?f(null):null!==a?f(a):e(c,d,f,k)}))!==b&&(p=!0,!g.suppressLoaderExceptions))throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.");}else e(c,d,f,k)}else f(null)}var f={},g={};a.g={get:function(d,e){var f=g.hasOwnProperty(d)?g[d]:b;f?f.dd?a.l.w(function(){e(f.definition)}):
a.Z.Za(function(){e(f.definition)}):c(d,e)},$b:function(a){delete g[a]},Nb:e};a.g.loaders=[];a.b("components",a.g);a.b("components.get",a.g.get);a.b("components.clearCachedDefinition",a.g.$b)})();(function(){function b(b,c,d,e){function g(){0===--y&&e(h)}var h={},y=2,v=d.template;d=d.viewModel;v?f(c,v,function(c){a.g.Nb("loadTemplate",[b,c],function(a){h.template=a;g()})}):g();d?f(c,d,function(c){a.g.Nb("loadViewModel",[b,c],function(a){h[l]=a;g()})}):g()}function c(a,b,d){if("function"===typeof b)d(function(a){return new b(a)});
else if("function"===typeof b[l])d(b[l]);else if("instance"in b){var e=b.instance;d(function(){return e})}else"viewModel"in b?c(a,b.viewModel,d):a("Unknown viewModel value: "+b)}function d(b){switch(a.a.A(b)){case "script":return a.a.na(b.text);case "textarea":return a.a.na(b.value);case "template":if(e(b.content))return a.a.wa(b.content.childNodes)}return a.a.wa(b.childNodes)}function e(a){return x.DocumentFragment?a instanceof DocumentFragment:a&&11===a.nodeType}function f(a,b,c){"string"===typeof b.require?
O||x.require?(O||x.require)([b.require],c):a("Uses require, but no AMD loader is present"):c(b)}function g(a){return function(b){throw Error("Component '"+a+"': "+b);}}var h={};a.g.register=function(b,c){if(!c)throw Error("Invalid configuration for "+b);if(a.g.wb(b))throw Error("Component "+b+" is already registered");h[b]=c};a.g.wb=function(a){return h.hasOwnProperty(a)};a.g.ud=function(b){delete h[b];a.g.$b(b)};a.g.cc={getConfig:function(a,b){b(h.hasOwnProperty(a)?h[a]:null)},loadComponent:function(a,
c,d){var e=g(a);f(e,c,function(c){b(a,e,c,d)})},loadTemplate:function(b,c,f){b=g(b);if("string"===typeof c)f(a.a.na(c));else if(c instanceof Array)f(c);else if(e(c))f(a.a.W(c.childNodes));else if(c.element)if(c=c.element,x.HTMLElement?c instanceof HTMLElement:c&&c.tagName&&1===c.nodeType)f(d(c));else if("string"===typeof c){var l=t.getElementById(c);l?f(d(l)):b("Cannot find element with ID "+c)}else b("Unknown element type: "+c);else b("Unknown template value: "+c)},loadViewModel:function(a,b,d){c(g(a),
b,d)}};var l="createViewModel";a.b("components.register",a.g.register);a.b("components.isRegistered",a.g.wb);a.b("components.unregister",a.g.ud);a.b("components.defaultLoader",a.g.cc);a.g.loaders.push(a.g.cc);a.g.Ec=h})();(function(){function b(b,e){var f=b.getAttribute("params");if(f){var f=c.parseBindingsString(f,e,b,{valueAccessors:!0,bindingParams:!0}),f=a.a.Ea(f,function(c){return a.m(c,null,{i:b})}),g=a.a.Ea(f,function(c){var e=c.p();return c.ca()?a.m({read:function(){return a.a.c(c())},write:a.Da(e)&&
function(a){c()(a)},i:b}):e});g.hasOwnProperty("$raw")||(g.$raw=f);return g}return{$raw:{}}}a.g.getComponentNameForNode=function(b){var c=a.a.A(b);if(a.g.wb(c)&&(-1!=c.indexOf("-")||"[object HTMLUnknownElement]"==""+b||8>=a.a.C&&b.tagName===c))return c};a.g.Rb=function(c,e,f,g){if(1===e.nodeType){var h=a.g.getComponentNameForNode(e);if(h){c=c||{};if(c.component)throw Error('Cannot use the "component" binding on a custom element matching a component');var l={name:h,params:b(e,f)};c.component=g?function(){return l}:
l}}return c};var c=new a.S;9>a.a.C&&(a.g.register=function(a){return function(b){t.createElement(b);return a.apply(this,arguments)}}(a.g.register),t.createDocumentFragment=function(b){return function(){var c=b(),f=a.g.Ec,g;for(g in f)f.hasOwnProperty(g)&&c.createElement(g);return c}}(t.createDocumentFragment))})();(function(b){function c(b,c,d){c=c.template;if(!c)throw Error("Component '"+b+"' has no template");b=a.a.wa(c);a.f.fa(d,b)}function d(a,b,c,d){var e=a.createViewModel;return e?e.call(a,
d,{element:b,templateNodes:c}):d}var e=0;a.d.component={init:function(f,g,h,l,m){function k(){var a=r&&r.dispose;"function"===typeof a&&a.call(r);q=r=null}var r,q,p=a.a.W(a.f.childNodes(f));a.a.G.qa(f,k);a.m(function(){var l=a.a.c(g()),h,v;"string"===typeof l?h=l:(h=a.a.c(l.name),v=a.a.c(l.params));if(!h)throw Error("No component name specified");var n=q=++e;a.g.get(h,function(e){if(q===n){k();if(!e)throw Error("Unknown component '"+h+"'");c(h,e,f);var l=d(e,f,p,v);e=m.createChildContext(l,b,function(a){a.$component=
l;a.$componentTemplateNodes=p});r=l;a.hb(e,f)}})},null,{i:f});return{controlsDescendantBindings:!0}}};a.f.aa.component=!0})();var Q={"class":"className","for":"htmlFor"};a.d.attr={update:function(b,c){var d=a.a.c(c())||{};a.a.D(d,function(c,d){d=a.a.c(d);var g=!1===d||null===d||d===n;g&&b.removeAttribute(c);8>=a.a.C&&c in Q?(c=Q[c],g?b.removeAttribute(c):b[c]=d):g||b.setAttribute(c,d.toString());"name"===c&&a.a.vc(b,g?"":d.toString())})}};(function(){a.d.checked={after:["value","attr"],init:function(b,
c,d){function e(){var e=b.checked,f=p?g():e;if(!a.xa.Va()&&(!l||e)){var h=a.l.w(c);if(k){var m=r?h.p():h;q!==f?(e&&(a.a.ra(m,f,!0),a.a.ra(m,q,!1)),q=f):a.a.ra(m,f,e);r&&a.Da(h)&&h(m)}else a.h.Ga(h,d,"checked",f,!0)}}function f(){var d=a.a.c(c());b.checked=k?0<=a.a.o(d,g()):h?d:g()===d}var g=a.rc(function(){return d.has("checkedValue")?a.a.c(d.get("checkedValue")):d.has("value")?a.a.c(d.get("value")):b.value}),h="checkbox"==b.type,l="radio"==b.type;if(h||l){var m=c(),k=h&&a.a.c(m)instanceof Array,
r=!(k&&m.push&&m.splice),q=k?g():n,p=l||k;l&&!b.name&&a.d.uniqueName.init(b,function(){return!0});a.m(e,null,{i:b});a.a.q(b,"click",e);a.m(f,null,{i:b});m=n}}};a.h.ga.checked=!0;a.d.checkedValue={update:function(b,c){b.value=a.a.c(c())}}})();a.d.css={update:function(b,c){var d=a.a.c(c());null!==d&&"object"==typeof d?a.a.D(d,function(c,d){d=a.a.c(d);a.a.fb(b,c,d)}):(d=a.a.cb(String(d||"")),a.a.fb(b,b.__ko__cssValue,!1),b.__ko__cssValue=d,a.a.fb(b,d,!0))}};a.d.enable={update:function(b,c){var d=a.a.c(c());
d&&b.disabled?b.removeAttribute("disabled"):d||b.disabled||(b.disabled=!0)}};a.d.disable={update:function(b,c){a.d.enable.update(b,function(){return!a.a.c(c())})}};a.d.event={init:function(b,c,d,e,f){var g=c()||{};a.a.D(g,function(g){"string"==typeof g&&a.a.q(b,g,function(b){var m,k=c()[g];if(k){try{var r=a.a.W(arguments);e=f.$data;r.unshift(e);m=k.apply(e,r)}finally{!0!==m&&(b.preventDefault?b.preventDefault():b.returnValue=!1)}!1===d.get(g+"Bubble")&&(b.cancelBubble=!0,b.stopPropagation&&b.stopPropagation())}})})}};
a.d.foreach={mc:function(b){return function(){var c=b(),d=a.a.Bb(c);if(!d||"number"==typeof d.length)return{foreach:c,templateEngine:a.X.vb};a.a.c(c);return{foreach:d.data,as:d.as,includeDestroyed:d.includeDestroyed,afterAdd:d.afterAdd,beforeRemove:d.beforeRemove,afterRender:d.afterRender,beforeMove:d.beforeMove,afterMove:d.afterMove,templateEngine:a.X.vb}}},init:function(b,c){return a.d.template.init(b,a.d.foreach.mc(c))},update:function(b,c,d,e,f){return a.d.template.update(b,a.d.foreach.mc(c),
d,e,f)}};a.h.va.foreach=!1;a.f.aa.foreach=!0;a.d.hasfocus={init:function(b,c,d){function e(e){b.__ko_hasfocusUpdating=!0;var f=b.ownerDocument;if("activeElement"in f){var g;try{g=f.activeElement}catch(k){g=f.body}e=g===b}f=c();a.h.Ga(f,d,"hasfocus",e,!0);b.__ko_hasfocusLastValue=e;b.__ko_hasfocusUpdating=!1}var f=e.bind(null,!0),g=e.bind(null,!1);a.a.q(b,"focus",f);a.a.q(b,"focusin",f);a.a.q(b,"blur",g);a.a.q(b,"focusout",g)},update:function(b,c){var d=!!a.a.c(c());b.__ko_hasfocusUpdating||b.__ko_hasfocusLastValue===
d||(d?b.focus():b.blur(),!d&&b.__ko_hasfocusLastValue&&b.ownerDocument.body.focus(),a.l.w(a.a.Fa,null,[b,d?"focusin":"focusout"]))}};a.h.ga.hasfocus=!0;a.d.hasFocus=a.d.hasfocus;a.h.ga.hasFocus=!0;a.d.html={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.Eb(b,c())}};K("if");K("ifnot",!1,!0);K("with",!0,!1,function(a,c){return a.ac(c)});var L={};a.d.options={init:function(b){if("select"!==a.a.A(b))throw Error("options binding applies only to SELECT elements");for(;0<
b.length;)b.remove(0);return{controlsDescendantBindings:!0}},update:function(b,c,d){function e(){return a.a.Ma(b.options,function(a){return a.selected})}function f(a,b,c){var d=typeof b;return"function"==d?b(a):"string"==d?a[b]:c}function g(c,e){if(A&&k)a.j.ja(b,a.a.c(d.get("value")),!0);else if(p.length){var f=0<=a.a.o(p,a.j.u(e[0]));a.a.wc(e[0],f);A&&!f&&a.l.w(a.a.Fa,null,[b,"change"])}}var h=b.multiple,l=0!=b.length&&h?b.scrollTop:null,m=a.a.c(c()),k=d.get("valueAllowUnset")&&d.has("value"),r=
d.get("optionsIncludeDestroyed");c={};var q,p=[];k||(h?p=a.a.ib(e(),a.j.u):0<=b.selectedIndex&&p.push(a.j.u(b.options[b.selectedIndex])));m&&("undefined"==typeof m.length&&(m=[m]),q=a.a.Ma(m,function(b){return r||b===n||null===b||!a.a.c(b._destroy)}),d.has("optionsCaption")&&(m=a.a.c(d.get("optionsCaption")),null!==m&&m!==n&&q.unshift(L)));var A=!1;c.beforeRemove=function(a){b.removeChild(a)};m=g;d.has("optionsAfterRender")&&"function"==typeof d.get("optionsAfterRender")&&(m=function(b,c){g(0,c);
a.l.w(d.get("optionsAfterRender"),null,[c[0],b!==L?b:n])});a.a.Db(b,q,function(c,e,g){g.length&&(p=!k&&g[0].selected?[a.j.u(g[0])]:[],A=!0);e=b.ownerDocument.createElement("option");c===L?(a.a.bb(e,d.get("optionsCaption")),a.j.ja(e,n)):(g=f(c,d.get("optionsValue"),c),a.j.ja(e,a.a.c(g)),c=f(c,d.get("optionsText"),g),a.a.bb(e,c));return[e]},c,m);a.l.w(function(){k?a.j.ja(b,a.a.c(d.get("value")),!0):(h?p.length&&e().length<p.length:p.length&&0<=b.selectedIndex?a.j.u(b.options[b.selectedIndex])!==p[0]:
p.length||0<=b.selectedIndex)&&a.a.Fa(b,"change")});a.a.Sc(b);l&&20<Math.abs(l-b.scrollTop)&&(b.scrollTop=l)}};a.d.options.zb=a.a.e.J();a.d.selectedOptions={after:["options","foreach"],init:function(b,c,d){a.a.q(b,"change",function(){var e=c(),f=[];a.a.r(b.getElementsByTagName("option"),function(b){b.selected&&f.push(a.j.u(b))});a.h.Ga(e,d,"selectedOptions",f)})},update:function(b,c){if("select"!=a.a.A(b))throw Error("values binding applies only to SELECT elements");var d=a.a.c(c()),e=b.scrollTop;
d&&"number"==typeof d.length&&a.a.r(b.getElementsByTagName("option"),function(b){var c=0<=a.a.o(d,a.j.u(b));b.selected!=c&&a.a.wc(b,c)});b.scrollTop=e}};a.h.ga.selectedOptions=!0;a.d.style={update:function(b,c){var d=a.a.c(c()||{});a.a.D(d,function(c,d){d=a.a.c(d);if(null===d||d===n||!1===d)d="";b.style[c]=d})}};a.d.submit={init:function(b,c,d,e,f){if("function"!=typeof c())throw Error("The value for a submit binding must be a function");a.a.q(b,"submit",function(a){var d,e=c();try{d=e.call(f.$data,
b)}finally{!0!==d&&(a.preventDefault?a.preventDefault():a.returnValue=!1)}})}};a.d.text={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.bb(b,c())}};a.f.aa.text=!0;(function(){if(x&&x.navigator)var b=function(a){if(a)return parseFloat(a[1])},c=x.opera&&x.opera.version&&parseInt(x.opera.version()),d=x.navigator.userAgent,e=b(d.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)),f=b(d.match(/Firefox\/([^ ]*)/));if(10>a.a.C)var g=a.a.e.J(),h=a.a.e.J(),l=function(b){var c=
this.activeElement;(c=c&&a.a.e.get(c,h))&&c(b)},m=function(b,c){var d=b.ownerDocument;a.a.e.get(d,g)||(a.a.e.set(d,g,!0),a.a.q(d,"selectionchange",l));a.a.e.set(b,h,c)};a.d.textInput={init:function(b,d,g){function l(c,d){a.a.q(b,c,d)}function h(){var c=a.a.c(d());if(null===c||c===n)c="";u!==n&&c===u?a.a.setTimeout(h,4):b.value!==c&&(s=c,b.value=c)}function y(){t||(u=b.value,t=a.a.setTimeout(v,4))}function v(){clearTimeout(t);u=t=n;var c=b.value;s!==c&&(s=c,a.h.Ga(d(),g,"textInput",c))}var s=b.value,
t,u,x=9==a.a.C?y:v;10>a.a.C?(l("propertychange",function(a){"value"===a.propertyName&&x(a)}),8==a.a.C&&(l("keyup",v),l("keydown",v)),8<=a.a.C&&(m(b,x),l("dragend",y))):(l("input",v),5>e&&"textarea"===a.a.A(b)?(l("keydown",y),l("paste",y),l("cut",y)):11>c?l("keydown",y):4>f&&(l("DOMAutoComplete",v),l("dragdrop",v),l("drop",v)));l("change",v);a.m(h,null,{i:b})}};a.h.ga.textInput=!0;a.d.textinput={preprocess:function(a,b,c){c("textInput",a)}}})();a.d.uniqueName={init:function(b,c){if(c()){var d="ko_unique_"+
++a.d.uniqueName.Nc;a.a.vc(b,d)}}};a.d.uniqueName.Nc=0;a.d.value={after:["options","foreach"],init:function(b,c,d){if("input"!=b.tagName.toLowerCase()||"checkbox"!=b.type&&"radio"!=b.type){var e=["change"],f=d.get("valueUpdate"),g=!1,h=null;f&&("string"==typeof f&&(f=[f]),a.a.ta(e,f),e=a.a.Wb(e));var l=function(){h=null;g=!1;var e=c(),f=a.j.u(b);a.h.Ga(e,d,"value",f)};!a.a.C||"input"!=b.tagName.toLowerCase()||"text"!=b.type||"off"==b.autocomplete||b.form&&"off"==b.form.autocomplete||-1!=a.a.o(e,"propertychange")||
(a.a.q(b,"propertychange",function(){g=!0}),a.a.q(b,"focus",function(){g=!1}),a.a.q(b,"blur",function(){g&&l()}));a.a.r(e,function(c){var d=l;a.a.sd(c,"after")&&(d=function(){h=a.j.u(b);a.a.setTimeout(l,0)},c=c.substring(5));a.a.q(b,c,d)});var m=function(){var e=a.a.c(c()),f=a.j.u(b);if(null!==h&&e===h)a.a.setTimeout(m,0);else if(e!==f)if("select"===a.a.A(b)){var g=d.get("valueAllowUnset"),f=function(){a.j.ja(b,e,g)};f();g||e===a.j.u(b)?a.a.setTimeout(f,0):a.l.w(a.a.Fa,null,[b,"change"])}else a.j.ja(b,
e)};a.m(m,null,{i:b})}else a.La(b,{checkedValue:c})},update:function(){}};a.h.ga.value=!0;a.d.visible={update:function(b,c){var d=a.a.c(c()),e="none"!=b.style.display;d&&!e?b.style.display="":!d&&e&&(b.style.display="none")}};(function(b){a.d[b]={init:function(c,d,e,f,g){return a.d.event.init.call(this,c,function(){var a={};a[b]=d();return a},e,f,g)}}})("click");a.P=function(){};a.P.prototype.renderTemplateSource=function(){throw Error("Override renderTemplateSource");};a.P.prototype.createJavaScriptEvaluatorBlock=
function(){throw Error("Override createJavaScriptEvaluatorBlock");};a.P.prototype.makeTemplateSource=function(b,c){if("string"==typeof b){c=c||t;var d=c.getElementById(b);if(!d)throw Error("Cannot find template with ID "+b);return new a.v.n(d)}if(1==b.nodeType||8==b.nodeType)return new a.v.sa(b);throw Error("Unknown template type: "+b);};a.P.prototype.renderTemplate=function(a,c,d,e){a=this.makeTemplateSource(a,e);return this.renderTemplateSource(a,c,d,e)};a.P.prototype.isTemplateRewritten=function(a,
c){return!1===this.allowTemplateRewriting?!0:this.makeTemplateSource(a,c).data("isRewritten")};a.P.prototype.rewriteTemplate=function(a,c,d){a=this.makeTemplateSource(a,d);c=c(a.text());a.text(c);a.data("isRewritten",!0)};a.b("templateEngine",a.P);a.Ib=function(){function b(b,c,d,h){b=a.h.Ab(b);for(var l=a.h.va,m=0;m<b.length;m++){var k=b[m].key;if(l.hasOwnProperty(k)){var r=l[k];if("function"===typeof r){if(k=r(b[m].value))throw Error(k);}else if(!r)throw Error("This template engine does not support the '"+
k+"' binding within its templates");}}d="ko.__tr_ambtns(function($context,$element){return(function(){return{ "+a.h.Xa(b,{valueAccessors:!0})+" } })()},'"+d.toLowerCase()+"')";return h.createJavaScriptEvaluatorBlock(d)+c}var c=/(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'|[^>]*))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi,d=/\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;return{Tc:function(b,c,d){c.isTemplateRewritten(b,d)||c.rewriteTemplate(b,function(b){return a.Ib.jd(b,
c)},d)},jd:function(a,f){return a.replace(c,function(a,c,d,e,k){return b(k,c,d,f)}).replace(d,function(a,c){return b(c,"\x3c!-- ko --\x3e","#comment",f)})},Jc:function(b,c){return a.N.yb(function(d,h){var l=d.nextSibling;l&&l.nodeName.toLowerCase()===c&&a.La(l,b,h)})}}}();a.b("__tr_ambtns",a.Ib.Jc);(function(){a.v={};a.v.n=function(b){if(this.n=b){var c=a.a.A(b);this.eb="script"===c?1:"textarea"===c?2:"template"==c&&b.content&&11===b.content.nodeType?3:4}};a.v.n.prototype.text=function(){var b=1===
this.eb?"text":2===this.eb?"value":"innerHTML";if(0==arguments.length)return this.n[b];var c=arguments[0];"innerHTML"===b?a.a.Eb(this.n,c):this.n[b]=c};var b=a.a.e.J()+"_";a.v.n.prototype.data=function(c){if(1===arguments.length)return a.a.e.get(this.n,b+c);a.a.e.set(this.n,b+c,arguments[1])};var c=a.a.e.J();a.v.n.prototype.nodes=function(){var b=this.n;if(0==arguments.length)return(a.a.e.get(b,c)||{}).mb||(3===this.eb?b.content:4===this.eb?b:n);a.a.e.set(b,c,{mb:arguments[0]})};a.v.sa=function(a){this.n=
a};a.v.sa.prototype=new a.v.n;a.v.sa.prototype.text=function(){if(0==arguments.length){var b=a.a.e.get(this.n,c)||{};b.Jb===n&&b.mb&&(b.Jb=b.mb.innerHTML);return b.Jb}a.a.e.set(this.n,c,{Jb:arguments[0]})};a.b("templateSources",a.v);a.b("templateSources.domElement",a.v.n);a.b("templateSources.anonymousTemplate",a.v.sa)})();(function(){function b(b,c,d){var e;for(c=a.f.nextSibling(c);b&&(e=b)!==c;)b=a.f.nextSibling(e),d(e,b)}function c(c,d){if(c.length){var e=c[0],f=c[c.length-1],g=e.parentNode,h=
a.S.instance,n=h.preprocessNode;if(n){b(e,f,function(a,b){var c=a.previousSibling,d=n.call(h,a);d&&(a===e&&(e=d[0]||b),a===f&&(f=d[d.length-1]||c))});c.length=0;if(!e)return;e===f?c.push(e):(c.push(e,f),a.a.Ba(c,g))}b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.Ub(d,b)});b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.N.Cc(b,[d])});a.a.Ba(c,g)}}function d(a){return a.nodeType?a:0<a.length?a[0]:null}function e(b,e,f,h,q){q=q||{};var p=(b&&d(b)||f||{}).ownerDocument,n=q.templateEngine||g;
a.Ib.Tc(f,n,p);f=n.renderTemplate(f,h,q,p);if("number"!=typeof f.length||0<f.length&&"number"!=typeof f[0].nodeType)throw Error("Template engine must return an array of DOM nodes");p=!1;switch(e){case "replaceChildren":a.f.fa(b,f);p=!0;break;case "replaceNode":a.a.uc(b,f);p=!0;break;case "ignoreTargetNode":break;default:throw Error("Unknown renderMode: "+e);}p&&(c(f,h),q.afterRender&&a.l.w(q.afterRender,null,[f,h.$data]));return f}function f(b,c,d){return a.I(b)?b():"function"===typeof b?b(c,d):b}
var g;a.Fb=function(b){if(b!=n&&!(b instanceof a.P))throw Error("templateEngine must inherit from ko.templateEngine");g=b};a.Cb=function(b,c,k,h,q){k=k||{};if((k.templateEngine||g)==n)throw Error("Set a template engine before calling renderTemplate");q=q||"replaceChildren";if(h){var p=d(h);return a.B(function(){var g=c&&c instanceof a.R?c:new a.R(c,null,null,null,{exportDependencies:!0}),n=f(b,g.$data,g),g=e(h,q,n,g,k);"replaceNode"==q&&(h=g,p=d(h))},null,{ya:function(){return!p||!a.a.qb(p)},i:p&&
"replaceNode"==q?p.parentNode:p})}return a.N.yb(function(d){a.Cb(b,c,k,d,"replaceNode")})};a.pd=function(b,d,g,h,q){function p(a,b){c(b,t);g.afterRender&&g.afterRender(b,a);t=null}function s(a,c){t=q.createChildContext(a,g.as,function(a){a.$index=c});var d=f(b,a,t);return e(null,"ignoreTargetNode",d,t,g)}var t;return a.B(function(){var b=a.a.c(d)||[];"undefined"==typeof b.length&&(b=[b]);b=a.a.Ma(b,function(b){return g.includeDestroyed||b===n||null===b||!a.a.c(b._destroy)});a.l.w(a.a.Db,null,[h,b,
s,g,p])},null,{i:h})};var h=a.a.e.J();a.d.template={init:function(b,c){var d=a.a.c(c());if("string"==typeof d||d.name)a.f.za(b);else{if("nodes"in d){if(d=d.nodes||[],a.I(d))throw Error('The "nodes" option must be a plain, non-observable array.');}else d=a.f.childNodes(b);d=a.a.nc(d);(new a.v.sa(b)).nodes(d)}return{controlsDescendantBindings:!0}},update:function(b,c,d,e,f){var g=c();c=a.a.c(g);d=!0;e=null;"string"==typeof c?c={}:(g=c.name,"if"in c&&(d=a.a.c(c["if"])),d&&"ifnot"in c&&(d=!a.a.c(c.ifnot)));
"foreach"in c?e=a.pd(g||b,d&&c.foreach||[],c,b,f):d?(f="data"in c?f.ac(c.data,c.as):f,e=a.Cb(g||b,f,c,b)):a.f.za(b);f=e;(c=a.a.e.get(b,h))&&"function"==typeof c.k&&c.k();a.a.e.set(b,h,f&&f.ca()?f:n)}};a.h.va.template=function(b){b=a.h.Ab(b);return 1==b.length&&b[0].unknown||a.h.fd(b,"name")?null:"This template engine does not support anonymous templates nested within its templates"};a.f.aa.template=!0})();a.b("setTemplateEngine",a.Fb);a.b("renderTemplate",a.Cb);a.a.hc=function(a,c,d){if(a.length&&
c.length){var e,f,g,h,l;for(e=f=0;(!d||e<d)&&(h=a[f]);++f){for(g=0;l=c[g];++g)if(h.value===l.value){h.moved=l.index;l.moved=h.index;c.splice(g,1);e=g=0;break}e+=g}}};a.a.lb=function(){function b(b,d,e,f,g){var h=Math.min,l=Math.max,m=[],k,n=b.length,q,p=d.length,s=p-n||1,t=n+p+1,v,u,x;for(k=0;k<=n;k++)for(u=v,m.push(v=[]),x=h(p,k+s),q=l(0,k-1);q<=x;q++)v[q]=q?k?b[k-1]===d[q-1]?u[q-1]:h(u[q]||t,v[q-1]||t)+1:q+1:k+1;h=[];l=[];s=[];k=n;for(q=p;k||q;)p=m[k][q]-1,q&&p===m[k][q-1]?l.push(h[h.length]={status:e,
value:d[--q],index:q}):k&&p===m[k-1][q]?s.push(h[h.length]={status:f,value:b[--k],index:k}):(--q,--k,g.sparse||h.push({status:"retained",value:d[q]}));a.a.hc(s,l,!g.dontLimitMoves&&10*n);return h.reverse()}return function(a,d,e){e="boolean"===typeof e?{dontLimitMoves:e}:e||{};a=a||[];d=d||[];return a.length<d.length?b(a,d,"added","deleted",e):b(d,a,"deleted","added",e)}}();a.b("utils.compareArrays",a.a.lb);(function(){function b(b,c,d,h,l){var m=[],k=a.B(function(){var k=c(d,l,a.a.Ba(m,b))||[];0<
m.length&&(a.a.uc(m,k),h&&a.l.w(h,null,[d,k,l]));m.length=0;a.a.ta(m,k)},null,{i:b,ya:function(){return!a.a.Tb(m)}});return{ea:m,B:k.ca()?k:n}}var c=a.a.e.J(),d=a.a.e.J();a.a.Db=function(e,f,g,h,l){function m(b,c){w=q[c];u!==c&&(D[b]=w);w.tb(u++);a.a.Ba(w.ea,e);t.push(w);z.push(w)}function k(b,c){if(b)for(var d=0,e=c.length;d<e;d++)c[d]&&a.a.r(c[d].ea,function(a){b(a,d,c[d].ka)})}f=f||[];h=h||{};var r=a.a.e.get(e,c)===n,q=a.a.e.get(e,c)||[],p=a.a.ib(q,function(a){return a.ka}),s=a.a.lb(p,f,h.dontLimitMoves),
t=[],v=0,u=0,x=[],z=[];f=[];for(var D=[],p=[],w,C=0,B,E;B=s[C];C++)switch(E=B.moved,B.status){case "deleted":E===n&&(w=q[v],w.B&&(w.B.k(),w.B=n),a.a.Ba(w.ea,e).length&&(h.beforeRemove&&(t.push(w),z.push(w),w.ka===d?w=null:f[C]=w),w&&x.push.apply(x,w.ea)));v++;break;case "retained":m(C,v++);break;case "added":E!==n?m(C,E):(w={ka:B.value,tb:a.O(u++)},t.push(w),z.push(w),r||(p[C]=w))}a.a.e.set(e,c,t);k(h.beforeMove,D);a.a.r(x,h.beforeRemove?a.ba:a.removeNode);for(var C=0,r=a.f.firstChild(e),F;w=z[C];C++){w.ea||
a.a.extend(w,b(e,g,w.ka,l,w.tb));for(v=0;s=w.ea[v];r=s.nextSibling,F=s,v++)s!==r&&a.f.kc(e,s,F);!w.ad&&l&&(l(w.ka,w.ea,w.tb),w.ad=!0)}k(h.beforeRemove,f);for(C=0;C<f.length;++C)f[C]&&(f[C].ka=d);k(h.afterMove,D);k(h.afterAdd,p)}})();a.b("utils.setDomNodeChildrenFromArrayMapping",a.a.Db);a.X=function(){this.allowTemplateRewriting=!1};a.X.prototype=new a.P;a.X.prototype.renderTemplateSource=function(b,c,d,e){if(c=(9>a.a.C?0:b.nodes)?b.nodes():null)return a.a.W(c.cloneNode(!0).childNodes);b=b.text();
return a.a.na(b,e)};a.X.vb=new a.X;a.Fb(a.X.vb);a.b("nativeTemplateEngine",a.X);(function(){a.xb=function(){var a=this.ed=function(){if(!u||!u.tmpl)return 0;try{if(0<=u.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2}catch(a){}return 1}();this.renderTemplateSource=function(b,e,f,g){g=g||t;f=f||{};if(2>a)throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");var h=b.data("precompiled");h||(h=b.text()||"",h=u.template(null,"{{ko_with $item.koBindingContext}}"+
h+"{{/ko_with}}"),b.data("precompiled",h));b=[e.$data];e=u.extend({koBindingContext:e},f.templateOptions);e=u.tmpl(h,b,e);e.appendTo(g.createElement("div"));u.fragments={};return e};this.createJavaScriptEvaluatorBlock=function(a){return"{{ko_code ((function() { return "+a+" })()) }}"};this.addTemplate=function(a,b){t.write("<script type='text/html' id='"+a+"'>"+b+"\x3c/script>")};0<a&&(u.tmpl.tag.ko_code={open:"__.push($1 || '');"},u.tmpl.tag.ko_with={open:"with($1) {",close:"} "})};a.xb.prototype=
new a.P;var b=new a.xb;0<b.ed&&a.Fb(b);a.b("jqueryTmplTemplateEngine",a.xb)})()})})();})();

/// Knockout Mapping plugin v2.4.1
/// (c) 2013 Steven Sanderson, Roy Jacobs - http://knockoutjs.com/
/// License: MIT (http://www.opensource.org/licenses/mit-license.php)
(function(e){"function"===typeof require&&"object"===typeof exports&&"object"===typeof module?e(require("ko"),exports):"function"===typeof define&&define.amd?define('mapping',["ko","exports"],e):e(ko,ko.mapping={})})(function(e,f){function y(b,c){var a,d;for(d in c)if(c.hasOwnProperty(d)&&c[d])if(a=f.getType(b[d]),d&&b[d]&&"array"!==a&&"string"!==a)y(b[d],c[d]);else if("array"===f.getType(b[d])&&"array"===f.getType(c[d])){a=b;for(var e=d,l=b[d],n=c[d],t={},g=l.length-1;0<=g;--g)t[l[g]]=l[g];for(g=
n.length-1;0<=g;--g)t[n[g]]=n[g];l=[];n=void 0;for(n in t)l.push(t[n]);a[e]=l}else b[d]=c[d]}function E(b,c){var a={};y(a,b);y(a,c);return a}function z(b,c){for(var a=E({},b),e=L.length-1;0<=e;e--){var f=L[e];a[f]&&(a[""]instanceof Object||(a[""]={}),a[""][f]=a[f],delete a[f])}c&&(a.ignore=h(c.ignore,a.ignore),a.include=h(c.include,a.include),a.copy=h(c.copy,a.copy),a.observe=h(c.observe,a.observe));a.ignore=h(a.ignore,j.ignore);a.include=h(a.include,j.include);a.copy=h(a.copy,j.copy);a.observe=h(a.observe,
j.observe);a.mappedProperties=a.mappedProperties||{};a.copiedProperties=a.copiedProperties||{};return a}function h(b,c){"array"!==f.getType(b)&&(b="undefined"===f.getType(b)?[]:[b]);"array"!==f.getType(c)&&(c="undefined"===f.getType(c)?[]:[c]);return e.utils.arrayGetDistinctValues(b.concat(c))}function F(b,c,a,d,k,l,n){var t="array"===f.getType(e.utils.unwrapObservable(c));l=l||"";if(f.isMapped(b)){var g=e.utils.unwrapObservable(b)[p];a=E(g,a)}var j=n||k,h=function(){return a[d]&&a[d].create instanceof
Function},x=function(b){var f=G,g=e.dependentObservable;e.dependentObservable=function(a,b,c){c=c||{};a&&"object"==typeof a&&(c=a);var d=c.deferEvaluation,M=!1;c.deferEvaluation=!0;a=new H(a,b,c);if(!d){var g=a,d=e.dependentObservable;e.dependentObservable=H;a=e.isWriteableObservable(g);e.dependentObservable=d;d=H({read:function(){M||(e.utils.arrayRemoveItem(f,g),M=!0);return g.apply(g,arguments)},write:a&&function(a){return g(a)},deferEvaluation:!0});d.__DO=g;a=d;f.push(a)}return a};e.dependentObservable.fn=
H.fn;e.computed=e.dependentObservable;b=e.utils.unwrapObservable(k)instanceof Array?a[d].create({data:b||c,parent:j,skip:N}):a[d].create({data:b||c,parent:j});e.dependentObservable=g;e.computed=e.dependentObservable;return b},u=function(){return a[d]&&a[d].update instanceof Function},v=function(b,f){var g={data:f||c,parent:j,target:e.utils.unwrapObservable(b)};e.isWriteableObservable(b)&&(g.observable=b);return a[d].update(g)};if(n=I.get(c))return n;d=d||"";if(t){var t=[],s=!1,m=function(a){return a};
a[d]&&a[d].key&&(m=a[d].key,s=!0);e.isObservable(b)||(b=e.observableArray([]),b.mappedRemove=function(a){var c="function"==typeof a?a:function(b){return b===m(a)};return b.remove(function(a){return c(m(a))})},b.mappedRemoveAll=function(a){var c=C(a,m);return b.remove(function(a){return-1!=e.utils.arrayIndexOf(c,m(a))})},b.mappedDestroy=function(a){var c="function"==typeof a?a:function(b){return b===m(a)};return b.destroy(function(a){return c(m(a))})},b.mappedDestroyAll=function(a){var c=C(a,m);return b.destroy(function(a){return-1!=
e.utils.arrayIndexOf(c,m(a))})},b.mappedIndexOf=function(a){var c=C(b(),m);a=m(a);return e.utils.arrayIndexOf(c,a)},b.mappedGet=function(a){return b()[b.mappedIndexOf(a)]},b.mappedCreate=function(a){if(-1!==b.mappedIndexOf(a))throw Error("There already is an object with the key that you specified.");var c=h()?x(a):a;u()&&(a=v(c,a),e.isWriteableObservable(c)?c(a):c=a);b.push(c);return c});n=C(e.utils.unwrapObservable(b),m).sort();g=C(c,m);s&&g.sort();s=e.utils.compareArrays(n,g);n={};var J,A=e.utils.unwrapObservable(c),
y={},z=!0,g=0;for(J=A.length;g<J;g++){var r=m(A[g]);if(void 0===r||r instanceof Object){z=!1;break}y[r]=A[g]}var A=[],B=0,g=0;for(J=s.length;g<J;g++){var r=s[g],q,w=l+"["+g+"]";switch(r.status){case "added":var D=z?y[r.value]:K(e.utils.unwrapObservable(c),r.value,m);q=F(void 0,D,a,d,b,w,k);h()||(q=e.utils.unwrapObservable(q));w=O(e.utils.unwrapObservable(c),D,n);q===N?B++:A[w-B]=q;n[w]=!0;break;case "retained":D=z?y[r.value]:K(e.utils.unwrapObservable(c),r.value,m);q=K(b,r.value,m);F(q,D,a,d,b,w,
k);w=O(e.utils.unwrapObservable(c),D,n);A[w]=q;n[w]=!0;break;case "deleted":q=K(b,r.value,m)}t.push({event:r.status,item:q})}b(A);a[d]&&a[d].arrayChanged&&e.utils.arrayForEach(t,function(b){a[d].arrayChanged(b.event,b.item)})}else if(P(c)){b=e.utils.unwrapObservable(b);if(!b){if(h())return s=x(),u()&&(s=v(s)),s;if(u())return v(s);b={}}u()&&(b=v(b));I.save(c,b);if(u())return b;Q(c,function(d){var f=l.length?l+"."+d:d;if(-1==e.utils.arrayIndexOf(a.ignore,f))if(-1!=e.utils.arrayIndexOf(a.copy,f))b[d]=
c[d];else if("object"!=typeof c[d]&&"array"!=typeof c[d]&&0<a.observe.length&&-1==e.utils.arrayIndexOf(a.observe,f))b[d]=c[d],a.copiedProperties[f]=!0;else{var g=I.get(c[d]),k=F(b[d],c[d],a,d,b,f,b),g=g||k;if(0<a.observe.length&&-1==e.utils.arrayIndexOf(a.observe,f))b[d]=g(),a.copiedProperties[f]=!0;else{if(e.isWriteableObservable(b[d])){if(g=e.utils.unwrapObservable(g),b[d]()!==g)b[d](g)}else g=void 0===b[d]?g:e.utils.unwrapObservable(g),b[d]=g;a.mappedProperties[f]=!0}}})}else switch(f.getType(c)){case "function":u()?
e.isWriteableObservable(c)?(c(v(c)),b=c):b=v(c):b=c;break;default:if(e.isWriteableObservable(b))return q=u()?v(b):e.utils.unwrapObservable(c),b(q),q;h()||u();b=h()?x():e.observable(e.utils.unwrapObservable(c));u()&&b(v(b))}return b}function O(b,c,a){for(var d=0,e=b.length;d<e;d++)if(!0!==a[d]&&b[d]===c)return d;return null}function R(b,c){var a;c&&(a=c(b));"undefined"===f.getType(a)&&(a=b);return e.utils.unwrapObservable(a)}function K(b,c,a){b=e.utils.unwrapObservable(b);for(var d=0,f=b.length;d<
f;d++){var l=b[d];if(R(l,a)===c)return l}throw Error("When calling ko.update*, the key '"+c+"' was not found!");}function C(b,c){return e.utils.arrayMap(e.utils.unwrapObservable(b),function(a){return c?R(a,c):a})}function Q(b,c){if("array"===f.getType(b))for(var a=0;a<b.length;a++)c(a);else for(a in b)c(a)}function P(b){var c=f.getType(b);return("object"===c||"array"===c)&&null!==b}function T(){var b=[],c=[];this.save=function(a,d){var f=e.utils.arrayIndexOf(b,a);0<=f?c[f]=d:(b.push(a),c.push(d))};
this.get=function(a){a=e.utils.arrayIndexOf(b,a);return 0<=a?c[a]:void 0}}function S(){var b={},c=function(a){var c;try{c=a}catch(e){c="$$$"}a=b[c];void 0===a&&(a=new T,b[c]=a);return a};this.save=function(a,b){c(a).save(a,b)};this.get=function(a){return c(a).get(a)}}var p="__ko_mapping__",H=e.dependentObservable,B=0,G,I,L=["create","update","key","arrayChanged"],N={},x={include:["_destroy"],ignore:[],copy:[],observe:[]},j=x;f.isMapped=function(b){return(b=e.utils.unwrapObservable(b))&&b[p]};f.fromJS=
function(b){if(0==arguments.length)throw Error("When calling ko.fromJS, pass the object you want to convert.");try{B++||(G=[],I=new S);var c,a;2==arguments.length&&(arguments[1][p]?a=arguments[1]:c=arguments[1]);3==arguments.length&&(c=arguments[1],a=arguments[2]);a&&(c=E(c,a[p]));c=z(c);var d=F(a,b,c);a&&(d=a);if(!--B)for(;G.length;){var e=G.pop();e&&(e(),e.__DO.throttleEvaluation=e.throttleEvaluation)}d[p]=E(d[p],c);return d}catch(f){throw B=0,f;}};f.fromJSON=function(b){var c=e.utils.parseJson(b);
arguments[0]=c;return f.fromJS.apply(this,arguments)};f.updateFromJS=function(){throw Error("ko.mapping.updateFromJS, use ko.mapping.fromJS instead. Please note that the order of parameters is different!");};f.updateFromJSON=function(){throw Error("ko.mapping.updateFromJSON, use ko.mapping.fromJSON instead. Please note that the order of parameters is different!");};f.toJS=function(b,c){j||f.resetDefaultOptions();if(0==arguments.length)throw Error("When calling ko.mapping.toJS, pass the object you want to convert.");
if("array"!==f.getType(j.ignore))throw Error("ko.mapping.defaultOptions().ignore should be an array.");if("array"!==f.getType(j.include))throw Error("ko.mapping.defaultOptions().include should be an array.");if("array"!==f.getType(j.copy))throw Error("ko.mapping.defaultOptions().copy should be an array.");c=z(c,b[p]);return f.visitModel(b,function(a){return e.utils.unwrapObservable(a)},c)};f.toJSON=function(b,c){var a=f.toJS(b,c);return e.utils.stringifyJson(a)};f.defaultOptions=function(){if(0<arguments.length)j=
arguments[0];else return j};f.resetDefaultOptions=function(){j={include:x.include.slice(0),ignore:x.ignore.slice(0),copy:x.copy.slice(0)}};f.getType=function(b){if(b&&"object"===typeof b){if(b.constructor===Date)return"date";if(b.constructor===Array)return"array"}return typeof b};f.visitModel=function(b,c,a){a=a||{};a.visitedObjects=a.visitedObjects||new S;var d,k=e.utils.unwrapObservable(b);if(P(k))a=z(a,k[p]),c(b,a.parentName),d="array"===f.getType(k)?[]:{};else return c(b,a.parentName);a.visitedObjects.save(b,
d);var l=a.parentName;Q(k,function(b){if(!(a.ignore&&-1!=e.utils.arrayIndexOf(a.ignore,b))){var j=k[b],g=a,h=l||"";"array"===f.getType(k)?l&&(h+="["+b+"]"):(l&&(h+="."),h+=b);g.parentName=h;if(!(-1===e.utils.arrayIndexOf(a.copy,b)&&-1===e.utils.arrayIndexOf(a.include,b)&&k[p]&&k[p].mappedProperties&&!k[p].mappedProperties[b]&&k[p].copiedProperties&&!k[p].copiedProperties[b]&&"array"!==f.getType(k)))switch(f.getType(e.utils.unwrapObservable(j))){case "object":case "array":case "undefined":g=a.visitedObjects.get(j);
d[b]="undefined"!==f.getType(g)?g:f.visitModel(j,c,a);break;default:d[b]=c(j,a.parentName)}}});return d}});

/*! jQuery v3.4.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],E=C.document,r=Object.getPrototypeOf,s=t.slice,g=t.concat,u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType},x=function(e){return null!=e&&e===e.window},c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement("script");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[o.call(e)]||"object":typeof e}var f="3.4.1",k=function(e,t){return new k.fn.init(e,t)},p=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;function d(e){var t=!!e&&"length"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}k.fn=k.prototype={jquery:f,constructor:k,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=k.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return k.each(this,e)},map:function(n){return this.pushStack(k.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},k.extend=k.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(k.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||k.isPlainObject(n)?n:{},i=!1,a[t]=k.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},k.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==o.call(e))&&(!(t=r(e))||"function"==typeof(n=v.call(t,"constructor")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t){b(e,{nonce:t&&t.nonce})},each:function(e,t){var n,r=0;if(d(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},trim:function(e){return null==e?"":(e+"").replace(p,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(d(Object(e))?k.merge(n,"string"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(d(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g.apply([],a)},guid:1,support:y}),"function"==typeof Symbol&&(k.fn[Symbol.iterator]=t[Symbol.iterator]),k.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var h=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,k="sizzle"+1*new Date,m=n.document,S=0,r=0,p=ue(),x=ue(),N=ue(),A=ue(),D=function(e,t){return e===t&&(l=!0),0},j={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",I="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",W="\\["+M+"*("+I+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+M+"*\\]",$=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+W+")*)|.*)\\)|)",F=new RegExp(M+"+","g"),B=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=new RegExp("^"+M+"*,"+M+"*"),z=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp(M+"|>"),X=new RegExp($),V=new RegExp("^"+I+"$"),G={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+W),PSEUDO:new RegExp("^"+$),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\d$/i,K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\([\\da-f]{1,6}"+M+"?|("+M+")|.)","ig"),ne=function(e,t,n){var r="0x"+t-65536;return r!=r||n?t:r<0?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{H.apply(t=O.call(m.childNodes),m.childNodes),t[m.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&((e?e.ownerDocument||e:m)!==C&&T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!A[t+" "]&&(!v||!v.test(t))&&(1!==p||"object"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&U.test(t)){(s=e.getAttribute("id"))?s=s.replace(re,ie):e.setAttribute("id",s=k),o=(l=h(t)).length;while(o--)l[o]="#"+s+" "+xe(l[o]);c=l.join(","),f=ee.test(t)&&ye(e.parentNode)||e}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){A(t,!0)}finally{s===k&&e.removeAttribute("id")}}}return g(t.replace(B,"$1"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function le(e){return e[k]=!0,e}function ce(e){var t=C.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split("|"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return("input"===t||"button"===t)&&e.type===n}}function ge(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e.namespaceURI,n=(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||"HTML")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:m;return r!==C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),m!==C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",oe,!1):n.attachEvent&&n.attachEvent("onunload",oe)),d.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment("")),!e.getElementsByTagName("*").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=k,!C.getElementsByName||!C.getElementsByName(k).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){a.appendChild(e).innerHTML="<a id='"+k+"'></a><select id='"+k+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&v.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||v.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll("[id~="+k+"-]").length||v.push("~="),e.querySelectorAll(":checked").length||v.push(":checked"),e.querySelectorAll("a#"+k+"+*").length||v.push(".#.+[+~]")}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=C.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&v.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&v.push(":enabled",":disabled"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&v.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),v.push(",.*:")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,"*"),c.call(e,"[s!='']:x"),s.push("!=",$)}),v=v.length&&new RegExp(v.join("|")),s=s.length&&new RegExp(s.join("|")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e===C||e.ownerDocument===m&&y(m,e)?-1:t===C||t.ownerDocument===m&&y(m,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e===C?-1:t===C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]===m?-1:s[r]===m?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if((e.ownerDocument||e)!==C&&T(e),d.matchesSelector&&E&&!A[t+" "]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){A(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!==C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!==C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&j.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+"").replace(re,ie)},se.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(D),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=p[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&p(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(F," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(h,e,t,g,v){var y="nth"!==h.slice(0,3),m="last"!==h.slice(-4),x="of-type"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?"nextSibling":"previousSibling",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l="only"===h&&!u&&"nextSibling"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===S&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[S,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===S&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[S,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error("unsupported pseudo: "+e);return a[k]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace(B,"$1"));return s[k]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||"")||se.error("unsupported lang: "+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&"parentNode"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[S,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[k]||(e[k]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===S&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[k]&&(v=Ce(v)),y&&!y[k]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[k]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace(B,"$1"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace(B," ")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=N[e+" "];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[k]?i.push(a):o.push(a);(a=N(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=S+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t===C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument===C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(S=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(S=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=k.split("").sort(D).join("")===k,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);k.find=h,k.expr=h.selectors,k.expr[":"]=k.expr.pseudos,k.uniqueSort=k.unique=h.uniqueSort,k.text=h.getText,k.isXMLDoc=h.isXML,k.contains=h.contains,k.escapeSelector=h.escape;var T=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&k(e).is(n))break;r.push(e)}return r},S=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},N=k.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var D=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function j(e,n,r){return m(n)?k.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?k.grep(e,function(e){return e===n!==r}):"string"!=typeof n?k.grep(e,function(e){return-1<i.call(n,e)!==r}):k.filter(n,e,r)}k.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?k.find.matchesSelector(r,e)?[r]:[]:k.find.matches(e,k.grep(t,function(e){return 1===e.nodeType}))},k.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(k(e).filter(function(){for(t=0;t<r;t++)if(k.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)k.find(e,i[t],n);return 1<r?k.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,"string"==typeof e&&N.test(e)?k(e):e||[],!1).length}});var q,L=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(k.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||q,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:L.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof k?t[0]:t,k.merge(this,k.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),D.test(r[1])&&k.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(k):k.makeArray(e,this)}).prototype=k.fn,q=k(E);var H=/^(?:parents|prev(?:Until|All))/,O={children:!0,contents:!0,next:!0,prev:!0};function P(e,t){while((e=e[t])&&1!==e.nodeType);return e}k.fn.extend({has:function(e){var t=k(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(k.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&k(e);if(!N.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&k.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?k.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?i.call(k(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(k.uniqueSort(k.merge(this.get(),k(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),k.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return T(e,"parentNode")},parentsUntil:function(e,t,n){return T(e,"parentNode",n)},next:function(e){return P(e,"nextSibling")},prev:function(e){return P(e,"previousSibling")},nextAll:function(e){return T(e,"nextSibling")},prevAll:function(e){return T(e,"previousSibling")},nextUntil:function(e,t,n){return T(e,"nextSibling",n)},prevUntil:function(e,t,n){return T(e,"previousSibling",n)},siblings:function(e){return S((e.parentNode||{}).firstChild,e)},children:function(e){return S(e.firstChild)},contents:function(e){return"undefined"!=typeof e.contentDocument?e.contentDocument:(A(e,"template")&&(e=e.content||e),k.merge([],e.childNodes))}},function(r,i){k.fn[r]=function(e,t){var n=k.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=k.filter(t,n)),1<this.length&&(O[r]||k.uniqueSort(n),H.test(r)&&n.reverse()),this.pushStack(n)}});var R=/[^\x20\t\r\n\f]+/g;function M(e){return e}function I(e){throw e}function W(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}k.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},k.each(e.match(R)||[],function(e,t){n[t]=!0}),n):k.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){k.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return k.each(arguments,function(e,t){var n;while(-1<(n=k.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<k.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},k.extend({Deferred:function(e){var o=[["notify","progress",k.Callbacks("memory"),k.Callbacks("memory"),2],["resolve","done",k.Callbacks("once memory"),k.Callbacks("once memory"),0,"resolved"],["reject","fail",k.Callbacks("once memory"),k.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return k.Deferred(function(r){k.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,M,s),l(u,o,I,s)):(u++,t.call(e,l(u,o,M,s),l(u,o,I,s),l(u,o,M,o.notifyWith))):(a!==M&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){k.Deferred.exceptionHook&&k.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==I&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(k.Deferred.getStackHook&&(t.stackTrace=k.Deferred.getStackHook()),C.setTimeout(t))}}return k.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:M,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:M)),o[2][3].add(l(0,e,m(n)?n:I))}).promise()},promise:function(e){return null!=e?k.extend(e,a):a}},s={};return k.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=k.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(W(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)W(i[t],a(t),o.reject);return o.promise()}});var $=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;k.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&$.test(e.name)&&C.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},k.readyException=function(e){C.setTimeout(function(){throw e})};var F=k.Deferred();function B(){E.removeEventListener("DOMContentLoaded",B),C.removeEventListener("load",B),k.ready()}k.fn.ready=function(e){return F.then(e)["catch"](function(e){k.readyException(e)}),this},k.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--k.readyWait:k.isReady)||(k.isReady=!0)!==e&&0<--k.readyWait||F.resolveWith(E,[k])}}),k.ready.then=F.then,"complete"===E.readyState||"loading"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(k.ready):(E.addEventListener("DOMContentLoaded",B),C.addEventListener("load",B));var _=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===w(n))for(s in i=!0,n)_(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(k(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},z=/^-ms-/,U=/-([a-z])/g;function X(e,t){return t.toUpperCase()}function V(e){return e.replace(z,"ms-").replace(U,X)}var G=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function Y(){this.expando=k.expando+Y.uid++}Y.uid=1,Y.prototype={cache:function(e){var t=e[this.expando];return t||(t={},G(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[V(t)]=n;else for(r in t)i[V(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][V(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(V):(t=V(t))in r?[t]:t.match(R)||[]).length;while(n--)delete r[t[n]]}(void 0===t||k.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!k.isEmptyObject(t)}};var Q=new Y,J=new Y,K=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Z=/[A-Z]/g;function ee(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(Z,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:K.test(i)?JSON.parse(i):i)}catch(e){}J.set(e,t,n)}else n=void 0;return n}k.extend({hasData:function(e){return J.hasData(e)||Q.hasData(e)},data:function(e,t,n){return J.access(e,t,n)},removeData:function(e,t){J.remove(e,t)},_data:function(e,t,n){return Q.access(e,t,n)},_removeData:function(e,t){Q.remove(e,t)}}),k.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=J.get(o),1===o.nodeType&&!Q.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=V(r.slice(5)),ee(o,r,i[r]));Q.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){J.set(this,n)}):_(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=J.get(o,n))?t:void 0!==(t=ee(o,n))?t:void 0;this.each(function(){J.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){J.remove(this,e)})}}),k.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Q.get(e,t),n&&(!r||Array.isArray(n)?r=Q.access(e,t,k.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=k.queue(e,t),r=n.length,i=n.shift(),o=k._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){k.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Q.get(e,n)||Q.access(e,n,{empty:k.Callbacks("once memory").add(function(){Q.remove(e,[t+"queue",n])})})}}),k.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?k.queue(this[0],t):void 0===n?this:this.each(function(){var e=k.queue(this,t,n);k._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&k.dequeue(this,t)})},dequeue:function(e){return this.each(function(){k.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=k.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=Q.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var te=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,ne=new RegExp("^(?:([+-])=|)("+te+")([a-z%]*)$","i"),re=["Top","Right","Bottom","Left"],ie=E.documentElement,oe=function(e){return k.contains(e.ownerDocument,e)},ae={composed:!0};ie.getRootNode&&(oe=function(e){return k.contains(e.ownerDocument,e)||e.getRootNode(ae)===e.ownerDocument});var se=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&oe(e)&&"none"===k.css(e,"display")},ue=function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];for(o in i=n.apply(e,r||[]),t)e.style[o]=a[o];return i};function le(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return k.css(e,t,"")},u=s(),l=n&&n[3]||(k.cssNumber[t]?"":"px"),c=e.nodeType&&(k.cssNumber[t]||"px"!==l&&+u)&&ne.exec(k.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)k.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,k.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ce={};function fe(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=Q.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&se(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ce[s])||(o=a.body.appendChild(a.createElement(s)),u=k.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ce[s]=u)))):"none"!==n&&(l[c]="none",Q.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}k.fn.extend({show:function(){return fe(this,!0)},hide:function(){return fe(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){se(this)?k(this).show():k(this).hide()})}});var pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,he=/^$|^module$|\/(?:java|ecma)script/i,ge={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ve(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&A(e,t)?k.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Q.set(e[n],"globalEval",!t||Q.get(t[n],"globalEval"))}ge.optgroup=ge.option,ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td;var me,xe,be=/<|&#?\w+;/;function we(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===w(o))k.merge(p,o.nodeType?[o]:o);else if(be.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+k.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;k.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<k.inArray(o,r))i&&i.push(o);else if(l=oe(o),a=ve(f.appendChild(o),"script"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}me=E.createDocumentFragment().appendChild(E.createElement("div")),(xe=E.createElement("input")).setAttribute("type","radio"),xe.setAttribute("checked","checked"),xe.setAttribute("name","t"),me.appendChild(xe),y.checkClone=me.cloneNode(!0).cloneNode(!0).lastChild.checked,me.innerHTML="<textarea>x</textarea>",y.noCloneChecked=!!me.cloneNode(!0).lastChild.defaultValue;var Te=/^key/,Ce=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Ee=/^([^.]*)(?:\.(.+)|)/;function ke(){return!0}function Se(){return!1}function Ne(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==("focus"===t)}function Ae(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)Ae(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Se;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return k().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=k.guid++)),e.each(function(){k.event.add(this,t,i,r,n)})}function De(e,i,o){o?(Q.set(e,i,!1),k.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Q.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(k.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Q.set(this,i,r),t=o(this,i),this[i](),r!==(n=Q.get(this,i))||t?Q.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n.value}else r.length&&(Q.set(this,i,{value:k.event.trigger(k.extend(r[0],k.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Q.get(e,i)&&k.event.add(e,i,ke)}k.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Q.get(t);if(v){n.handler&&(n=(o=n).handler,i=o.selector),i&&k.find.matchesSelector(ie,i),n.guid||(n.guid=k.guid++),(u=v.events)||(u=v.events={}),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof k&&k.event.triggered!==e.type?k.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(R)||[""]).length;while(l--)d=g=(s=Ee.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=k.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=k.event.special[d]||{},c=k.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&k.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),k.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Q.hasData(e)&&Q.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(R)||[""]).length;while(l--)if(d=g=(s=Ee.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=k.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||k.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)k.event.remove(e,d+t[l],n,r,!0);k.isEmptyObject(u)&&Q.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=k.event.fix(e),u=new Array(arguments.length),l=(Q.get(this,"events")||{})[s.type]||[],c=k.event.special[s.type]||{};for(u[0]=s,t=1;t<arguments.length;t++)u[t]=arguments[t];if(s.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,s)){a=k.event.handlers.call(this,s,l),t=0;while((i=a[t++])&&!s.isPropagationStopped()){s.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!s.isImmediatePropagationStopped())s.rnamespace&&!1!==o.namespace&&!s.rnamespace.test(o.namespace)||(s.handleObj=o,s.data=o.data,void 0!==(r=((k.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,u))&&!1===(s.result=r)&&(s.preventDefault(),s.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,s),s.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<k(i,this).index(l):k.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(k.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[k.expando]?e:new k.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&De(t,"click",ke),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&De(t,"click"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,"input")&&Q.get(t,"click")||A(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},k.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},k.Event=function(e,t){if(!(this instanceof k.Event))return new k.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?ke:Se,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&k.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[k.expando]=!0},k.Event.prototype={constructor:k.Event,isDefaultPrevented:Se,isPropagationStopped:Se,isImmediatePropagationStopped:Se,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=ke,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=ke,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=ke,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},k.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&Te.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&Ce.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},k.event.addProp),k.each({focus:"focusin",blur:"focusout"},function(e,t){k.event.special[e]={setup:function(){return De(this,e,Ne),!1},trigger:function(){return De(this,e),!0},delegateType:t}}),k.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){k.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||k.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),k.fn.extend({on:function(e,t,n,r){return Ae(this,e,t,n,r)},one:function(e,t,n,r){return Ae(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,k(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Se),this.each(function(){k.event.remove(this,e,n,t)})}});var je=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,qe=/<script|<style|<link/i,Le=/checked\s*(?:[^=]|=\s*.checked.)/i,He=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Oe(e,t){return A(e,"table")&&A(11!==t.nodeType?t:t.firstChild,"tr")&&k(e).children("tbody")[0]||e}function Pe(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function Re(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Me(e,t){var n,r,i,o,a,s,u,l;if(1===t.nodeType){if(Q.hasData(e)&&(o=Q.access(e),a=Q.set(t,o),l=o.events))for(i in delete a.handle,a.events={},l)for(n=0,r=l[i].length;n<r;n++)k.event.add(t,i,l[i][n]);J.hasData(e)&&(s=J.access(e),u=k.extend({},s),J.set(t,u))}}function Ie(n,r,i,o){r=g.apply([],r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&"string"==typeof d&&!y.checkClone&&Le.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),Ie(t,r,i,o)});if(f&&(t=(e=we(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=k.map(ve(e,"script"),Pe)).length;c<f;c++)u=e,c!==p&&(u=k.clone(u,!0,!0),s&&k.merge(a,ve(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,k.map(a,Re),c=0;c<s;c++)u=a[c],he.test(u.type||"")&&!Q.access(u,"globalEval")&&k.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?k._evalUrl&&!u.noModule&&k._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")}):b(u.textContent.replace(He,""),u,l))}return n}function We(e,t,n){for(var r,i=t?k.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||k.cleanData(ve(r)),r.parentNode&&(n&&oe(r)&&ye(ve(r,"script")),r.parentNode.removeChild(r));return e}k.extend({htmlPrefilter:function(e){return e.replace(je,"<$1></$2>")},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=oe(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||k.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Me(o[r],a[r]);else Me(e,c);return 0<(a=ve(c,"script")).length&&ye(a,!f&&ve(e,"script")),c},cleanData:function(e){for(var t,n,r,i=k.event.special,o=0;void 0!==(n=e[o]);o++)if(G(n)){if(t=n[Q.expando]){if(t.events)for(r in t.events)i[r]?k.event.remove(n,r):k.removeEvent(n,r,t.handle);n[Q.expando]=void 0}n[J.expando]&&(n[J.expando]=void 0)}}}),k.fn.extend({detach:function(e){return We(this,e,!0)},remove:function(e){return We(this,e)},text:function(e){return _(this,function(e){return void 0===e?k.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Ie(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||Oe(this,e).appendChild(e)})},prepend:function(){return Ie(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Oe(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Ie(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Ie(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(k.cleanData(ve(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return k.clone(this,e,t)})},html:function(e){return _(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!qe.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=k.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(k.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return Ie(this,arguments,function(e){var t=this.parentNode;k.inArray(this,n)<0&&(k.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),k.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){k.fn[e]=function(e){for(var t,n=[],r=k(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),k(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var $e=new RegExp("^("+te+")(?!px)[a-z%]+$","i"),Fe=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},Be=new RegExp(re.join("|"),"i");function _e(e,t,n){var r,i,o,a,s=e.style;return(n=n||Fe(e))&&(""!==(a=n.getPropertyValue(t)||n[t])||oe(e)||(a=k.style(e,t)),!y.pixelBoxStyles()&&$e.test(a)&&Be.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function ze(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(u){s.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",u.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",ie.appendChild(s).appendChild(u);var e=C.getComputedStyle(u);n="1%"!==e.top,a=12===t(e.marginLeft),u.style.right="60%",o=36===t(e.right),r=36===t(e.width),u.style.position="absolute",i=12===t(u.offsetWidth/3),ie.removeChild(s),u=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s=E.createElement("div"),u=E.createElement("div");u.style&&(u.style.backgroundClip="content-box",u.cloneNode(!0).style.backgroundClip="",y.clearCloneStyle="content-box"===u.style.backgroundClip,k.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),a},scrollboxSize:function(){return e(),i}}))}();var Ue=["Webkit","Moz","ms"],Xe=E.createElement("div").style,Ve={};function Ge(e){var t=k.cssProps[e]||Ve[e];return t||(e in Xe?e:Ve[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=Ue.length;while(n--)if((e=Ue[n]+t)in Xe)return e}(e)||e)}var Ye=/^(none|table(?!-c[ea]).+)/,Qe=/^--/,Je={position:"absolute",visibility:"hidden",display:"block"},Ke={letterSpacing:"0",fontWeight:"400"};function Ze(e,t,n){var r=ne.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function et(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=k.css(e,n+re[a],!0,i)),r?("content"===n&&(u-=k.css(e,"padding"+re[a],!0,i)),"margin"!==n&&(u-=k.css(e,"border"+re[a]+"Width",!0,i))):(u+=k.css(e,"padding"+re[a],!0,i),"padding"!==n?u+=k.css(e,"border"+re[a]+"Width",!0,i):s+=k.css(e,"border"+re[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function tt(e,t,n){var r=Fe(e),i=(!y.boxSizingReliable()||n)&&"border-box"===k.css(e,"boxSizing",!1,r),o=i,a=_e(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if($e.test(a)){if(!n)return a;a="auto"}return(!y.boxSizingReliable()&&i||"auto"===a||!parseFloat(a)&&"inline"===k.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===k.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+et(e,t,n||(i?"border":"content"),o,r,a)+"px"}function nt(e,t,n,r,i){return new nt.prototype.init(e,t,n,r,i)}k.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=_e(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=V(t),u=Qe.test(t),l=e.style;if(u||(t=Ge(s)),a=k.cssHooks[t]||k.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=ne.exec(n))&&i[1]&&(n=le(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(k.cssNumber[s]?"":"px")),y.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=V(t);return Qe.test(t)||(t=Ge(s)),(a=k.cssHooks[t]||k.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=_e(e,t,r)),"normal"===i&&t in Ke&&(i=Ke[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),k.each(["height","width"],function(e,u){k.cssHooks[u]={get:function(e,t,n){if(t)return!Ye.test(k.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?tt(e,u,n):ue(e,Je,function(){return tt(e,u,n)})},set:function(e,t,n){var r,i=Fe(e),o=!y.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===k.css(e,"boxSizing",!1,i),s=n?et(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-et(e,u,"border",!1,i)-.5)),s&&(r=ne.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=k.css(e,u)),Ze(0,t,s)}}}),k.cssHooks.marginLeft=ze(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(_e(e,"marginLeft"))||e.getBoundingClientRect().left-ue(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),k.each({margin:"",padding:"",border:"Width"},function(i,o){k.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+re[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(k.cssHooks[i+o].set=Ze)}),k.fn.extend({css:function(e,t){return _(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Fe(e),i=t.length;a<i;a++)o[t[a]]=k.css(e,t[a],!1,r);return o}return void 0!==n?k.style(e,t,n):k.css(e,t)},e,t,1<arguments.length)}}),((k.Tween=nt).prototype={constructor:nt,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||k.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(k.cssNumber[n]?"":"px")},cur:function(){var e=nt.propHooks[this.prop];return e&&e.get?e.get(this):nt.propHooks._default.get(this)},run:function(e){var t,n=nt.propHooks[this.prop];return this.options.duration?this.pos=t=k.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):nt.propHooks._default.set(this),this}}).init.prototype=nt.prototype,(nt.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=k.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){k.fx.step[e.prop]?k.fx.step[e.prop](e):1!==e.elem.nodeType||!k.cssHooks[e.prop]&&null==e.elem.style[Ge(e.prop)]?e.elem[e.prop]=e.now:k.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=nt.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},k.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},k.fx=nt.prototype.init,k.fx.step={};var rt,it,ot,at,st=/^(?:toggle|show|hide)$/,ut=/queueHooks$/;function lt(){it&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(lt):C.setTimeout(lt,k.fx.interval),k.fx.tick())}function ct(){return C.setTimeout(function(){rt=void 0}),rt=Date.now()}function ft(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=re[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function pt(e,t,n){for(var r,i=(dt.tweeners[t]||[]).concat(dt.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function dt(o,e,t){var n,a,r=0,i=dt.prefilters.length,s=k.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=rt||ct(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:k.extend({},e),opts:k.extend(!0,{specialEasing:{},easing:k.easing._default},t),originalProperties:e,originalOptions:t,startTime:rt||ct(),duration:t.duration,tweens:[],createTween:function(e,t){var n=k.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=V(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=k.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=dt.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(k._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return k.map(c,pt,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),k.fx.timer(k.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}k.Animation=k.extend(dt,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return le(n.elem,e,ne.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=["*"]):e=e.match(R);for(var n,r=0,i=e.length;r<i;r++)n=e[r],dt.tweeners[n]=dt.tweeners[n]||[],dt.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&se(e),v=Q.get(e,"fxshow");for(r in n.queue||(null==(a=k._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,k.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],st.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||k.style(e,r)}if((u=!k.isEmptyObject(t))||!k.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Q.get(e,"display")),"none"===(c=k.css(e,"display"))&&(l?c=l:(fe([e],!0),l=e.style.display||l,c=k.css(e,"display"),fe([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===k.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=Q.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&fe([e],!0),p.done(function(){for(r in g||fe([e]),Q.remove(e,"fxshow"),d)k.style(e,r,d[r])})),u=pt(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?dt.prefilters.unshift(e):dt.prefilters.push(e)}}),k.speed=function(e,t,n){var r=e&&"object"==typeof e?k.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return k.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in k.fx.speeds?r.duration=k.fx.speeds[r.duration]:r.duration=k.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&k.dequeue(this,r.queue)},r},k.fn.extend({fadeTo:function(e,t,n,r){return this.filter(se).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=k.isEmptyObject(t),o=k.speed(e,n,r),a=function(){var e=dt(this,k.extend({},t),o);(i||Q.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&!1!==i&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=k.timers,r=Q.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&ut.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||k.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=Q.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=k.timers,o=n?n.length:0;for(t.finish=!0,k.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),k.each(["toggle","show","hide"],function(e,r){var i=k.fn[r];k.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(ft(r,!0),e,t,n)}}),k.each({slideDown:ft("show"),slideUp:ft("hide"),slideToggle:ft("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){k.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),k.timers=[],k.fx.tick=function(){var e,t=0,n=k.timers;for(rt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||k.fx.stop(),rt=void 0},k.fx.timer=function(e){k.timers.push(e),k.fx.start()},k.fx.interval=13,k.fx.start=function(){it||(it=!0,lt())},k.fx.stop=function(){it=null},k.fx.speeds={slow:600,fast:200,_default:400},k.fn.delay=function(r,e){return r=k.fx&&k.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},ot=E.createElement("input"),at=E.createElement("select").appendChild(E.createElement("option")),ot.type="checkbox",y.checkOn=""!==ot.value,y.optSelected=at.selected,(ot=E.createElement("input")).value="t",ot.type="radio",y.radioValue="t"===ot.value;var ht,gt=k.expr.attrHandle;k.fn.extend({attr:function(e,t){return _(this,k.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){k.removeAttr(this,e)})}}),k.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?k.prop(e,t,n):(1===o&&k.isXMLDoc(e)||(i=k.attrHooks[t.toLowerCase()]||(k.expr.match.bool.test(t)?ht:void 0)),void 0!==n?null===n?void k.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=k.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&"radio"===t&&A(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(R);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),ht={set:function(e,t,n){return!1===t?k.removeAttr(e,n):e.setAttribute(n,n),n}},k.each(k.expr.match.bool.source.match(/\w+/g),function(e,t){var a=gt[t]||k.find.attr;gt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=gt[o],gt[o]=r,r=null!=a(e,t,n)?o:null,gt[o]=i),r}});var vt=/^(?:input|select|textarea|button)$/i,yt=/^(?:a|area)$/i;function mt(e){return(e.match(R)||[]).join(" ")}function xt(e){return e.getAttribute&&e.getAttribute("class")||""}function bt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(R)||[]}k.fn.extend({prop:function(e,t){return _(this,k.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[k.propFix[e]||e]})}}),k.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&k.isXMLDoc(e)||(t=k.propFix[t]||t,i=k.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=k.find.attr(e,"tabindex");return t?parseInt(t,10):vt.test(e.nodeName)||yt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),y.optSelected||(k.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),k.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){k.propFix[this.toLowerCase()]=this}),k.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){k(this).addClass(t.call(this,e,xt(this)))});if((e=bt(t)).length)while(n=this[u++])if(i=xt(n),r=1===n.nodeType&&" "+mt(i)+" "){a=0;while(o=e[a++])r.indexOf(" "+o+" ")<0&&(r+=o+" ");i!==(s=mt(r))&&n.setAttribute("class",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){k(this).removeClass(t.call(this,e,xt(this)))});if(!arguments.length)return this.attr("class","");if((e=bt(t)).length)while(n=this[u++])if(i=xt(n),r=1===n.nodeType&&" "+mt(i)+" "){a=0;while(o=e[a++])while(-1<r.indexOf(" "+o+" "))r=r.replace(" "+o+" "," ");i!==(s=mt(r))&&n.setAttribute("class",s)}return this},toggleClass:function(i,t){var o=typeof i,a="string"===o||Array.isArray(i);return"boolean"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){k(this).toggleClass(i.call(this,e,xt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=k(this),r=bt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&"boolean"!==o||((e=xt(this))&&Q.set(this,"__className__",e),this.setAttribute&&this.setAttribute("class",e||!1===i?"":Q.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+mt(xt(n))+" ").indexOf(t))return!0;return!1}});var wt=/\r/g;k.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,k(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=k.map(t,function(e){return null==e?"":e+""})),(r=k.valHooks[this.type]||k.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=k.valHooks[t.type]||k.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(wt,""):null==e?"":e:void 0}}),k.extend({valHooks:{option:{get:function(e){var t=k.find.attr(e,"value");return null!=t?t:mt(k.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,"optgroup"))){if(t=k(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=k.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<k.inArray(k.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),k.each(["radio","checkbox"],function(){k.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<k.inArray(k(e).val(),t)}},y.checkOn||(k.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),y.focusin="onfocusin"in C;var Tt=/^(?:focusinfocus|focusoutblur)$/,Ct=function(e){e.stopPropagation()};k.extend(k.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,"type")?e.type:e,h=v.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!Tt.test(d+k.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[k.expando]?e:new k.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:k.makeArray(t,[e]),c=k.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,Tt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Q.get(o,"events")||{})[e.type]&&Q.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&G(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!G(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),k.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,Ct),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,Ct),k.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=k.extend(new k.Event,n,{type:e,isSimulated:!0});k.event.trigger(r,null,t)}}),k.fn.extend({trigger:function(e,t){return this.each(function(){k.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return k.event.trigger(e,t,n,!0)}}),y.focusin||k.each({focus:"focusin",blur:"focusout"},function(n,r){var i=function(e){k.event.simulate(r,e.target,k.event.fix(e))};k.event.special[r]={setup:function(){var e=this.ownerDocument||this,t=Q.access(e,r);t||e.addEventListener(n,i,!0),Q.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this,t=Q.access(e,r)-1;t?Q.access(e,r,t):(e.removeEventListener(n,i,!0),Q.remove(e,r))}}});var Et=C.location,kt=Date.now(),St=/\?/;k.parseXML=function(e){var t;if(!e||"string"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,"text/xml")}catch(e){t=void 0}return t&&!t.getElementsByTagName("parsererror").length||k.error("Invalid XML: "+e),t};var Nt=/\[\]$/,At=/\r?\n/g,Dt=/^(?:submit|button|image|reset|file)$/i,jt=/^(?:input|select|textarea|keygen)/i;function qt(n,e,r,i){var t;if(Array.isArray(e))k.each(e,function(e,t){r||Nt.test(n)?i(n,t):qt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==w(e))i(n,e);else for(t in e)qt(n+"["+t+"]",e[t],r,i)}k.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!k.isPlainObject(e))k.each(e,function(){i(this.name,this.value)});else for(n in e)qt(n,e[n],t,i);return r.join("&")},k.fn.extend({serialize:function(){return k.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=k.prop(this,"elements");return e?k.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!k(this).is(":disabled")&&jt.test(this.nodeName)&&!Dt.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=k(this).val();return null==n?null:Array.isArray(n)?k.map(n,function(e){return{name:t.name,value:e.replace(At,"\r\n")}}):{name:t.name,value:n.replace(At,"\r\n")}}).get()}});var Lt=/%20/g,Ht=/#.*$/,Ot=/([?&])_=[^&]*/,Pt=/^(.*?):[ \t]*([^\r\n]*)$/gm,Rt=/^(?:GET|HEAD)$/,Mt=/^\/\//,It={},Wt={},$t="*/".concat("*"),Ft=E.createElement("a");function Bt(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(R)||[];if(m(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function _t(t,i,o,a){var s={},u=t===Wt;function l(e){var r;return s[e]=!0,k.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function zt(e,t){var n,r,i=k.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&k.extend(!0,e,r),e}Ft.href=Et.href,k.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Et.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Et.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":$t,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":k.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?zt(zt(e,k.ajaxSettings),t):zt(k.ajaxSettings,e)},ajaxPrefilter:Bt(It),ajaxTransport:Bt(Wt),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=k.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?k(y):k.event,x=k.Deferred(),b=k.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Pt.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Et.href)+"").replace(Mt,Et.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(R)||[""],null==v.crossDomain){r=E.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Ft.protocol+"//"+Ft.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=k.param(v.data,v.traditional)),_t(It,v,t,T),h)return T;for(i in(g=k.event&&v.global)&&0==k.active++&&k.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Rt.test(v.type),f=v.url.replace(Ht,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(Lt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(St.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Ot,"$1"),o=(St.test(f)?"&":"?")+"_="+kt+++o),v.url=f+o),v.ifModified&&(k.lastModified[f]&&T.setRequestHeader("If-Modified-Since",k.lastModified[f]),k.etag[f]&&T.setRequestHeader("If-None-Match",k.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+$t+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=_t(Wt,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(k.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(k.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--k.active||k.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return k.get(e,t,n,"json")},getScript:function(e,t){return k.get(e,void 0,t,"script")}}),k.each(["get","post"],function(e,i){k[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),k.ajax(k.extend({url:e,type:i,dataType:r,data:t,success:n},k.isPlainObject(e)&&e))}}),k._evalUrl=function(e,t){return k.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){k.globalEval(e,t)}})},k.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=k(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){k(this).wrapInner(n.call(this,e))}):this.each(function(){var e=k(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){k(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){k(this).replaceWith(this.childNodes)}),this}}),k.expr.pseudos.hidden=function(e){return!k.expr.pseudos.visible(e)},k.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},k.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var Ut={0:200,1223:204},Xt=k.ajaxSettings.xhr();y.cors=!!Xt&&"withCredentials"in Xt,y.ajax=Xt=!!Xt,k.ajaxTransport(function(i){var o,a;if(y.cors||Xt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(Ut[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),k.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),k.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return k.globalEval(e),e}}}),k.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),k.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=k("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Vt,Gt=[],Yt=/(=)\?(?=&|$)|\?\?/;k.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Gt.pop()||k.expando+"_"+kt++;return this[e]=!0,e}}),k.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Yt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Yt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Yt,"$1"+r):!1!==e.jsonp&&(e.url+=(St.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||k.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?k(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Gt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),"script"}),y.createHTMLDocument=((Vt=E.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Vt.childNodes.length),k.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument("")).createElement("base")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=D.exec(e))?[t.createElement(i[1])]:(i=we([e],t,o),o&&o.length&&k(o).remove(),k.merge([],i.childNodes)));var r,i,o},k.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=mt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&k.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?k("<div>").append(k.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},k.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){k.fn[t]=function(e){return this.on(t,e)}}),k.expr.pseudos.animated=function(t){return k.grep(k.timers,function(e){return t===e.elem}).length},k.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=k.css(e,"position"),c=k(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=k.css(e,"top"),u=k.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,k.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):c.css(f)}},k.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){k.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===k.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===k.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=k(e).offset()).top+=k.css(e,"borderTopWidth",!0),i.left+=k.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-k.css(r,"marginTop",!0),left:t.left-i.left-k.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===k.css(e,"position"))e=e.offsetParent;return e||ie})}}),k.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;k.fn[t]=function(e){return _(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),k.each(["top","left"],function(e,n){k.cssHooks[n]=ze(y.pixelPosition,function(e,t){if(t)return t=_e(e,n),$e.test(t)?k(e).position()[n]+"px":t})}),k.each({Height:"height",Width:"width"},function(a,s){k.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){k.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return _(this,function(e,t,n){var r;return x(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?k.css(e,t,i):k.style(e,t,n,i)},s,n?e:void 0,n)}})}),k.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){k.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}}),k.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),k.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}}),k.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||k.guid++,i},k.holdReady=function(e){e?k.readyWait++:k.ready(!0)},k.isArray=Array.isArray,k.parseJSON=JSON.parse,k.nodeName=A,k.isFunction=m,k.isWindow=x,k.camelCase=V,k.type=w,k.now=Date.now,k.isNumeric=function(e){var t=k.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},"function"==typeof define&&define.amd&&define("jquery",[],function(){return k});var Qt=C.jQuery,Jt=C.$;return k.noConflict=function(e){return C.$===k&&(C.$=Jt),e&&C.jQuery===k&&(C.jQuery=Qt),k},e||(C.jQuery=C.$=k),k});

/*!
 * Socket.IO v2.1.1
 * (c) 2014-2018 Guillermo Rauch
 * Released under the MIT License.
 */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define('socketio',[],e):"object"==typeof exports?exports.io=e():t.io=e()}(this,function(){return function(t){function e(n){if(r[n])return r[n].exports;var o=r[n]={exports:{},id:n,loaded:!1};return t[n].call(o.exports,o,o.exports,e),o.loaded=!0,o.exports}var r={};return e.m=t,e.c=r,e.p="",e(0)}([function(t,e,r){"use strict";function n(t,e){"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{};var r,n=i(t),s=n.source,h=n.id,p=n.path,u=c[h]&&p in c[h].nsps,f=e.forceNew||e["force new connection"]||!1===e.multiplex||u;return f?r=a(s,e):(c[h]||(c[h]=a(s,e)),r=c[h]),n.query&&!e.query&&(e.query=n.query),r.socket(n.path,e)}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=r(1),s=r(4),a=r(9);r(3)("socket.io-client");t.exports=e=n;var c=e.managers={};e.protocol=s.protocol,e.connect=n,e.Manager=r(9),e.Socket=r(34)},function(t,e,r){(function(e){"use strict";function n(t,r){var n=t;r=r||e.location,null==t&&(t=r.protocol+"//"+r.host),"string"==typeof t&&("/"===t.charAt(0)&&(t="/"===t.charAt(1)?r.protocol+t:r.host+t),/^(https?|wss?):\/\//.test(t)||(t="undefined"!=typeof r?r.protocol+"//"+t:"https://"+t),n=o(t)),n.port||(/^(http|ws)$/.test(n.protocol)?n.port="80":/^(http|ws)s$/.test(n.protocol)&&(n.port="443")),n.path=n.path||"/";var i=n.host.indexOf(":")!==-1,s=i?"["+n.host+"]":n.host;return n.id=n.protocol+"://"+s+":"+n.port,n.href=n.protocol+"://"+s+(r&&r.port===n.port?"":":"+n.port),n}var o=r(2);r(3)("socket.io-client:url");t.exports=n}).call(e,function(){return this}())},function(t,e){var r=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,n=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];t.exports=function(t){var e=t,o=t.indexOf("["),i=t.indexOf("]");o!=-1&&i!=-1&&(t=t.substring(0,o)+t.substring(o,i).replace(/:/g,";")+t.substring(i,t.length));for(var s=r.exec(t||""),a={},c=14;c--;)a[n[c]]=s[c]||"";return o!=-1&&i!=-1&&(a.source=e,a.host=a.host.substring(1,a.host.length-1).replace(/;/g,":"),a.authority=a.authority.replace("[","").replace("]","").replace(/;/g,":"),a.ipv6uri=!0),a}},function(t,e){"use strict";t.exports=function(){return function(){}}},function(t,e,r){function n(){}function o(t){var r=""+t.type;if(e.BINARY_EVENT!==t.type&&e.BINARY_ACK!==t.type||(r+=t.attachments+"-"),t.nsp&&"/"!==t.nsp&&(r+=t.nsp+","),null!=t.id&&(r+=t.id),null!=t.data){var n=i(t.data);if(n===!1)return m;r+=n}return r}function i(t){try{return JSON.stringify(t)}catch(t){return!1}}function s(t,e){function r(t){var r=l.deconstructPacket(t),n=o(r.packet),i=r.buffers;i.unshift(n),e(i)}l.removeBlobs(t,r)}function a(){this.reconstructor=null}function c(t){var r=0,n={type:Number(t.charAt(0))};if(null==e.types[n.type])return u("unknown packet type "+n.type);if(e.BINARY_EVENT===n.type||e.BINARY_ACK===n.type){for(var o="";"-"!==t.charAt(++r)&&(o+=t.charAt(r),r!=t.length););if(o!=Number(o)||"-"!==t.charAt(r))throw new Error("Illegal attachments");n.attachments=Number(o)}if("/"===t.charAt(r+1))for(n.nsp="";++r;){var i=t.charAt(r);if(","===i)break;if(n.nsp+=i,r===t.length)break}else n.nsp="/";var s=t.charAt(r+1);if(""!==s&&Number(s)==s){for(n.id="";++r;){var i=t.charAt(r);if(null==i||Number(i)!=i){--r;break}if(n.id+=t.charAt(r),r===t.length)break}n.id=Number(n.id)}if(t.charAt(++r)){var a=h(t.substr(r)),c=a!==!1&&(n.type===e.ERROR||d(a));if(!c)return u("invalid payload");n.data=a}return n}function h(t){try{return JSON.parse(t)}catch(t){return!1}}function p(t){this.reconPack=t,this.buffers=[]}function u(t){return{type:e.ERROR,data:"parser error: "+t}}var f=(r(3)("socket.io-parser"),r(5)),l=r(6),d=r(7),y=r(8);e.protocol=4,e.types=["CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK"],e.CONNECT=0,e.DISCONNECT=1,e.EVENT=2,e.ACK=3,e.ERROR=4,e.BINARY_EVENT=5,e.BINARY_ACK=6,e.Encoder=n,e.Decoder=a;var m=e.ERROR+'"encode error"';n.prototype.encode=function(t,r){if(e.BINARY_EVENT===t.type||e.BINARY_ACK===t.type)s(t,r);else{var n=o(t);r([n])}},f(a.prototype),a.prototype.add=function(t){var r;if("string"==typeof t)r=c(t),e.BINARY_EVENT===r.type||e.BINARY_ACK===r.type?(this.reconstructor=new p(r),0===this.reconstructor.reconPack.attachments&&this.emit("decoded",r)):this.emit("decoded",r);else{if(!y(t)&&!t.base64)throw new Error("Unknown type: "+t);if(!this.reconstructor)throw new Error("got binary data when not reconstructing a packet");r=this.reconstructor.takeBinaryData(t),r&&(this.reconstructor=null,this.emit("decoded",r))}},a.prototype.destroy=function(){this.reconstructor&&this.reconstructor.finishedReconstruction()},p.prototype.takeBinaryData=function(t){if(this.buffers.push(t),this.buffers.length===this.reconPack.attachments){var e=l.reconstructPacket(this.reconPack,this.buffers);return this.finishedReconstruction(),e}return null},p.prototype.finishedReconstruction=function(){this.reconPack=null,this.buffers=[]}},function(t,e,r){function n(t){if(t)return o(t)}function o(t){for(var e in n.prototype)t[e]=n.prototype[e];return t}t.exports=n,n.prototype.on=n.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+t]=this._callbacks["$"+t]||[]).push(e),this},n.prototype.once=function(t,e){function r(){this.off(t,r),e.apply(this,arguments)}return r.fn=e,this.on(t,r),this},n.prototype.off=n.prototype.removeListener=n.prototype.removeAllListeners=n.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var r=this._callbacks["$"+t];if(!r)return this;if(1==arguments.length)return delete this._callbacks["$"+t],this;for(var n,o=0;o<r.length;o++)if(n=r[o],n===e||n.fn===e){r.splice(o,1);break}return this},n.prototype.emit=function(t){this._callbacks=this._callbacks||{};var e=[].slice.call(arguments,1),r=this._callbacks["$"+t];if(r){r=r.slice(0);for(var n=0,o=r.length;n<o;++n)r[n].apply(this,e)}return this},n.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks["$"+t]||[]},n.prototype.hasListeners=function(t){return!!this.listeners(t).length}},function(t,e,r){(function(t){function n(t,e){if(!t)return t;if(s(t)){var r={_placeholder:!0,num:e.length};return e.push(t),r}if(i(t)){for(var o=new Array(t.length),a=0;a<t.length;a++)o[a]=n(t[a],e);return o}if("object"==typeof t&&!(t instanceof Date)){var o={};for(var c in t)o[c]=n(t[c],e);return o}return t}function o(t,e){if(!t)return t;if(t&&t._placeholder)return e[t.num];if(i(t))for(var r=0;r<t.length;r++)t[r]=o(t[r],e);else if("object"==typeof t)for(var n in t)t[n]=o(t[n],e);return t}var i=r(7),s=r(8),a=Object.prototype.toString,c="function"==typeof t.Blob||"[object BlobConstructor]"===a.call(t.Blob),h="function"==typeof t.File||"[object FileConstructor]"===a.call(t.File);e.deconstructPacket=function(t){var e=[],r=t.data,o=t;return o.data=n(r,e),o.attachments=e.length,{packet:o,buffers:e}},e.reconstructPacket=function(t,e){return t.data=o(t.data,e),t.attachments=void 0,t},e.removeBlobs=function(t,e){function r(t,a,p){if(!t)return t;if(c&&t instanceof Blob||h&&t instanceof File){n++;var u=new FileReader;u.onload=function(){p?p[a]=this.result:o=this.result,--n||e(o)},u.readAsArrayBuffer(t)}else if(i(t))for(var f=0;f<t.length;f++)r(t[f],f,t);else if("object"==typeof t&&!s(t))for(var l in t)r(t[l],l,t)}var n=0,o=t;r(o),n||e(o)}}).call(e,function(){return this}())},function(t,e){var r={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==r.call(t)}},function(t,e){(function(e){function r(t){return n&&e.Buffer.isBuffer(t)||o&&(t instanceof e.ArrayBuffer||i(t))}t.exports=r;var n="function"==typeof e.Buffer&&"function"==typeof e.Buffer.isBuffer,o="function"==typeof e.ArrayBuffer,i=function(){return o&&"function"==typeof e.ArrayBuffer.isView?e.ArrayBuffer.isView:function(t){return t.buffer instanceof e.ArrayBuffer}}()}).call(e,function(){return this}())},function(t,e,r){"use strict";function n(t,e){if(!(this instanceof n))return new n(t,e);t&&"object"===("undefined"==typeof t?"undefined":o(t))&&(e=t,t=void 0),e=e||{},e.path=e.path||"/socket.io",this.nsps={},this.subs=[],this.opts=e,this.reconnection(e.reconnection!==!1),this.reconnectionAttempts(e.reconnectionAttempts||1/0),this.reconnectionDelay(e.reconnectionDelay||1e3),this.reconnectionDelayMax(e.reconnectionDelayMax||5e3),this.randomizationFactor(e.randomizationFactor||.5),this.backoff=new f({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()}),this.timeout(null==e.timeout?2e4:e.timeout),this.readyState="closed",this.uri=t,this.connecting=[],this.lastPing=null,this.encoding=!1,this.packetBuffer=[];var r=e.parser||c;this.encoder=new r.Encoder,this.decoder=new r.Decoder,this.autoConnect=e.autoConnect!==!1,this.autoConnect&&this.open()}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=r(10),s=r(34),a=r(5),c=r(4),h=r(36),p=r(37),u=(r(3)("socket.io-client:manager"),r(33)),f=r(38),l=Object.prototype.hasOwnProperty;t.exports=n,n.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var t in this.nsps)l.call(this.nsps,t)&&this.nsps[t].emit.apply(this.nsps[t],arguments)},n.prototype.updateSocketIds=function(){for(var t in this.nsps)l.call(this.nsps,t)&&(this.nsps[t].id=this.generateId(t))},n.prototype.generateId=function(t){return("/"===t?"":t+"#")+this.engine.id},a(n.prototype),n.prototype.reconnection=function(t){return arguments.length?(this._reconnection=!!t,this):this._reconnection},n.prototype.reconnectionAttempts=function(t){return arguments.length?(this._reconnectionAttempts=t,this):this._reconnectionAttempts},n.prototype.reconnectionDelay=function(t){return arguments.length?(this._reconnectionDelay=t,this.backoff&&this.backoff.setMin(t),this):this._reconnectionDelay},n.prototype.randomizationFactor=function(t){return arguments.length?(this._randomizationFactor=t,this.backoff&&this.backoff.setJitter(t),this):this._randomizationFactor},n.prototype.reconnectionDelayMax=function(t){return arguments.length?(this._reconnectionDelayMax=t,this.backoff&&this.backoff.setMax(t),this):this._reconnectionDelayMax},n.prototype.timeout=function(t){return arguments.length?(this._timeout=t,this):this._timeout},n.prototype.maybeReconnectOnOpen=function(){!this.reconnecting&&this._reconnection&&0===this.backoff.attempts&&this.reconnect()},n.prototype.open=n.prototype.connect=function(t,e){if(~this.readyState.indexOf("open"))return this;this.engine=i(this.uri,this.opts);var r=this.engine,n=this;this.readyState="opening",this.skipReconnect=!1;var o=h(r,"open",function(){n.onopen(),t&&t()}),s=h(r,"error",function(e){if(n.cleanup(),n.readyState="closed",n.emitAll("connect_error",e),t){var r=new Error("Connection error");r.data=e,t(r)}else n.maybeReconnectOnOpen()});if(!1!==this._timeout){var a=this._timeout,c=setTimeout(function(){o.destroy(),r.close(),r.emit("error","timeout"),n.emitAll("connect_timeout",a)},a);this.subs.push({destroy:function(){clearTimeout(c)}})}return this.subs.push(o),this.subs.push(s),this},n.prototype.onopen=function(){this.cleanup(),this.readyState="open",this.emit("open");var t=this.engine;this.subs.push(h(t,"data",p(this,"ondata"))),this.subs.push(h(t,"ping",p(this,"onping"))),this.subs.push(h(t,"pong",p(this,"onpong"))),this.subs.push(h(t,"error",p(this,"onerror"))),this.subs.push(h(t,"close",p(this,"onclose"))),this.subs.push(h(this.decoder,"decoded",p(this,"ondecoded")))},n.prototype.onping=function(){this.lastPing=new Date,this.emitAll("ping")},n.prototype.onpong=function(){this.emitAll("pong",new Date-this.lastPing)},n.prototype.ondata=function(t){this.decoder.add(t)},n.prototype.ondecoded=function(t){this.emit("packet",t)},n.prototype.onerror=function(t){this.emitAll("error",t)},n.prototype.socket=function(t,e){function r(){~u(o.connecting,n)||o.connecting.push(n)}var n=this.nsps[t];if(!n){n=new s(this,t,e),this.nsps[t]=n;var o=this;n.on("connecting",r),n.on("connect",function(){n.id=o.generateId(t)}),this.autoConnect&&r()}return n},n.prototype.destroy=function(t){var e=u(this.connecting,t);~e&&this.connecting.splice(e,1),this.connecting.length||this.close()},n.prototype.packet=function(t){var e=this;t.query&&0===t.type&&(t.nsp+="?"+t.query),e.encoding?e.packetBuffer.push(t):(e.encoding=!0,this.encoder.encode(t,function(r){for(var n=0;n<r.length;n++)e.engine.write(r[n],t.options);e.encoding=!1,e.processPacketQueue()}))},n.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var t=this.packetBuffer.shift();this.packet(t)}},n.prototype.cleanup=function(){for(var t=this.subs.length,e=0;e<t;e++){var r=this.subs.shift();r.destroy()}this.packetBuffer=[],this.encoding=!1,this.lastPing=null,this.decoder.destroy()},n.prototype.close=n.prototype.disconnect=function(){this.skipReconnect=!0,this.reconnecting=!1,"opening"===this.readyState&&this.cleanup(),this.backoff.reset(),this.readyState="closed",this.engine&&this.engine.close()},n.prototype.onclose=function(t){this.cleanup(),this.backoff.reset(),this.readyState="closed",this.emit("close",t),this._reconnection&&!this.skipReconnect&&this.reconnect()},n.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var t=this;if(this.backoff.attempts>=this._reconnectionAttempts)this.backoff.reset(),this.emitAll("reconnect_failed"),this.reconnecting=!1;else{var e=this.backoff.duration();this.reconnecting=!0;var r=setTimeout(function(){t.skipReconnect||(t.emitAll("reconnect_attempt",t.backoff.attempts),t.emitAll("reconnecting",t.backoff.attempts),t.skipReconnect||t.open(function(e){e?(t.reconnecting=!1,t.reconnect(),t.emitAll("reconnect_error",e.data)):t.onreconnect()}))},e);this.subs.push({destroy:function(){clearTimeout(r)}})}},n.prototype.onreconnect=function(){var t=this.backoff.attempts;this.reconnecting=!1,this.backoff.reset(),this.updateSocketIds(),this.emitAll("reconnect",t)}},function(t,e,r){t.exports=r(11),t.exports.parser=r(18)},function(t,e,r){(function(e){function n(t,r){if(!(this instanceof n))return new n(t,r);r=r||{},t&&"object"==typeof t&&(r=t,t=null),t?(t=h(t),r.hostname=t.host,r.secure="https"===t.protocol||"wss"===t.protocol,r.port=t.port,t.query&&(r.query=t.query)):r.host&&(r.hostname=h(r.host).host),this.secure=null!=r.secure?r.secure:e.location&&"https:"===location.protocol,r.hostname&&!r.port&&(r.port=this.secure?"443":"80"),this.agent=r.agent||!1,this.hostname=r.hostname||(e.location?location.hostname:"localhost"),this.port=r.port||(e.location&&location.port?location.port:this.secure?443:80),this.query=r.query||{},"string"==typeof this.query&&(this.query=p.decode(this.query)),this.upgrade=!1!==r.upgrade,this.path=(r.path||"/engine.io").replace(/\/$/,"")+"/",this.forceJSONP=!!r.forceJSONP,this.jsonp=!1!==r.jsonp,this.forceBase64=!!r.forceBase64,this.enablesXDR=!!r.enablesXDR,this.timestampParam=r.timestampParam||"t",this.timestampRequests=r.timestampRequests,this.transports=r.transports||["polling","websocket"],this.transportOptions=r.transportOptions||{},this.readyState="",this.writeBuffer=[],this.prevBufferLen=0,this.policyPort=r.policyPort||843,this.rememberUpgrade=r.rememberUpgrade||!1,this.binaryType=null,this.onlyBinaryUpgrades=r.onlyBinaryUpgrades,this.perMessageDeflate=!1!==r.perMessageDeflate&&(r.perMessageDeflate||{}),!0===this.perMessageDeflate&&(this.perMessageDeflate={}),this.perMessageDeflate&&null==this.perMessageDeflate.threshold&&(this.perMessageDeflate.threshold=1024),this.pfx=r.pfx||null,this.key=r.key||null,this.passphrase=r.passphrase||null,this.cert=r.cert||null,this.ca=r.ca||null,this.ciphers=r.ciphers||null,this.rejectUnauthorized=void 0===r.rejectUnauthorized||r.rejectUnauthorized,this.forceNode=!!r.forceNode;var o="object"==typeof e&&e;o.global===o&&(r.extraHeaders&&Object.keys(r.extraHeaders).length>0&&(this.extraHeaders=r.extraHeaders),r.localAddress&&(this.localAddress=r.localAddress)),this.id=null,this.upgrades=null,this.pingInterval=null,this.pingTimeout=null,this.pingIntervalTimer=null,this.pingTimeoutTimer=null,this.open()}function o(t){var e={};for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r]);return e}var i=r(12),s=r(5),a=(r(3)("engine.io-client:socket"),r(33)),c=r(18),h=r(2),p=r(27);t.exports=n,n.priorWebsocketSuccess=!1,s(n.prototype),n.protocol=c.protocol,n.Socket=n,n.Transport=r(17),n.transports=r(12),n.parser=r(18),n.prototype.createTransport=function(t){var e=o(this.query);e.EIO=c.protocol,e.transport=t;var r=this.transportOptions[t]||{};this.id&&(e.sid=this.id);var n=new i[t]({query:e,socket:this,agent:r.agent||this.agent,hostname:r.hostname||this.hostname,port:r.port||this.port,secure:r.secure||this.secure,path:r.path||this.path,forceJSONP:r.forceJSONP||this.forceJSONP,jsonp:r.jsonp||this.jsonp,forceBase64:r.forceBase64||this.forceBase64,enablesXDR:r.enablesXDR||this.enablesXDR,timestampRequests:r.timestampRequests||this.timestampRequests,timestampParam:r.timestampParam||this.timestampParam,policyPort:r.policyPort||this.policyPort,pfx:r.pfx||this.pfx,key:r.key||this.key,passphrase:r.passphrase||this.passphrase,cert:r.cert||this.cert,ca:r.ca||this.ca,ciphers:r.ciphers||this.ciphers,rejectUnauthorized:r.rejectUnauthorized||this.rejectUnauthorized,perMessageDeflate:r.perMessageDeflate||this.perMessageDeflate,extraHeaders:r.extraHeaders||this.extraHeaders,forceNode:r.forceNode||this.forceNode,localAddress:r.localAddress||this.localAddress,requestTimeout:r.requestTimeout||this.requestTimeout,protocols:r.protocols||void 0});return n},n.prototype.open=function(){var t;if(this.rememberUpgrade&&n.priorWebsocketSuccess&&this.transports.indexOf("websocket")!==-1)t="websocket";else{if(0===this.transports.length){var e=this;return void setTimeout(function(){e.emit("error","No transports available")},0)}t=this.transports[0]}this.readyState="opening";try{t=this.createTransport(t)}catch(t){return this.transports.shift(),void this.open()}t.open(),this.setTransport(t)},n.prototype.setTransport=function(t){var e=this;this.transport&&this.transport.removeAllListeners(),this.transport=t,t.on("drain",function(){e.onDrain()}).on("packet",function(t){e.onPacket(t)}).on("error",function(t){e.onError(t)}).on("close",function(){e.onClose("transport close")})},n.prototype.probe=function(t){function e(){if(u.onlyBinaryUpgrades){var t=!this.supportsBinary&&u.transport.supportsBinary;p=p||t}p||(h.send([{type:"ping",data:"probe"}]),h.once("packet",function(t){if(!p)if("pong"===t.type&&"probe"===t.data){if(u.upgrading=!0,u.emit("upgrading",h),!h)return;n.priorWebsocketSuccess="websocket"===h.name,u.transport.pause(function(){p||"closed"!==u.readyState&&(c(),u.setTransport(h),h.send([{type:"upgrade"}]),u.emit("upgrade",h),h=null,u.upgrading=!1,u.flush())})}else{var e=new Error("probe error");e.transport=h.name,u.emit("upgradeError",e)}}))}function r(){p||(p=!0,c(),h.close(),h=null)}function o(t){var e=new Error("probe error: "+t);e.transport=h.name,r(),u.emit("upgradeError",e)}function i(){o("transport closed")}function s(){o("socket closed")}function a(t){h&&t.name!==h.name&&r()}function c(){h.removeListener("open",e),h.removeListener("error",o),h.removeListener("close",i),u.removeListener("close",s),u.removeListener("upgrading",a)}var h=this.createTransport(t,{probe:1}),p=!1,u=this;n.priorWebsocketSuccess=!1,h.once("open",e),h.once("error",o),h.once("close",i),this.once("close",s),this.once("upgrading",a),h.open()},n.prototype.onOpen=function(){if(this.readyState="open",n.priorWebsocketSuccess="websocket"===this.transport.name,this.emit("open"),this.flush(),"open"===this.readyState&&this.upgrade&&this.transport.pause)for(var t=0,e=this.upgrades.length;t<e;t++)this.probe(this.upgrades[t])},n.prototype.onPacket=function(t){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState)switch(this.emit("packet",t),this.emit("heartbeat"),t.type){case"open":this.onHandshake(JSON.parse(t.data));break;case"pong":this.setPing(),this.emit("pong");break;case"error":var e=new Error("server error");e.code=t.data,this.onError(e);break;case"message":this.emit("data",t.data),this.emit("message",t.data)}},n.prototype.onHandshake=function(t){this.emit("handshake",t),this.id=t.sid,this.transport.query.sid=t.sid,this.upgrades=this.filterUpgrades(t.upgrades),this.pingInterval=t.pingInterval,this.pingTimeout=t.pingTimeout,this.onOpen(),"closed"!==this.readyState&&(this.setPing(),this.removeListener("heartbeat",this.onHeartbeat),this.on("heartbeat",this.onHeartbeat))},n.prototype.onHeartbeat=function(t){clearTimeout(this.pingTimeoutTimer);var e=this;e.pingTimeoutTimer=setTimeout(function(){"closed"!==e.readyState&&e.onClose("ping timeout")},t||e.pingInterval+e.pingTimeout)},n.prototype.setPing=function(){var t=this;clearTimeout(t.pingIntervalTimer),t.pingIntervalTimer=setTimeout(function(){t.ping(),t.onHeartbeat(t.pingTimeout)},t.pingInterval)},n.prototype.ping=function(){var t=this;this.sendPacket("ping",function(){t.emit("ping")})},n.prototype.onDrain=function(){this.writeBuffer.splice(0,this.prevBufferLen),this.prevBufferLen=0,0===this.writeBuffer.length?this.emit("drain"):this.flush()},n.prototype.flush=function(){"closed"!==this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length&&(this.transport.send(this.writeBuffer),this.prevBufferLen=this.writeBuffer.length,this.emit("flush"))},n.prototype.write=n.prototype.send=function(t,e,r){return this.sendPacket("message",t,e,r),this},n.prototype.sendPacket=function(t,e,r,n){if("function"==typeof e&&(n=e,e=void 0),"function"==typeof r&&(n=r,r=null),"closing"!==this.readyState&&"closed"!==this.readyState){r=r||{},r.compress=!1!==r.compress;var o={type:t,data:e,options:r};this.emit("packetCreate",o),this.writeBuffer.push(o),n&&this.once("flush",n),this.flush()}},n.prototype.close=function(){function t(){n.onClose("forced close"),n.transport.close()}function e(){n.removeListener("upgrade",e),n.removeListener("upgradeError",e),t()}function r(){n.once("upgrade",e),n.once("upgradeError",e)}if("opening"===this.readyState||"open"===this.readyState){this.readyState="closing";var n=this;this.writeBuffer.length?this.once("drain",function(){this.upgrading?r():t()}):this.upgrading?r():t()}return this},n.prototype.onError=function(t){n.priorWebsocketSuccess=!1,this.emit("error",t),this.onClose("transport error",t)},n.prototype.onClose=function(t,e){if("opening"===this.readyState||"open"===this.readyState||"closing"===this.readyState){var r=this;clearTimeout(this.pingIntervalTimer),clearTimeout(this.pingTimeoutTimer),this.transport.removeAllListeners("close"),this.transport.close(),this.transport.removeAllListeners(),this.readyState="closed",this.id=null,this.emit("close",t,e),r.writeBuffer=[],r.prevBufferLen=0}},n.prototype.filterUpgrades=function(t){for(var e=[],r=0,n=t.length;r<n;r++)~a(this.transports,t[r])&&e.push(t[r]);return e}}).call(e,function(){return this}())},function(t,e,r){(function(t){function n(e){var r,n=!1,a=!1,c=!1!==e.jsonp;if(t.location){var h="https:"===location.protocol,p=location.port;p||(p=h?443:80),n=e.hostname!==location.hostname||p!==e.port,a=e.secure!==h}if(e.xdomain=n,e.xscheme=a,r=new o(e),"open"in r&&!e.forceJSONP)return new i(e);if(!c)throw new Error("JSONP disabled");return new s(e)}var o=r(13),i=r(15),s=r(30),a=r(31);e.polling=n,e.websocket=a}).call(e,function(){return this}())},function(t,e,r){(function(e){var n=r(14);t.exports=function(t){var r=t.xdomain,o=t.xscheme,i=t.enablesXDR;try{if("undefined"!=typeof XMLHttpRequest&&(!r||n))return new XMLHttpRequest}catch(t){}try{if("undefined"!=typeof XDomainRequest&&!o&&i)return new XDomainRequest}catch(t){}if(!r)try{return new(e[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")}catch(t){}}}).call(e,function(){return this}())},function(t,e){try{t.exports="undefined"!=typeof XMLHttpRequest&&"withCredentials"in new XMLHttpRequest}catch(e){t.exports=!1}},function(t,e,r){(function(e){function n(){}function o(t){if(c.call(this,t),this.requestTimeout=t.requestTimeout,this.extraHeaders=t.extraHeaders,e.location){var r="https:"===location.protocol,n=location.port;n||(n=r?443:80),this.xd=t.hostname!==e.location.hostname||n!==t.port,this.xs=t.secure!==r}}function i(t){this.method=t.method||"GET",this.uri=t.uri,this.xd=!!t.xd,this.xs=!!t.xs,this.async=!1!==t.async,this.data=void 0!==t.data?t.data:null,this.agent=t.agent,this.isBinary=t.isBinary,this.supportsBinary=t.supportsBinary,this.enablesXDR=t.enablesXDR,this.requestTimeout=t.requestTimeout,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.extraHeaders=t.extraHeaders,this.create()}function s(){for(var t in i.requests)i.requests.hasOwnProperty(t)&&i.requests[t].abort()}var a=r(13),c=r(16),h=r(5),p=r(28);r(3)("engine.io-client:polling-xhr");t.exports=o,t.exports.Request=i,p(o,c),o.prototype.supportsBinary=!0,o.prototype.request=function(t){return t=t||{},t.uri=this.uri(),t.xd=this.xd,t.xs=this.xs,t.agent=this.agent||!1,t.supportsBinary=this.supportsBinary,t.enablesXDR=this.enablesXDR,t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized,t.requestTimeout=this.requestTimeout,t.extraHeaders=this.extraHeaders,new i(t)},o.prototype.doWrite=function(t,e){var r="string"!=typeof t&&void 0!==t,n=this.request({method:"POST",data:t,isBinary:r}),o=this;n.on("success",e),n.on("error",function(t){o.onError("xhr post error",t)}),this.sendXhr=n},o.prototype.doPoll=function(){var t=this.request(),e=this;t.on("data",function(t){e.onData(t)}),t.on("error",function(t){e.onError("xhr poll error",t)}),this.pollXhr=t},h(i.prototype),i.prototype.create=function(){var t={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};t.pfx=this.pfx,t.key=this.key,t.passphrase=this.passphrase,t.cert=this.cert,t.ca=this.ca,t.ciphers=this.ciphers,t.rejectUnauthorized=this.rejectUnauthorized;var r=this.xhr=new a(t),n=this;try{r.open(this.method,this.uri,this.async);try{if(this.extraHeaders){r.setDisableHeaderCheck&&r.setDisableHeaderCheck(!0);for(var o in this.extraHeaders)this.extraHeaders.hasOwnProperty(o)&&r.setRequestHeader(o,this.extraHeaders[o])}}catch(t){}if("POST"===this.method)try{this.isBinary?r.setRequestHeader("Content-type","application/octet-stream"):r.setRequestHeader("Content-type","text/plain;charset=UTF-8")}catch(t){}try{r.setRequestHeader("Accept","*/*")}catch(t){}"withCredentials"in r&&(r.withCredentials=!0),this.requestTimeout&&(r.timeout=this.requestTimeout),this.hasXDR()?(r.onload=function(){n.onLoad()},r.onerror=function(){n.onError(r.responseText)}):r.onreadystatechange=function(){if(2===r.readyState)try{var t=r.getResponseHeader("Content-Type");n.supportsBinary&&"application/octet-stream"===t&&(r.responseType="arraybuffer")}catch(t){}4===r.readyState&&(200===r.status||1223===r.status?n.onLoad():setTimeout(function(){n.onError(r.status)},0))},r.send(this.data)}catch(t){return void setTimeout(function(){n.onError(t)},0)}e.document&&(this.index=i.requestsCount++,i.requests[this.index]=this)},i.prototype.onSuccess=function(){this.emit("success"),this.cleanup()},i.prototype.onData=function(t){this.emit("data",t),this.onSuccess()},i.prototype.onError=function(t){this.emit("error",t),this.cleanup(!0)},i.prototype.cleanup=function(t){if("undefined"!=typeof this.xhr&&null!==this.xhr){if(this.hasXDR()?this.xhr.onload=this.xhr.onerror=n:this.xhr.onreadystatechange=n,t)try{this.xhr.abort()}catch(t){}e.document&&delete i.requests[this.index],this.xhr=null}},i.prototype.onLoad=function(){var t;try{var e;try{e=this.xhr.getResponseHeader("Content-Type")}catch(t){}t="application/octet-stream"===e?this.xhr.response||this.xhr.responseText:this.xhr.responseText}catch(t){this.onError(t)}null!=t&&this.onData(t)},i.prototype.hasXDR=function(){return"undefined"!=typeof e.XDomainRequest&&!this.xs&&this.enablesXDR},i.prototype.abort=function(){this.cleanup()},i.requestsCount=0,i.requests={},e.document&&(e.attachEvent?e.attachEvent("onunload",s):e.addEventListener&&e.addEventListener("beforeunload",s,!1))}).call(e,function(){return this}())},function(t,e,r){function n(t){var e=t&&t.forceBase64;h&&!e||(this.supportsBinary=!1),o.call(this,t)}var o=r(17),i=r(27),s=r(18),a=r(28),c=r(29);r(3)("engine.io-client:polling");t.exports=n;var h=function(){var t=r(13),e=new t({xdomain:!1});return null!=e.responseType}();a(n,o),n.prototype.name="polling",n.prototype.doOpen=function(){this.poll()},n.prototype.pause=function(t){function e(){r.readyState="paused",t()}var r=this;if(this.readyState="pausing",this.polling||!this.writable){var n=0;this.polling&&(n++,this.once("pollComplete",function(){--n||e()})),this.writable||(n++,this.once("drain",function(){--n||e()}))}else e()},n.prototype.poll=function(){this.polling=!0,this.doPoll(),this.emit("poll")},n.prototype.onData=function(t){var e=this,r=function(t,r,n){return"opening"===e.readyState&&e.onOpen(),"close"===t.type?(e.onClose(),!1):void e.onPacket(t)};s.decodePayload(t,this.socket.binaryType,r),"closed"!==this.readyState&&(this.polling=!1,this.emit("pollComplete"),"open"===this.readyState&&this.poll())},n.prototype.doClose=function(){function t(){e.write([{type:"close"}])}var e=this;"open"===this.readyState?t():this.once("open",t)},n.prototype.write=function(t){var e=this;this.writable=!1;var r=function(){e.writable=!0,e.emit("drain")};s.encodePayload(t,this.supportsBinary,function(t){e.doWrite(t,r)})},n.prototype.uri=function(){var t=this.query||{},e=this.secure?"https":"http",r="";!1!==this.timestampRequests&&(t[this.timestampParam]=c()),this.supportsBinary||t.sid||(t.b64=1),t=i.encode(t),this.port&&("https"===e&&443!==Number(this.port)||"http"===e&&80!==Number(this.port))&&(r=":"+this.port),t.length&&(t="?"+t);var n=this.hostname.indexOf(":")!==-1;return e+"://"+(n?"["+this.hostname+"]":this.hostname)+r+this.path+t}},function(t,e,r){function n(t){this.path=t.path,this.hostname=t.hostname,this.port=t.port,this.secure=t.secure,this.query=t.query,this.timestampParam=t.timestampParam,this.timestampRequests=t.timestampRequests,this.readyState="",this.agent=t.agent||!1,this.socket=t.socket,this.enablesXDR=t.enablesXDR,this.pfx=t.pfx,this.key=t.key,this.passphrase=t.passphrase,this.cert=t.cert,this.ca=t.ca,this.ciphers=t.ciphers,this.rejectUnauthorized=t.rejectUnauthorized,this.forceNode=t.forceNode,this.extraHeaders=t.extraHeaders,this.localAddress=t.localAddress}var o=r(18),i=r(5);t.exports=n,i(n.prototype),n.prototype.onError=function(t,e){var r=new Error(t);return r.type="TransportError",r.description=e,this.emit("error",r),this},n.prototype.open=function(){return"closed"!==this.readyState&&""!==this.readyState||(this.readyState="opening",this.doOpen()),this},n.prototype.close=function(){return"opening"!==this.readyState&&"open"!==this.readyState||(this.doClose(),this.onClose()),this},n.prototype.send=function(t){if("open"!==this.readyState)throw new Error("Transport not open");this.write(t)},n.prototype.onOpen=function(){this.readyState="open",this.writable=!0,this.emit("open")},n.prototype.onData=function(t){var e=o.decodePacket(t,this.socket.binaryType);this.onPacket(e)},n.prototype.onPacket=function(t){this.emit("packet",t)},n.prototype.onClose=function(){this.readyState="closed",this.emit("close")}},function(t,e,r){(function(t){function n(t,r){var n="b"+e.packets[t.type]+t.data.data;return r(n)}function o(t,r,n){if(!r)return e.encodeBase64Packet(t,n);
var o=t.data,i=new Uint8Array(o),s=new Uint8Array(1+o.byteLength);s[0]=v[t.type];for(var a=0;a<i.length;a++)s[a+1]=i[a];return n(s.buffer)}function i(t,r,n){if(!r)return e.encodeBase64Packet(t,n);var o=new FileReader;return o.onload=function(){t.data=o.result,e.encodePacket(t,r,!0,n)},o.readAsArrayBuffer(t.data)}function s(t,r,n){if(!r)return e.encodeBase64Packet(t,n);if(g)return i(t,r,n);var o=new Uint8Array(1);o[0]=v[t.type];var s=new w([o.buffer,t.data]);return n(s)}function a(t){try{t=d.decode(t,{strict:!1})}catch(t){return!1}return t}function c(t,e,r){for(var n=new Array(t.length),o=l(t.length,r),i=function(t,r,o){e(r,function(e,r){n[t]=r,o(e,n)})},s=0;s<t.length;s++)i(s,t[s],o)}var h,p=r(19),u=r(20),f=r(21),l=r(22),d=r(23);t&&t.ArrayBuffer&&(h=r(25));var y="undefined"!=typeof navigator&&/Android/i.test(navigator.userAgent),m="undefined"!=typeof navigator&&/PhantomJS/i.test(navigator.userAgent),g=y||m;e.protocol=3;var v=e.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6},b=p(v),k={type:"error",data:"parser error"},w=r(26);e.encodePacket=function(e,r,i,a){"function"==typeof r&&(a=r,r=!1),"function"==typeof i&&(a=i,i=null);var c=void 0===e.data?void 0:e.data.buffer||e.data;if(t.ArrayBuffer&&c instanceof ArrayBuffer)return o(e,r,a);if(w&&c instanceof t.Blob)return s(e,r,a);if(c&&c.base64)return n(e,a);var h=v[e.type];return void 0!==e.data&&(h+=i?d.encode(String(e.data),{strict:!1}):String(e.data)),a(""+h)},e.encodeBase64Packet=function(r,n){var o="b"+e.packets[r.type];if(w&&r.data instanceof t.Blob){var i=new FileReader;return i.onload=function(){var t=i.result.split(",")[1];n(o+t)},i.readAsDataURL(r.data)}var s;try{s=String.fromCharCode.apply(null,new Uint8Array(r.data))}catch(t){for(var a=new Uint8Array(r.data),c=new Array(a.length),h=0;h<a.length;h++)c[h]=a[h];s=String.fromCharCode.apply(null,c)}return o+=t.btoa(s),n(o)},e.decodePacket=function(t,r,n){if(void 0===t)return k;if("string"==typeof t){if("b"===t.charAt(0))return e.decodeBase64Packet(t.substr(1),r);if(n&&(t=a(t),t===!1))return k;var o=t.charAt(0);return Number(o)==o&&b[o]?t.length>1?{type:b[o],data:t.substring(1)}:{type:b[o]}:k}var i=new Uint8Array(t),o=i[0],s=f(t,1);return w&&"blob"===r&&(s=new w([s])),{type:b[o],data:s}},e.decodeBase64Packet=function(t,e){var r=b[t.charAt(0)];if(!h)return{type:r,data:{base64:!0,data:t.substr(1)}};var n=h.decode(t.substr(1));return"blob"===e&&w&&(n=new w([n])),{type:r,data:n}},e.encodePayload=function(t,r,n){function o(t){return t.length+":"+t}function i(t,n){e.encodePacket(t,!!s&&r,!1,function(t){n(null,o(t))})}"function"==typeof r&&(n=r,r=null);var s=u(t);return r&&s?w&&!g?e.encodePayloadAsBlob(t,n):e.encodePayloadAsArrayBuffer(t,n):t.length?void c(t,i,function(t,e){return n(e.join(""))}):n("0:")},e.decodePayload=function(t,r,n){if("string"!=typeof t)return e.decodePayloadAsBinary(t,r,n);"function"==typeof r&&(n=r,r=null);var o;if(""===t)return n(k,0,1);for(var i,s,a="",c=0,h=t.length;c<h;c++){var p=t.charAt(c);if(":"===p){if(""===a||a!=(i=Number(a)))return n(k,0,1);if(s=t.substr(c+1,i),a!=s.length)return n(k,0,1);if(s.length){if(o=e.decodePacket(s,r,!1),k.type===o.type&&k.data===o.data)return n(k,0,1);var u=n(o,c+i,h);if(!1===u)return}c+=i,a=""}else a+=p}return""!==a?n(k,0,1):void 0},e.encodePayloadAsArrayBuffer=function(t,r){function n(t,r){e.encodePacket(t,!0,!0,function(t){return r(null,t)})}return t.length?void c(t,n,function(t,e){var n=e.reduce(function(t,e){var r;return r="string"==typeof e?e.length:e.byteLength,t+r.toString().length+r+2},0),o=new Uint8Array(n),i=0;return e.forEach(function(t){var e="string"==typeof t,r=t;if(e){for(var n=new Uint8Array(t.length),s=0;s<t.length;s++)n[s]=t.charCodeAt(s);r=n.buffer}e?o[i++]=0:o[i++]=1;for(var a=r.byteLength.toString(),s=0;s<a.length;s++)o[i++]=parseInt(a[s]);o[i++]=255;for(var n=new Uint8Array(r),s=0;s<n.length;s++)o[i++]=n[s]}),r(o.buffer)}):r(new ArrayBuffer(0))},e.encodePayloadAsBlob=function(t,r){function n(t,r){e.encodePacket(t,!0,!0,function(t){var e=new Uint8Array(1);if(e[0]=1,"string"==typeof t){for(var n=new Uint8Array(t.length),o=0;o<t.length;o++)n[o]=t.charCodeAt(o);t=n.buffer,e[0]=0}for(var i=t instanceof ArrayBuffer?t.byteLength:t.size,s=i.toString(),a=new Uint8Array(s.length+1),o=0;o<s.length;o++)a[o]=parseInt(s[o]);if(a[s.length]=255,w){var c=new w([e.buffer,a.buffer,t]);r(null,c)}})}c(t,n,function(t,e){return r(new w(e))})},e.decodePayloadAsBinary=function(t,r,n){"function"==typeof r&&(n=r,r=null);for(var o=t,i=[];o.byteLength>0;){for(var s=new Uint8Array(o),a=0===s[0],c="",h=1;255!==s[h];h++){if(c.length>310)return n(k,0,1);c+=s[h]}o=f(o,2+c.length),c=parseInt(c);var p=f(o,0,c);if(a)try{p=String.fromCharCode.apply(null,new Uint8Array(p))}catch(t){var u=new Uint8Array(p);p="";for(var h=0;h<u.length;h++)p+=String.fromCharCode(u[h])}i.push(p),o=f(o,c)}var l=i.length;i.forEach(function(t,o){n(e.decodePacket(t,r,!0),o,l)})}}).call(e,function(){return this}())},function(t,e){t.exports=Object.keys||function(t){var e=[],r=Object.prototype.hasOwnProperty;for(var n in t)r.call(t,n)&&e.push(n);return e}},function(t,e,r){(function(e){function n(t){if(!t||"object"!=typeof t)return!1;if(o(t)){for(var r=0,i=t.length;r<i;r++)if(n(t[r]))return!0;return!1}if("function"==typeof e.Buffer&&e.Buffer.isBuffer&&e.Buffer.isBuffer(t)||"function"==typeof e.ArrayBuffer&&t instanceof ArrayBuffer||s&&t instanceof Blob||a&&t instanceof File)return!0;if(t.toJSON&&"function"==typeof t.toJSON&&1===arguments.length)return n(t.toJSON(),!0);for(var c in t)if(Object.prototype.hasOwnProperty.call(t,c)&&n(t[c]))return!0;return!1}var o=r(7),i=Object.prototype.toString,s="function"==typeof e.Blob||"[object BlobConstructor]"===i.call(e.Blob),a="function"==typeof e.File||"[object FileConstructor]"===i.call(e.File);t.exports=n}).call(e,function(){return this}())},function(t,e){t.exports=function(t,e,r){var n=t.byteLength;if(e=e||0,r=r||n,t.slice)return t.slice(e,r);if(e<0&&(e+=n),r<0&&(r+=n),r>n&&(r=n),e>=n||e>=r||0===n)return new ArrayBuffer(0);for(var o=new Uint8Array(t),i=new Uint8Array(r-e),s=e,a=0;s<r;s++,a++)i[a]=o[s];return i.buffer}},function(t,e){function r(t,e,r){function o(t,n){if(o.count<=0)throw new Error("after called too many times");--o.count,t?(i=!0,e(t),e=r):0!==o.count||i||e(null,n)}var i=!1;return r=r||n,o.count=t,0===t?e():o}function n(){}t.exports=r},function(t,e,r){var n;(function(t,o){!function(i){function s(t){for(var e,r,n=[],o=0,i=t.length;o<i;)e=t.charCodeAt(o++),e>=55296&&e<=56319&&o<i?(r=t.charCodeAt(o++),56320==(64512&r)?n.push(((1023&e)<<10)+(1023&r)+65536):(n.push(e),o--)):n.push(e);return n}function a(t){for(var e,r=t.length,n=-1,o="";++n<r;)e=t[n],e>65535&&(e-=65536,o+=k(e>>>10&1023|55296),e=56320|1023&e),o+=k(e);return o}function c(t,e){if(t>=55296&&t<=57343){if(e)throw Error("Lone surrogate U+"+t.toString(16).toUpperCase()+" is not a scalar value");return!1}return!0}function h(t,e){return k(t>>e&63|128)}function p(t,e){if(0==(4294967168&t))return k(t);var r="";return 0==(4294965248&t)?r=k(t>>6&31|192):0==(4294901760&t)?(c(t,e)||(t=65533),r=k(t>>12&15|224),r+=h(t,6)):0==(4292870144&t)&&(r=k(t>>18&7|240),r+=h(t,12),r+=h(t,6)),r+=k(63&t|128)}function u(t,e){e=e||{};for(var r,n=!1!==e.strict,o=s(t),i=o.length,a=-1,c="";++a<i;)r=o[a],c+=p(r,n);return c}function f(){if(b>=v)throw Error("Invalid byte index");var t=255&g[b];if(b++,128==(192&t))return 63&t;throw Error("Invalid continuation byte")}function l(t){var e,r,n,o,i;if(b>v)throw Error("Invalid byte index");if(b==v)return!1;if(e=255&g[b],b++,0==(128&e))return e;if(192==(224&e)){if(r=f(),i=(31&e)<<6|r,i>=128)return i;throw Error("Invalid continuation byte")}if(224==(240&e)){if(r=f(),n=f(),i=(15&e)<<12|r<<6|n,i>=2048)return c(i,t)?i:65533;throw Error("Invalid continuation byte")}if(240==(248&e)&&(r=f(),n=f(),o=f(),i=(7&e)<<18|r<<12|n<<6|o,i>=65536&&i<=1114111))return i;throw Error("Invalid UTF-8 detected")}function d(t,e){e=e||{};var r=!1!==e.strict;g=s(t),v=g.length,b=0;for(var n,o=[];(n=l(r))!==!1;)o.push(n);return a(o)}var y="object"==typeof e&&e,m=("object"==typeof t&&t&&t.exports==y&&t,"object"==typeof o&&o);m.global!==m&&m.window!==m||(i=m);var g,v,b,k=String.fromCharCode,w={version:"2.1.2",encode:u,decode:d};n=function(){return w}.call(e,r,e,t),!(void 0!==n&&(t.exports=n))}(this)}).call(e,r(24)(t),function(){return this}())},function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children=[],t.webpackPolyfill=1),t}},function(t,e){!function(){"use strict";for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",r=new Uint8Array(256),n=0;n<t.length;n++)r[t.charCodeAt(n)]=n;e.encode=function(e){var r,n=new Uint8Array(e),o=n.length,i="";for(r=0;r<o;r+=3)i+=t[n[r]>>2],i+=t[(3&n[r])<<4|n[r+1]>>4],i+=t[(15&n[r+1])<<2|n[r+2]>>6],i+=t[63&n[r+2]];return o%3===2?i=i.substring(0,i.length-1)+"=":o%3===1&&(i=i.substring(0,i.length-2)+"=="),i},e.decode=function(t){var e,n,o,i,s,a=.75*t.length,c=t.length,h=0;"="===t[t.length-1]&&(a--,"="===t[t.length-2]&&a--);var p=new ArrayBuffer(a),u=new Uint8Array(p);for(e=0;e<c;e+=4)n=r[t.charCodeAt(e)],o=r[t.charCodeAt(e+1)],i=r[t.charCodeAt(e+2)],s=r[t.charCodeAt(e+3)],u[h++]=n<<2|o>>4,u[h++]=(15&o)<<4|i>>2,u[h++]=(3&i)<<6|63&s;return p}}()},function(t,e){(function(e){function r(t){for(var e=0;e<t.length;e++){var r=t[e];if(r.buffer instanceof ArrayBuffer){var n=r.buffer;if(r.byteLength!==n.byteLength){var o=new Uint8Array(r.byteLength);o.set(new Uint8Array(n,r.byteOffset,r.byteLength)),n=o.buffer}t[e]=n}}}function n(t,e){e=e||{};var n=new i;r(t);for(var o=0;o<t.length;o++)n.append(t[o]);return e.type?n.getBlob(e.type):n.getBlob()}function o(t,e){return r(t),new Blob(t,e||{})}var i=e.BlobBuilder||e.WebKitBlobBuilder||e.MSBlobBuilder||e.MozBlobBuilder,s=function(){try{var t=new Blob(["hi"]);return 2===t.size}catch(t){return!1}}(),a=s&&function(){try{var t=new Blob([new Uint8Array([1,2])]);return 2===t.size}catch(t){return!1}}(),c=i&&i.prototype.append&&i.prototype.getBlob;t.exports=function(){return s?a?e.Blob:o:c?n:void 0}()}).call(e,function(){return this}())},function(t,e){e.encode=function(t){var e="";for(var r in t)t.hasOwnProperty(r)&&(e.length&&(e+="&"),e+=encodeURIComponent(r)+"="+encodeURIComponent(t[r]));return e},e.decode=function(t){for(var e={},r=t.split("&"),n=0,o=r.length;n<o;n++){var i=r[n].split("=");e[decodeURIComponent(i[0])]=decodeURIComponent(i[1])}return e}},function(t,e){t.exports=function(t,e){var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t}},function(t,e){"use strict";function r(t){var e="";do e=s[t%a]+e,t=Math.floor(t/a);while(t>0);return e}function n(t){var e=0;for(p=0;p<t.length;p++)e=e*a+c[t.charAt(p)];return e}function o(){var t=r(+new Date);return t!==i?(h=0,i=t):t+"."+r(h++)}for(var i,s="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),a=64,c={},h=0,p=0;p<a;p++)c[s[p]]=p;o.encode=r,o.decode=n,t.exports=o},function(t,e,r){(function(e){function n(){}function o(t){i.call(this,t),this.query=this.query||{},a||(e.___eio||(e.___eio=[]),a=e.___eio),this.index=a.length;var r=this;a.push(function(t){r.onData(t)}),this.query.j=this.index,e.document&&e.addEventListener&&e.addEventListener("beforeunload",function(){r.script&&(r.script.onerror=n)},!1)}var i=r(16),s=r(28);t.exports=o;var a,c=/\n/g,h=/\\n/g;s(o,i),o.prototype.supportsBinary=!1,o.prototype.doClose=function(){this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),this.form&&(this.form.parentNode.removeChild(this.form),this.form=null,this.iframe=null),i.prototype.doClose.call(this)},o.prototype.doPoll=function(){var t=this,e=document.createElement("script");this.script&&(this.script.parentNode.removeChild(this.script),this.script=null),e.async=!0,e.src=this.uri(),e.onerror=function(e){t.onError("jsonp poll error",e)};var r=document.getElementsByTagName("script")[0];r?r.parentNode.insertBefore(e,r):(document.head||document.body).appendChild(e),this.script=e;var n="undefined"!=typeof navigator&&/gecko/i.test(navigator.userAgent);n&&setTimeout(function(){var t=document.createElement("iframe");document.body.appendChild(t),document.body.removeChild(t)},100)},o.prototype.doWrite=function(t,e){function r(){n(),e()}function n(){if(o.iframe)try{o.form.removeChild(o.iframe)}catch(t){o.onError("jsonp polling iframe removal error",t)}try{var t='<iframe src="javascript:0" name="'+o.iframeId+'">';i=document.createElement(t)}catch(t){i=document.createElement("iframe"),i.name=o.iframeId,i.src="javascript:0"}i.id=o.iframeId,o.form.appendChild(i),o.iframe=i}var o=this;if(!this.form){var i,s=document.createElement("form"),a=document.createElement("textarea"),p=this.iframeId="eio_iframe_"+this.index;s.className="socketio",s.style.position="absolute",s.style.top="-1000px",s.style.left="-1000px",s.target=p,s.method="POST",s.setAttribute("accept-charset","utf-8"),a.name="d",s.appendChild(a),document.body.appendChild(s),this.form=s,this.area=a}this.form.action=this.uri(),n(),t=t.replace(h,"\\\n"),this.area.value=t.replace(c,"\\n");try{this.form.submit()}catch(t){}this.iframe.attachEvent?this.iframe.onreadystatechange=function(){"complete"===o.iframe.readyState&&r()}:this.iframe.onload=r}}).call(e,function(){return this}())},function(t,e,r){(function(e){function n(t){var e=t&&t.forceBase64;e&&(this.supportsBinary=!1),this.perMessageDeflate=t.perMessageDeflate,this.usingBrowserWebSocket=p&&!t.forceNode,this.protocols=t.protocols,this.usingBrowserWebSocket||(u=o),i.call(this,t)}var o,i=r(17),s=r(18),a=r(27),c=r(28),h=r(29),p=(r(3)("engine.io-client:websocket"),e.WebSocket||e.MozWebSocket);if("undefined"==typeof window)try{o=r(32)}catch(t){}var u=p;u||"undefined"!=typeof window||(u=o),t.exports=n,c(n,i),n.prototype.name="websocket",n.prototype.supportsBinary=!0,n.prototype.doOpen=function(){if(this.check()){var t=this.uri(),e=this.protocols,r={agent:this.agent,perMessageDeflate:this.perMessageDeflate};r.pfx=this.pfx,r.key=this.key,r.passphrase=this.passphrase,r.cert=this.cert,r.ca=this.ca,r.ciphers=this.ciphers,r.rejectUnauthorized=this.rejectUnauthorized,this.extraHeaders&&(r.headers=this.extraHeaders),this.localAddress&&(r.localAddress=this.localAddress);try{this.ws=this.usingBrowserWebSocket?e?new u(t,e):new u(t):new u(t,e,r)}catch(t){return this.emit("error",t)}void 0===this.ws.binaryType&&(this.supportsBinary=!1),this.ws.supports&&this.ws.supports.binary?(this.supportsBinary=!0,this.ws.binaryType="nodebuffer"):this.ws.binaryType="arraybuffer",this.addEventListeners()}},n.prototype.addEventListeners=function(){var t=this;this.ws.onopen=function(){t.onOpen()},this.ws.onclose=function(){t.onClose()},this.ws.onmessage=function(e){t.onData(e.data)},this.ws.onerror=function(e){t.onError("websocket error",e)}},n.prototype.write=function(t){function r(){n.emit("flush"),setTimeout(function(){n.writable=!0,n.emit("drain")},0)}var n=this;this.writable=!1;for(var o=t.length,i=0,a=o;i<a;i++)!function(t){s.encodePacket(t,n.supportsBinary,function(i){if(!n.usingBrowserWebSocket){var s={};if(t.options&&(s.compress=t.options.compress),n.perMessageDeflate){var a="string"==typeof i?e.Buffer.byteLength(i):i.length;a<n.perMessageDeflate.threshold&&(s.compress=!1)}}try{n.usingBrowserWebSocket?n.ws.send(i):n.ws.send(i,s)}catch(t){}--o||r()})}(t[i])},n.prototype.onClose=function(){i.prototype.onClose.call(this)},n.prototype.doClose=function(){"undefined"!=typeof this.ws&&this.ws.close()},n.prototype.uri=function(){var t=this.query||{},e=this.secure?"wss":"ws",r="";this.port&&("wss"===e&&443!==Number(this.port)||"ws"===e&&80!==Number(this.port))&&(r=":"+this.port),this.timestampRequests&&(t[this.timestampParam]=h()),this.supportsBinary||(t.b64=1),t=a.encode(t),t.length&&(t="?"+t);var n=this.hostname.indexOf(":")!==-1;return e+"://"+(n?"["+this.hostname+"]":this.hostname)+r+this.path+t},n.prototype.check=function(){return!(!u||"__initialize"in u&&this.name===n.prototype.name)}}).call(e,function(){return this}())},function(t,e){},function(t,e){var r=[].indexOf;t.exports=function(t,e){if(r)return t.indexOf(e);for(var n=0;n<t.length;++n)if(t[n]===e)return n;return-1}},function(t,e,r){"use strict";function n(t,e,r){this.io=t,this.nsp=e,this.json=this,this.ids=0,this.acks={},this.receiveBuffer=[],this.sendBuffer=[],this.connected=!1,this.disconnected=!0,this.flags={},r&&r.query&&(this.query=r.query),this.io.autoConnect&&this.open()}var o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=r(4),s=r(5),a=r(35),c=r(36),h=r(37),p=(r(3)("socket.io-client:socket"),r(27)),u=r(20);t.exports=e=n;var f={connect:1,connect_error:1,connect_timeout:1,connecting:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1,ping:1,pong:1},l=s.prototype.emit;s(n.prototype),n.prototype.subEvents=function(){if(!this.subs){var t=this.io;this.subs=[c(t,"open",h(this,"onopen")),c(t,"packet",h(this,"onpacket")),c(t,"close",h(this,"onclose"))]}},n.prototype.open=n.prototype.connect=function(){return this.connected?this:(this.subEvents(),this.io.open(),"open"===this.io.readyState&&this.onopen(),this.emit("connecting"),this)},n.prototype.send=function(){var t=a(arguments);return t.unshift("message"),this.emit.apply(this,t),this},n.prototype.emit=function(t){if(f.hasOwnProperty(t))return l.apply(this,arguments),this;var e=a(arguments),r={type:(void 0!==this.flags.binary?this.flags.binary:u(e))?i.BINARY_EVENT:i.EVENT,data:e};return r.options={},r.options.compress=!this.flags||!1!==this.flags.compress,"function"==typeof e[e.length-1]&&(this.acks[this.ids]=e.pop(),r.id=this.ids++),this.connected?this.packet(r):this.sendBuffer.push(r),this.flags={},this},n.prototype.packet=function(t){t.nsp=this.nsp,this.io.packet(t)},n.prototype.onopen=function(){if("/"!==this.nsp)if(this.query){var t="object"===o(this.query)?p.encode(this.query):this.query;this.packet({type:i.CONNECT,query:t})}else this.packet({type:i.CONNECT})},n.prototype.onclose=function(t){this.connected=!1,this.disconnected=!0,delete this.id,this.emit("disconnect",t)},n.prototype.onpacket=function(t){var e=t.nsp===this.nsp,r=t.type===i.ERROR&&"/"===t.nsp;if(e||r)switch(t.type){case i.CONNECT:this.onconnect();break;case i.EVENT:this.onevent(t);break;case i.BINARY_EVENT:this.onevent(t);break;case i.ACK:this.onack(t);break;case i.BINARY_ACK:this.onack(t);break;case i.DISCONNECT:this.ondisconnect();break;case i.ERROR:this.emit("error",t.data)}},n.prototype.onevent=function(t){var e=t.data||[];null!=t.id&&e.push(this.ack(t.id)),this.connected?l.apply(this,e):this.receiveBuffer.push(e)},n.prototype.ack=function(t){var e=this,r=!1;return function(){if(!r){r=!0;var n=a(arguments);e.packet({type:u(n)?i.BINARY_ACK:i.ACK,id:t,data:n})}}},n.prototype.onack=function(t){var e=this.acks[t.id];"function"==typeof e&&(e.apply(this,t.data),delete this.acks[t.id])},n.prototype.onconnect=function(){this.connected=!0,this.disconnected=!1,this.emit("connect"),this.emitBuffered()},n.prototype.emitBuffered=function(){var t;for(t=0;t<this.receiveBuffer.length;t++)l.apply(this,this.receiveBuffer[t]);for(this.receiveBuffer=[],t=0;t<this.sendBuffer.length;t++)this.packet(this.sendBuffer[t]);this.sendBuffer=[]},n.prototype.ondisconnect=function(){this.destroy(),this.onclose("io server disconnect")},n.prototype.destroy=function(){if(this.subs){for(var t=0;t<this.subs.length;t++)this.subs[t].destroy();this.subs=null}this.io.destroy(this)},n.prototype.close=n.prototype.disconnect=function(){return this.connected&&this.packet({type:i.DISCONNECT}),this.destroy(),this.connected&&this.onclose("io client disconnect"),this},n.prototype.compress=function(t){return this.flags.compress=t,this},n.prototype.binary=function(t){return this.flags.binary=t,this}},function(t,e){function r(t,e){var r=[];e=e||0;for(var n=e||0;n<t.length;n++)r[n-e]=t[n];return r}t.exports=r},function(t,e){"use strict";function r(t,e,r){return t.on(e,r),{destroy:function(){t.removeListener(e,r)}}}t.exports=r},function(t,e){var r=[].slice;t.exports=function(t,e){if("string"==typeof e&&(e=t[e]),"function"!=typeof e)throw new Error("bind() requires a function");var n=r.call(arguments,2);return function(){return e.apply(t,n.concat(r.call(arguments)))}}},function(t,e){function r(t){t=t||{},this.ms=t.min||100,this.max=t.max||1e4,this.factor=t.factor||2,this.jitter=t.jitter>0&&t.jitter<=1?t.jitter:0,this.attempts=0}t.exports=r,r.prototype.duration=function(){var t=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var e=Math.random(),r=Math.floor(e*this.jitter*t);t=0==(1&Math.floor(10*e))?t-r:t+r}return 0|Math.min(t,this.max)},r.prototype.reset=function(){this.attempts=0},r.prototype.setMin=function(t){this.ms=t},r.prototype.setMax=function(t){this.max=t},r.prototype.setJitter=function(t){this.jitter=t}}])});
//# sourceMappingURL=socket.io.slim.js.map;
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define('adapter',[],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.adapter = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */


var SDPUtils = require('sdp');

function fixStatsType(stat) {
  return {
    inboundrtp: 'inbound-rtp',
    outboundrtp: 'outbound-rtp',
    candidatepair: 'candidate-pair',
    localcandidate: 'local-candidate',
    remotecandidate: 'remote-candidate'
  }[stat.type] || stat.type;
}

function writeMediaSection(transceiver, caps, type, stream, dtlsRole) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : dtlsRole || 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    var trackId = transceiver.rtpSender._initialTrackId ||
        transceiver.rtpSender.track.id;
    transceiver.rtpSender._initialTrackId = trackId;
    // spec.
    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +
        trackId + '\r\n';
    sdp += 'a=' + msid;
    // for Chrome. Legacy should no longer be required.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;

    // RTX
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
}

// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
function filterIceServers(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function(server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        console.warn('RTCIceServer.url is deprecated! Use urls instead.');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function(url) {
        var validTurn = url.indexOf('turn:') === 0 &&
            url.indexOf('transport=udp') !== -1 &&
            url.indexOf('turn:[') === -1 &&
            !hasTurn;

        if (validTurn) {
          hasTurn = true;
          return true;
        }
        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
            url.indexOf('?transport=udp') === -1;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
  });
}

// Determines the intersection of local and remote capabilities.
function getCommonCapabilities(localCapabilities, remoteCapabilities) {
  var commonCapabilities = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: []
  };

  var findCodecByPayloadType = function(pt, codecs) {
    pt = parseInt(pt, 10);
    for (var i = 0; i < codecs.length; i++) {
      if (codecs[i].payloadType === pt ||
          codecs[i].preferredPayloadType === pt) {
        return codecs[i];
      }
    }
  };

  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {
    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);
    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);
    return lCodec && rCodec &&
        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();
  };

  localCapabilities.codecs.forEach(function(lCodec) {
    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {
      var rCodec = remoteCapabilities.codecs[i];
      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
          lCodec.clockRate === rCodec.clockRate) {
        if (lCodec.name.toLowerCase() === 'rtx' &&
            lCodec.parameters && rCodec.parameters.apt) {
          // for RTX we need to find the local rtx that has a apt
          // which points to the same local codec as the remote one.
          if (!rtxCapabilityMatches(lCodec, rCodec,
              localCapabilities.codecs, remoteCapabilities.codecs)) {
            continue;
          }
        }
        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy
        // number of channels is the highest common number of channels
        rCodec.numChannels = Math.min(lCodec.numChannels,
            rCodec.numChannels);
        // push rCodec so we reply with offerer payload type
        commonCapabilities.codecs.push(rCodec);

        // determine common feedback mechanisms
        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {
          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {
            if (lCodec.rtcpFeedback[j].type === fb.type &&
                lCodec.rtcpFeedback[j].parameter === fb.parameter) {
              return true;
            }
          }
          return false;
        });
        // FIXME: also need to determine .parameters
        //  see https://github.com/openpeer/ortc/issues/569
        break;
      }
    }
  });

  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {
    for (var i = 0; i < remoteCapabilities.headerExtensions.length;
         i++) {
      var rHeaderExtension = remoteCapabilities.headerExtensions[i];
      if (lHeaderExtension.uri === rHeaderExtension.uri) {
        commonCapabilities.headerExtensions.push(rHeaderExtension);
        break;
      }
    }
  });

  // FIXME: fecMechanisms
  return commonCapabilities;
}

// is action=setLocalDescription with type allowed in signalingState
function isActionAllowedInSignalingState(action, type, signalingState) {
  return {
    offer: {
      setLocalDescription: ['stable', 'have-local-offer'],
      setRemoteDescription: ['stable', 'have-remote-offer']
    },
    answer: {
      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],
      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']
    }
  }[type][action].indexOf(signalingState) !== -1;
}

function maybeAddCandidate(iceTransport, candidate) {
  // Edge's internal representation adds some fields therefore
  // not all fieldѕ are taken into account.
  var alreadyAdded = iceTransport.getRemoteCandidates()
      .find(function(remoteCandidate) {
        return candidate.foundation === remoteCandidate.foundation &&
            candidate.ip === remoteCandidate.ip &&
            candidate.port === remoteCandidate.port &&
            candidate.priority === remoteCandidate.priority &&
            candidate.protocol === remoteCandidate.protocol &&
            candidate.type === remoteCandidate.type;
      });
  if (!alreadyAdded) {
    iceTransport.addRemoteCandidate(candidate);
  }
  return !alreadyAdded;
}


function makeError(name, description) {
  var e = new Error(description);
  e.name = name;
  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names
  e.code = {
    NotSupportedError: 9,
    InvalidStateError: 11,
    InvalidAccessError: 15,
    TypeError: undefined,
    OperationError: undefined
  }[name];
  return e;
}

module.exports = function(window, edgeVersion) {
  // https://w3c.github.io/mediacapture-main/#mediastream
  // Helper function to add the track to the stream and
  // dispatch the event ourselves.
  function addTrackToStreamAndFireEvent(track, stream) {
    stream.addTrack(track);
    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',
        {track: track}));
  }

  function removeTrackFromStreamAndFireEvent(track, stream) {
    stream.removeTrack(track);
    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',
        {track: track}));
  }

  function fireAddTrack(pc, track, receiver, streams) {
    var trackEvent = new Event('track');
    trackEvent.track = track;
    trackEvent.receiver = receiver;
    trackEvent.transceiver = {receiver: receiver};
    trackEvent.streams = streams;
    window.setTimeout(function() {
      pc._dispatchEvent('track', trackEvent);
    });
  }

  var RTCPeerConnection = function(config) {
    var pc = this;

    var _eventTarget = document.createDocumentFragment();
    ['addEventListener', 'removeEventListener', 'dispatchEvent']
        .forEach(function(method) {
          pc[method] = _eventTarget[method].bind(_eventTarget);
        });

    this.canTrickleIceCandidates = null;

    this.needNegotiation = false;

    this.localStreams = [];
    this.remoteStreams = [];

    this._localDescription = null;
    this._remoteDescription = null;

    this.signalingState = 'stable';
    this.iceConnectionState = 'new';
    this.connectionState = 'new';
    this.iceGatheringState = 'new';

    config = JSON.parse(JSON.stringify(config || {}));

    this.usingBundle = config.bundlePolicy === 'max-bundle';
    if (config.rtcpMuxPolicy === 'negotiate') {
      throw(makeError('NotSupportedError',
          'rtcpMuxPolicy \'negotiate\' is not supported'));
    } else if (!config.rtcpMuxPolicy) {
      config.rtcpMuxPolicy = 'require';
    }

    switch (config.iceTransportPolicy) {
      case 'all':
      case 'relay':
        break;
      default:
        config.iceTransportPolicy = 'all';
        break;
    }

    switch (config.bundlePolicy) {
      case 'balanced':
      case 'max-compat':
      case 'max-bundle':
        break;
      default:
        config.bundlePolicy = 'balanced';
        break;
    }

    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);

    this._iceGatherers = [];
    if (config.iceCandidatePoolSize) {
      for (var i = config.iceCandidatePoolSize; i > 0; i--) {
        this._iceGatherers.push(new window.RTCIceGatherer({
          iceServers: config.iceServers,
          gatherPolicy: config.iceTransportPolicy
        }));
      }
    } else {
      config.iceCandidatePoolSize = 0;
    }

    this._config = config;

    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...
    // everything that is needed to describe a SDP m-line.
    this.transceivers = [];

    this._sdpSessionId = SDPUtils.generateSessionId();
    this._sdpSessionVersion = 0;

    this._dtlsRole = undefined; // role for a=setup to use in answers.

    this._isClosed = false;
  };

  Object.defineProperty(RTCPeerConnection.prototype, 'localDescription', {
    configurable: true,
    get: function() {
      return this._localDescription;
    }
  });
  Object.defineProperty(RTCPeerConnection.prototype, 'remoteDescription', {
    configurable: true,
    get: function() {
      return this._remoteDescription;
    }
  });

  // set up event handlers on prototype
  RTCPeerConnection.prototype.onicecandidate = null;
  RTCPeerConnection.prototype.onaddstream = null;
  RTCPeerConnection.prototype.ontrack = null;
  RTCPeerConnection.prototype.onremovestream = null;
  RTCPeerConnection.prototype.onsignalingstatechange = null;
  RTCPeerConnection.prototype.oniceconnectionstatechange = null;
  RTCPeerConnection.prototype.onconnectionstatechange = null;
  RTCPeerConnection.prototype.onicegatheringstatechange = null;
  RTCPeerConnection.prototype.onnegotiationneeded = null;
  RTCPeerConnection.prototype.ondatachannel = null;

  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {
    if (this._isClosed) {
      return;
    }
    this.dispatchEvent(event);
    if (typeof this['on' + name] === 'function') {
      this['on' + name](event);
    }
  };

  RTCPeerConnection.prototype._emitGatheringStateChange = function() {
    var event = new Event('icegatheringstatechange');
    this._dispatchEvent('icegatheringstatechange', event);
  };

  RTCPeerConnection.prototype.getConfiguration = function() {
    return this._config;
  };

  RTCPeerConnection.prototype.getLocalStreams = function() {
    return this.localStreams;
  };

  RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this.remoteStreams;
  };

  // internal helper to create a transceiver object.
  // (which is not yet the same as the WebRTC 1.0 transceiver)
  RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {
    var hasBundleTransport = this.transceivers.length > 0;
    var transceiver = {
      track: null,
      iceGatherer: null,
      iceTransport: null,
      dtlsTransport: null,
      localCapabilities: null,
      remoteCapabilities: null,
      rtpSender: null,
      rtpReceiver: null,
      kind: kind,
      mid: null,
      sendEncodingParameters: null,
      recvEncodingParameters: null,
      stream: null,
      associatedRemoteMediaStreams: [],
      wantReceive: true
    };
    if (this.usingBundle && hasBundleTransport) {
      transceiver.iceTransport = this.transceivers[0].iceTransport;
      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
    } else {
      var transports = this._createIceAndDtlsTransports();
      transceiver.iceTransport = transports.iceTransport;
      transceiver.dtlsTransport = transports.dtlsTransport;
    }
    if (!doNotAdd) {
      this.transceivers.push(transceiver);
    }
    return transceiver;
  };

  RTCPeerConnection.prototype.addTrack = function(track, stream) {
    if (this._isClosed) {
      throw makeError('InvalidStateError',
          'Attempted to call addTrack on a closed peerconnection.');
    }

    var alreadyExists = this.transceivers.find(function(s) {
      return s.track === track;
    });

    if (alreadyExists) {
      throw makeError('InvalidAccessError', 'Track already exists.');
    }

    var transceiver;
    for (var i = 0; i < this.transceivers.length; i++) {
      if (!this.transceivers[i].track &&
          this.transceivers[i].kind === track.kind) {
        transceiver = this.transceivers[i];
      }
    }
    if (!transceiver) {
      transceiver = this._createTransceiver(track.kind);
    }

    this._maybeFireNegotiationNeeded();

    if (this.localStreams.indexOf(stream) === -1) {
      this.localStreams.push(stream);
    }

    transceiver.track = track;
    transceiver.stream = stream;
    transceiver.rtpSender = new window.RTCRtpSender(track,
        transceiver.dtlsTransport);
    return transceiver.rtpSender;
  };

  RTCPeerConnection.prototype.addStream = function(stream) {
    var pc = this;
    if (edgeVersion >= 15025) {
      stream.getTracks().forEach(function(track) {
        pc.addTrack(track, stream);
      });
    } else {
      // Clone is necessary for local demos mostly, attaching directly
      // to two different senders does not work (build 10547).
      // Fixed in 15025 (or earlier)
      var clonedStream = stream.clone();
      stream.getTracks().forEach(function(track, idx) {
        var clonedTrack = clonedStream.getTracks()[idx];
        track.addEventListener('enabled', function(event) {
          clonedTrack.enabled = event.enabled;
        });
      });
      clonedStream.getTracks().forEach(function(track) {
        pc.addTrack(track, clonedStream);
      });
    }
  };

  RTCPeerConnection.prototype.removeTrack = function(sender) {
    if (this._isClosed) {
      throw makeError('InvalidStateError',
          'Attempted to call removeTrack on a closed peerconnection.');
    }

    if (!(sender instanceof window.RTCRtpSender)) {
      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +
          'does not implement interface RTCRtpSender.');
    }

    var transceiver = this.transceivers.find(function(t) {
      return t.rtpSender === sender;
    });

    if (!transceiver) {
      throw makeError('InvalidAccessError',
          'Sender was not created by this connection.');
    }
    var stream = transceiver.stream;

    transceiver.rtpSender.stop();
    transceiver.rtpSender = null;
    transceiver.track = null;
    transceiver.stream = null;

    // remove the stream from the set of local streams
    var localStreams = this.transceivers.map(function(t) {
      return t.stream;
    });
    if (localStreams.indexOf(stream) === -1 &&
        this.localStreams.indexOf(stream) > -1) {
      this.localStreams.splice(this.localStreams.indexOf(stream), 1);
    }

    this._maybeFireNegotiationNeeded();
  };

  RTCPeerConnection.prototype.removeStream = function(stream) {
    var pc = this;
    stream.getTracks().forEach(function(track) {
      var sender = pc.getSenders().find(function(s) {
        return s.track === track;
      });
      if (sender) {
        pc.removeTrack(sender);
      }
    });
  };

  RTCPeerConnection.prototype.getSenders = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpSender;
    })
    .map(function(transceiver) {
      return transceiver.rtpSender;
    });
  };

  RTCPeerConnection.prototype.getReceivers = function() {
    return this.transceivers.filter(function(transceiver) {
      return !!transceiver.rtpReceiver;
    })
    .map(function(transceiver) {
      return transceiver.rtpReceiver;
    });
  };


  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,
      usingBundle) {
    var pc = this;
    if (usingBundle && sdpMLineIndex > 0) {
      return this.transceivers[0].iceGatherer;
    } else if (this._iceGatherers.length) {
      return this._iceGatherers.shift();
    }
    var iceGatherer = new window.RTCIceGatherer({
      iceServers: this._config.iceServers,
      gatherPolicy: this._config.iceTransportPolicy
    });
    Object.defineProperty(iceGatherer, 'state',
        {value: 'new', writable: true}
    );

    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {
      var end = !event.candidate || Object.keys(event.candidate).length === 0;
      // polyfill since RTCIceGatherer.state is not implemented in
      // Edge 10547 yet.
      iceGatherer.state = end ? 'completed' : 'gathering';
      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {
        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);
      }
    };
    iceGatherer.addEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    return iceGatherer;
  };

  // start gathering from an RTCIceGatherer.
  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {
    var pc = this;
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer.onlocalcandidate) {
      return;
    }
    var bufferedCandidateEvents =
      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;
    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
    iceGatherer.removeEventListener('localcandidate',
      this.transceivers[sdpMLineIndex].bufferCandidates);
    iceGatherer.onlocalcandidate = function(evt) {
      if (pc.usingBundle && sdpMLineIndex > 0) {
        // if we know that we use bundle we can drop candidates with
        // ѕdpMLineIndex > 0. If we don't do this then our state gets
        // confused since we dispose the extra ice gatherer.
        return;
      }
      var event = new Event('icecandidate');
      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};

      var cand = evt.candidate;
      // Edge emits an empty object for RTCIceCandidateComplete‥
      var end = !cand || Object.keys(cand).length === 0;
      if (end) {
        // polyfill since RTCIceGatherer.state is not implemented in
        // Edge 10547 yet.
        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {
          iceGatherer.state = 'completed';
        }
      } else {
        if (iceGatherer.state === 'new') {
          iceGatherer.state = 'gathering';
        }
        // RTCIceCandidate doesn't have a component, needs to be added
        cand.component = 1;
        // also the usernameFragment. TODO: update SDP to take both variants.
        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;

        var serializedCandidate = SDPUtils.writeCandidate(cand);
        event.candidate = Object.assign(event.candidate,
            SDPUtils.parseCandidate(serializedCandidate));

        event.candidate.candidate = serializedCandidate;
        event.candidate.toJSON = function() {
          return {
            candidate: event.candidate.candidate,
            sdpMid: event.candidate.sdpMid,
            sdpMLineIndex: event.candidate.sdpMLineIndex,
            usernameFragment: event.candidate.usernameFragment
          };
        };
      }

      // update local description.
      var sections = SDPUtils.getMediaSections(pc._localDescription.sdp);
      if (!end) {
        sections[event.candidate.sdpMLineIndex] +=
            'a=' + event.candidate.candidate + '\r\n';
      } else {
        sections[event.candidate.sdpMLineIndex] +=
            'a=end-of-candidates\r\n';
      }
      pc._localDescription.sdp =
          SDPUtils.getDescription(pc._localDescription.sdp) +
          sections.join('');
      var complete = pc.transceivers.every(function(transceiver) {
        return transceiver.iceGatherer &&
            transceiver.iceGatherer.state === 'completed';
      });

      if (pc.iceGatheringState !== 'gathering') {
        pc.iceGatheringState = 'gathering';
        pc._emitGatheringStateChange();
      }

      // Emit candidate. Also emit null candidate when all gatherers are
      // complete.
      if (!end) {
        pc._dispatchEvent('icecandidate', event);
      }
      if (complete) {
        pc._dispatchEvent('icecandidate', new Event('icecandidate'));
        pc.iceGatheringState = 'complete';
        pc._emitGatheringStateChange();
      }
    };

    // emit already gathered candidates.
    window.setTimeout(function() {
      bufferedCandidateEvents.forEach(function(e) {
        iceGatherer.onlocalcandidate(e);
      });
    }, 0);
  };

  // Create ICE transport and DTLS transport.
  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {
    var pc = this;
    var iceTransport = new window.RTCIceTransport(null);
    iceTransport.onicestatechange = function() {
      pc._updateIceConnectionState();
      pc._updateConnectionState();
    };

    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);
    dtlsTransport.ondtlsstatechange = function() {
      pc._updateConnectionState();
    };
    dtlsTransport.onerror = function() {
      // onerror does not set state to failed by itself.
      Object.defineProperty(dtlsTransport, 'state',
          {value: 'failed', writable: true});
      pc._updateConnectionState();
    };

    return {
      iceTransport: iceTransport,
      dtlsTransport: dtlsTransport
    };
  };

  // Destroy ICE gatherer, ICE transport and DTLS transport.
  // Without triggering the callbacks.
  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(
      sdpMLineIndex) {
    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;
    if (iceGatherer) {
      delete iceGatherer.onlocalcandidate;
      delete this.transceivers[sdpMLineIndex].iceGatherer;
    }
    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;
    if (iceTransport) {
      delete iceTransport.onicestatechange;
      delete this.transceivers[sdpMLineIndex].iceTransport;
    }
    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;
    if (dtlsTransport) {
      delete dtlsTransport.ondtlsstatechange;
      delete dtlsTransport.onerror;
      delete this.transceivers[sdpMLineIndex].dtlsTransport;
    }
  };

  // Start the RTP Sender and Receiver for a transceiver.
  RTCPeerConnection.prototype._transceive = function(transceiver,
      send, recv) {
    var params = getCommonCapabilities(transceiver.localCapabilities,
        transceiver.remoteCapabilities);
    if (send && transceiver.rtpSender) {
      params.encodings = transceiver.sendEncodingParameters;
      params.rtcp = {
        cname: SDPUtils.localCName,
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.recvEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
      }
      transceiver.rtpSender.send(params);
    }
    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
      // remove RTX field in Edge 14942
      if (transceiver.kind === 'video'
          && transceiver.recvEncodingParameters
          && edgeVersion < 15019) {
        transceiver.recvEncodingParameters.forEach(function(p) {
          delete p.rtx;
        });
      }
      if (transceiver.recvEncodingParameters.length) {
        params.encodings = transceiver.recvEncodingParameters;
      } else {
        params.encodings = [{}];
      }
      params.rtcp = {
        compound: transceiver.rtcpParameters.compound
      };
      if (transceiver.rtcpParameters.cname) {
        params.rtcp.cname = transceiver.rtcpParameters.cname;
      }
      if (transceiver.sendEncodingParameters.length) {
        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
      }
      transceiver.rtpReceiver.receive(params);
    }
  };

  RTCPeerConnection.prototype.setLocalDescription = function(description) {
    var pc = this;

    // Note: pranswer is not supported.
    if (['offer', 'answer'].indexOf(description.type) === -1) {
      return Promise.reject(makeError('TypeError',
          'Unsupported type "' + description.type + '"'));
    }

    if (!isActionAllowedInSignalingState('setLocalDescription',
        description.type, pc.signalingState) || pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not set local ' + description.type +
          ' in state ' + pc.signalingState));
    }

    var sections;
    var sessionpart;
    if (description.type === 'offer') {
      // VERY limited support for SDP munging. Limited to:
      // * changing the order of codecs
      sections = SDPUtils.splitSections(description.sdp);
      sessionpart = sections.shift();
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var caps = SDPUtils.parseRtpParameters(mediaSection);
        pc.transceivers[sdpMLineIndex].localCapabilities = caps;
      });

      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
        pc._gather(transceiver.mid, sdpMLineIndex);
      });
    } else if (description.type === 'answer') {
      sections = SDPUtils.splitSections(pc._remoteDescription.sdp);
      sessionpart = sections.shift();
      var isIceLite = SDPUtils.matchPrefix(sessionpart,
          'a=ice-lite').length > 0;
      sections.forEach(function(mediaSection, sdpMLineIndex) {
        var transceiver = pc.transceivers[sdpMLineIndex];
        var iceGatherer = transceiver.iceGatherer;
        var iceTransport = transceiver.iceTransport;
        var dtlsTransport = transceiver.dtlsTransport;
        var localCapabilities = transceiver.localCapabilities;
        var remoteCapabilities = transceiver.remoteCapabilities;

        // treat bundle-only as not-rejected.
        var rejected = SDPUtils.isRejected(mediaSection) &&
            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;

        if (!rejected && !transceiver.rejected) {
          var remoteIceParameters = SDPUtils.getIceParameters(
              mediaSection, sessionpart);
          var remoteDtlsParameters = SDPUtils.getDtlsParameters(
              mediaSection, sessionpart);
          if (isIceLite) {
            remoteDtlsParameters.role = 'server';
          }

          if (!pc.usingBundle || sdpMLineIndex === 0) {
            pc._gather(transceiver.mid, sdpMLineIndex);
            if (iceTransport.state === 'new') {
              iceTransport.start(iceGatherer, remoteIceParameters,
                  isIceLite ? 'controlling' : 'controlled');
            }
            if (dtlsTransport.state === 'new') {
              dtlsTransport.start(remoteDtlsParameters);
            }
          }

          // Calculate intersection of capabilities.
          var params = getCommonCapabilities(localCapabilities,
              remoteCapabilities);

          // Start the RTCRtpSender. The RTCRtpReceiver for this
          // transceiver has already been started in setRemoteDescription.
          pc._transceive(transceiver,
              params.codecs.length > 0,
              false);
        }
      });
    }

    pc._localDescription = {
      type: description.type,
      sdp: description.sdp
    };
    if (description.type === 'offer') {
      pc._updateSignalingState('have-local-offer');
    } else {
      pc._updateSignalingState('stable');
    }

    return Promise.resolve();
  };

  RTCPeerConnection.prototype.setRemoteDescription = function(description) {
    var pc = this;

    // Note: pranswer is not supported.
    if (['offer', 'answer'].indexOf(description.type) === -1) {
      return Promise.reject(makeError('TypeError',
          'Unsupported type "' + description.type + '"'));
    }

    if (!isActionAllowedInSignalingState('setRemoteDescription',
        description.type, pc.signalingState) || pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not set remote ' + description.type +
          ' in state ' + pc.signalingState));
    }

    var streams = {};
    pc.remoteStreams.forEach(function(stream) {
      streams[stream.id] = stream;
    });
    var receiverList = [];
    var sections = SDPUtils.splitSections(description.sdp);
    var sessionpart = sections.shift();
    var isIceLite = SDPUtils.matchPrefix(sessionpart,
        'a=ice-lite').length > 0;
    var usingBundle = SDPUtils.matchPrefix(sessionpart,
        'a=group:BUNDLE ').length > 0;
    pc.usingBundle = usingBundle;
    var iceOptions = SDPUtils.matchPrefix(sessionpart,
        'a=ice-options:')[0];
    if (iceOptions) {
      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')
          .indexOf('trickle') >= 0;
    } else {
      pc.canTrickleIceCandidates = false;
    }

    sections.forEach(function(mediaSection, sdpMLineIndex) {
      var lines = SDPUtils.splitLines(mediaSection);
      var kind = SDPUtils.getKind(mediaSection);
      // treat bundle-only as not-rejected.
      var rejected = SDPUtils.isRejected(mediaSection) &&
          SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;
      var protocol = lines[0].substr(2).split(' ')[2];

      var direction = SDPUtils.getDirection(mediaSection, sessionpart);
      var remoteMsid = SDPUtils.parseMsid(mediaSection);

      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();

      // Reject datachannels which are not implemented yet.
      if (rejected || (kind === 'application' && (protocol === 'DTLS/SCTP' ||
          protocol === 'UDP/DTLS/SCTP'))) {
        // TODO: this is dangerous in the case where a non-rejected m-line
        //     becomes rejected.
        pc.transceivers[sdpMLineIndex] = {
          mid: mid,
          kind: kind,
          protocol: protocol,
          rejected: true
        };
        return;
      }

      if (!rejected && pc.transceivers[sdpMLineIndex] &&
          pc.transceivers[sdpMLineIndex].rejected) {
        // recycle a rejected transceiver.
        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);
      }

      var transceiver;
      var iceGatherer;
      var iceTransport;
      var dtlsTransport;
      var rtpReceiver;
      var sendEncodingParameters;
      var recvEncodingParameters;
      var localCapabilities;

      var track;
      // FIXME: ensure the mediaSection has rtcp-mux set.
      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);
      var remoteIceParameters;
      var remoteDtlsParameters;
      if (!rejected) {
        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,
            sessionpart);
        remoteDtlsParameters.role = 'client';
      }
      recvEncodingParameters =
          SDPUtils.parseRtpEncodingParameters(mediaSection);

      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);

      var isComplete = SDPUtils.matchPrefix(mediaSection,
          'a=end-of-candidates', sessionpart).length > 0;
      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
          .map(function(cand) {
            return SDPUtils.parseCandidate(cand);
          })
          .filter(function(cand) {
            return cand.component === 1;
          });

      // Check if we can use BUNDLE and dispose transports.
      if ((description.type === 'offer' || description.type === 'answer') &&
          !rejected && usingBundle && sdpMLineIndex > 0 &&
          pc.transceivers[sdpMLineIndex]) {
        pc._disposeIceAndDtlsTransports(sdpMLineIndex);
        pc.transceivers[sdpMLineIndex].iceGatherer =
            pc.transceivers[0].iceGatherer;
        pc.transceivers[sdpMLineIndex].iceTransport =
            pc.transceivers[0].iceTransport;
        pc.transceivers[sdpMLineIndex].dtlsTransport =
            pc.transceivers[0].dtlsTransport;
        if (pc.transceivers[sdpMLineIndex].rtpSender) {
          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(
              pc.transceivers[0].dtlsTransport);
        }
        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
              pc.transceivers[0].dtlsTransport);
        }
      }
      if (description.type === 'offer' && !rejected) {
        transceiver = pc.transceivers[sdpMLineIndex] ||
            pc._createTransceiver(kind);
        transceiver.mid = mid;

        if (!transceiver.iceGatherer) {
          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
              usingBundle);
        }

        if (cands.length && transceiver.iceTransport.state === 'new') {
          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
            transceiver.iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);

        // filter RTX until additional stuff needed for RTX is implemented
        // in adapter.js
        if (edgeVersion < 15019) {
          localCapabilities.codecs = localCapabilities.codecs.filter(
              function(codec) {
                return codec.name !== 'rtx';
              });
        }

        sendEncodingParameters = transceiver.sendEncodingParameters || [{
          ssrc: (2 * sdpMLineIndex + 2) * 1001
        }];

        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
        var isNewTrack = false;
        if (direction === 'sendrecv' || direction === 'sendonly') {
          isNewTrack = !transceiver.rtpReceiver;
          rtpReceiver = transceiver.rtpReceiver ||
              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);

          if (isNewTrack) {
            var stream;
            track = rtpReceiver.track;
            // FIXME: does not work with Plan B.
            if (remoteMsid && remoteMsid.stream === '-') {
              // no-op. a stream id of '-' means: no associated stream.
            } else if (remoteMsid) {
              if (!streams[remoteMsid.stream]) {
                streams[remoteMsid.stream] = new window.MediaStream();
                Object.defineProperty(streams[remoteMsid.stream], 'id', {
                  get: function() {
                    return remoteMsid.stream;
                  }
                });
              }
              Object.defineProperty(track, 'id', {
                get: function() {
                  return remoteMsid.track;
                }
              });
              stream = streams[remoteMsid.stream];
            } else {
              if (!streams.default) {
                streams.default = new window.MediaStream();
              }
              stream = streams.default;
            }
            if (stream) {
              addTrackToStreamAndFireEvent(track, stream);
              transceiver.associatedRemoteMediaStreams.push(stream);
            }
            receiverList.push([track, rtpReceiver, stream]);
          }
        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {
          transceiver.associatedRemoteMediaStreams.forEach(function(s) {
            var nativeTrack = s.getTracks().find(function(t) {
              return t.id === transceiver.rtpReceiver.track.id;
            });
            if (nativeTrack) {
              removeTrackFromStreamAndFireEvent(nativeTrack, s);
            }
          });
          transceiver.associatedRemoteMediaStreams = [];
        }

        transceiver.localCapabilities = localCapabilities;
        transceiver.remoteCapabilities = remoteCapabilities;
        transceiver.rtpReceiver = rtpReceiver;
        transceiver.rtcpParameters = rtcpParameters;
        transceiver.sendEncodingParameters = sendEncodingParameters;
        transceiver.recvEncodingParameters = recvEncodingParameters;

        // Start the RTCRtpReceiver now. The RTPSender is started in
        // setLocalDescription.
        pc._transceive(pc.transceivers[sdpMLineIndex],
            false,
            isNewTrack);
      } else if (description.type === 'answer' && !rejected) {
        transceiver = pc.transceivers[sdpMLineIndex];
        iceGatherer = transceiver.iceGatherer;
        iceTransport = transceiver.iceTransport;
        dtlsTransport = transceiver.dtlsTransport;
        rtpReceiver = transceiver.rtpReceiver;
        sendEncodingParameters = transceiver.sendEncodingParameters;
        localCapabilities = transceiver.localCapabilities;

        pc.transceivers[sdpMLineIndex].recvEncodingParameters =
            recvEncodingParameters;
        pc.transceivers[sdpMLineIndex].remoteCapabilities =
            remoteCapabilities;
        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;

        if (cands.length && iceTransport.state === 'new') {
          if ((isIceLite || isComplete) &&
              (!usingBundle || sdpMLineIndex === 0)) {
            iceTransport.setRemoteCandidates(cands);
          } else {
            cands.forEach(function(candidate) {
              maybeAddCandidate(transceiver.iceTransport, candidate);
            });
          }
        }

        if (!usingBundle || sdpMLineIndex === 0) {
          if (iceTransport.state === 'new') {
            iceTransport.start(iceGatherer, remoteIceParameters,
                'controlling');
          }
          if (dtlsTransport.state === 'new') {
            dtlsTransport.start(remoteDtlsParameters);
          }
        }

        pc._transceive(transceiver,
            direction === 'sendrecv' || direction === 'recvonly',
            direction === 'sendrecv' || direction === 'sendonly');

        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams
        if (rtpReceiver &&
            (direction === 'sendrecv' || direction === 'sendonly')) {
          track = rtpReceiver.track;
          if (remoteMsid) {
            if (!streams[remoteMsid.stream]) {
              streams[remoteMsid.stream] = new window.MediaStream();
            }
            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);
            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);
          } else {
            if (!streams.default) {
              streams.default = new window.MediaStream();
            }
            addTrackToStreamAndFireEvent(track, streams.default);
            receiverList.push([track, rtpReceiver, streams.default]);
          }
        } else {
          // FIXME: actually the receiver should be created later.
          delete transceiver.rtpReceiver;
        }
      }
    });

    if (pc._dtlsRole === undefined) {
      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';
    }

    pc._remoteDescription = {
      type: description.type,
      sdp: description.sdp
    };
    if (description.type === 'offer') {
      pc._updateSignalingState('have-remote-offer');
    } else {
      pc._updateSignalingState('stable');
    }
    Object.keys(streams).forEach(function(sid) {
      var stream = streams[sid];
      if (stream.getTracks().length) {
        if (pc.remoteStreams.indexOf(stream) === -1) {
          pc.remoteStreams.push(stream);
          var event = new Event('addstream');
          event.stream = stream;
          window.setTimeout(function() {
            pc._dispatchEvent('addstream', event);
          });
        }

        receiverList.forEach(function(item) {
          var track = item[0];
          var receiver = item[1];
          if (stream.id !== item[2].id) {
            return;
          }
          fireAddTrack(pc, track, receiver, [stream]);
        });
      }
    });
    receiverList.forEach(function(item) {
      if (item[2]) {
        return;
      }
      fireAddTrack(pc, item[0], item[1], []);
    });

    // check whether addIceCandidate({}) was called within four seconds after
    // setRemoteDescription.
    window.setTimeout(function() {
      if (!(pc && pc.transceivers)) {
        return;
      }
      pc.transceivers.forEach(function(transceiver) {
        if (transceiver.iceTransport &&
            transceiver.iceTransport.state === 'new' &&
            transceiver.iceTransport.getRemoteCandidates().length > 0) {
              console.warn('Timeout for addRemoteCandidate. Consider sending ' +
              'an end-of-candidates notification');
          transceiver.iceTransport.addRemoteCandidate({});
        }
      });
    }, 4000);

    return Promise.resolve();
  };

  RTCPeerConnection.prototype.close = function() {
    this.transceivers.forEach(function(transceiver) {
      /* not yet
      if (transceiver.iceGatherer) {
        transceiver.iceGatherer.close();
      }
      */
      if (transceiver.iceTransport) {
        transceiver.iceTransport.stop();
      }
      if (transceiver.dtlsTransport) {
        transceiver.dtlsTransport.stop();
      }
      if (transceiver.rtpSender) {
        transceiver.rtpSender.stop();
      }
      if (transceiver.rtpReceiver) {
        transceiver.rtpReceiver.stop();
      }
    });
    // FIXME: clean up tracks, local streams, remote streams, etc
    this._isClosed = true;
    this._updateSignalingState('closed');
  };

  // Update the signaling state.
  RTCPeerConnection.prototype._updateSignalingState = function(newState) {
    this.signalingState = newState;
    var event = new Event('signalingstatechange');
    this._dispatchEvent('signalingstatechange', event);
  };

  // Determine whether to fire the negotiationneeded event.
  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {
    var pc = this;
    if (this.signalingState !== 'stable' || this.needNegotiation === true) {
      return;
    }
    this.needNegotiation = true;
    window.setTimeout(function() {
      if (pc.needNegotiation) {
        pc.needNegotiation = false;
        var event = new Event('negotiationneeded');
        pc._dispatchEvent('negotiationneeded', event);
      }
    }, 0);
  };

  // Update the ice connection state.
  RTCPeerConnection.prototype._updateIceConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      checking: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      states[transceiver.iceTransport.state]++;
    });

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.checking > 0) {
      newState = 'checking';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0) {
      newState = 'connected';
    } else if (states.completed > 0) {
      newState = 'completed';
    }

    if (newState !== this.iceConnectionState) {
      this.iceConnectionState = newState;
      var event = new Event('iceconnectionstatechange');
      this._dispatchEvent('iceconnectionstatechange', event);
    }
  };

  // Update the connection state.
  RTCPeerConnection.prototype._updateConnectionState = function() {
    var newState;
    var states = {
      'new': 0,
      closed: 0,
      connecting: 0,
      connected: 0,
      completed: 0,
      disconnected: 0,
      failed: 0
    };
    this.transceivers.forEach(function(transceiver) {
      states[transceiver.iceTransport.state]++;
      states[transceiver.dtlsTransport.state]++;
    });
    // ICETransport.completed and connected are the same for this purpose.
    states.connected += states.completed;

    newState = 'new';
    if (states.failed > 0) {
      newState = 'failed';
    } else if (states.connecting > 0) {
      newState = 'connecting';
    } else if (states.disconnected > 0) {
      newState = 'disconnected';
    } else if (states.new > 0) {
      newState = 'new';
    } else if (states.connected > 0) {
      newState = 'connected';
    }

    if (newState !== this.connectionState) {
      this.connectionState = newState;
      var event = new Event('connectionstatechange');
      this._dispatchEvent('connectionstatechange', event);
    }
  };

  RTCPeerConnection.prototype.createOffer = function() {
    var pc = this;

    if (pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createOffer after close'));
    }

    var numAudioTracks = pc.transceivers.filter(function(t) {
      return t.kind === 'audio';
    }).length;
    var numVideoTracks = pc.transceivers.filter(function(t) {
      return t.kind === 'video';
    }).length;

    // Determine number of audio and video tracks we need to send/recv.
    var offerOptions = arguments[0];
    if (offerOptions) {
      // Reject Chrome legacy constraints.
      if (offerOptions.mandatory || offerOptions.optional) {
        throw new TypeError(
            'Legacy mandatory/optional constraints not supported.');
      }
      if (offerOptions.offerToReceiveAudio !== undefined) {
        if (offerOptions.offerToReceiveAudio === true) {
          numAudioTracks = 1;
        } else if (offerOptions.offerToReceiveAudio === false) {
          numAudioTracks = 0;
        } else {
          numAudioTracks = offerOptions.offerToReceiveAudio;
        }
      }
      if (offerOptions.offerToReceiveVideo !== undefined) {
        if (offerOptions.offerToReceiveVideo === true) {
          numVideoTracks = 1;
        } else if (offerOptions.offerToReceiveVideo === false) {
          numVideoTracks = 0;
        } else {
          numVideoTracks = offerOptions.offerToReceiveVideo;
        }
      }
    }

    pc.transceivers.forEach(function(transceiver) {
      if (transceiver.kind === 'audio') {
        numAudioTracks--;
        if (numAudioTracks < 0) {
          transceiver.wantReceive = false;
        }
      } else if (transceiver.kind === 'video') {
        numVideoTracks--;
        if (numVideoTracks < 0) {
          transceiver.wantReceive = false;
        }
      }
    });

    // Create M-lines for recvonly streams.
    while (numAudioTracks > 0 || numVideoTracks > 0) {
      if (numAudioTracks > 0) {
        pc._createTransceiver('audio');
        numAudioTracks--;
      }
      if (numVideoTracks > 0) {
        pc._createTransceiver('video');
        numVideoTracks--;
      }
    }

    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
        pc._sdpSessionVersion++);
    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      // For each track, create an ice gatherer, ice transport,
      // dtls transport, potentially rtpsender and rtpreceiver.
      var track = transceiver.track;
      var kind = transceiver.kind;
      var mid = transceiver.mid || SDPUtils.generateIdentifier();
      transceiver.mid = mid;

      if (!transceiver.iceGatherer) {
        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,
            pc.usingBundle);
      }

      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);
      // filter RTX until additional stuff needed for RTX is implemented
      // in adapter.js
      if (edgeVersion < 15019) {
        localCapabilities.codecs = localCapabilities.codecs.filter(
            function(codec) {
              return codec.name !== 'rtx';
            });
      }
      localCapabilities.codecs.forEach(function(codec) {
        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552
        // by adding level-asymmetry-allowed=1
        if (codec.name === 'H264' &&
            codec.parameters['level-asymmetry-allowed'] === undefined) {
          codec.parameters['level-asymmetry-allowed'] = '1';
        }

        // for subsequent offers, we might have to re-use the payload
        // type of the last offer.
        if (transceiver.remoteCapabilities &&
            transceiver.remoteCapabilities.codecs) {
          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {
            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&
                codec.clockRate === remoteCodec.clockRate) {
              codec.preferredPayloadType = remoteCodec.payloadType;
            }
          });
        }
      });
      localCapabilities.headerExtensions.forEach(function(hdrExt) {
        var remoteExtensions = transceiver.remoteCapabilities &&
            transceiver.remoteCapabilities.headerExtensions || [];
        remoteExtensions.forEach(function(rHdrExt) {
          if (hdrExt.uri === rHdrExt.uri) {
            hdrExt.id = rHdrExt.id;
          }
        });
      });

      // generate an ssrc now, to be used later in rtpSender.send
      var sendEncodingParameters = transceiver.sendEncodingParameters || [{
        ssrc: (2 * sdpMLineIndex + 1) * 1001
      }];
      if (track) {
        // add RTX
        if (edgeVersion >= 15019 && kind === 'video' &&
            !sendEncodingParameters[0].rtx) {
          sendEncodingParameters[0].rtx = {
            ssrc: sendEncodingParameters[0].ssrc + 1
          };
        }
      }

      if (transceiver.wantReceive) {
        transceiver.rtpReceiver = new window.RTCRtpReceiver(
            transceiver.dtlsTransport, kind);
      }

      transceiver.localCapabilities = localCapabilities;
      transceiver.sendEncodingParameters = sendEncodingParameters;
    });

    // always offer BUNDLE and dispose on return if not supported.
    if (pc._config.bundlePolicy !== 'max-compat') {
      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    sdp += 'a=ice-options:trickle\r\n';

    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,
          'offer', transceiver.stream, pc._dtlsRole);
      sdp += 'a=rtcp-rsize\r\n';

      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&
          (sdpMLineIndex === 0 || !pc.usingBundle)) {
        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {
          cand.component = 1;
          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\r\n';
        });

        if (transceiver.iceGatherer.state === 'completed') {
          sdp += 'a=end-of-candidates\r\n';
        }
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'offer',
      sdp: sdp
    });
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.createAnswer = function() {
    var pc = this;

    if (pc._isClosed) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createAnswer after close'));
    }

    if (!(pc.signalingState === 'have-remote-offer' ||
        pc.signalingState === 'have-local-pranswer')) {
      return Promise.reject(makeError('InvalidStateError',
          'Can not call createAnswer in signalingState ' + pc.signalingState));
    }

    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,
        pc._sdpSessionVersion++);
    if (pc.usingBundle) {
      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {
        return t.mid;
      }).join(' ') + '\r\n';
    }
    var mediaSectionsInOffer = SDPUtils.getMediaSections(
        pc._remoteDescription.sdp).length;
    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {
      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
        return;
      }
      if (transceiver.rejected) {
        if (transceiver.kind === 'application') {
          if (transceiver.protocol === 'DTLS/SCTP') { // legacy fmt
            sdp += 'm=application 0 DTLS/SCTP 5000\r\n';
          } else {
            sdp += 'm=application 0 ' + transceiver.protocol +
                ' webrtc-datachannel\r\n';
          }
        } else if (transceiver.kind === 'audio') {
          sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\r\n' +
              'a=rtpmap:0 PCMU/8000\r\n';
        } else if (transceiver.kind === 'video') {
          sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\r\n' +
              'a=rtpmap:120 VP8/90000\r\n';
        }
        sdp += 'c=IN IP4 0.0.0.0\r\n' +
            'a=inactive\r\n' +
            'a=mid:' + transceiver.mid + '\r\n';
        return;
      }

      // FIXME: look at direction.
      if (transceiver.stream) {
        var localTrack;
        if (transceiver.kind === 'audio') {
          localTrack = transceiver.stream.getAudioTracks()[0];
        } else if (transceiver.kind === 'video') {
          localTrack = transceiver.stream.getVideoTracks()[0];
        }
        if (localTrack) {
          // add RTX
          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&
              !transceiver.sendEncodingParameters[0].rtx) {
            transceiver.sendEncodingParameters[0].rtx = {
              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1
            };
          }
        }
      }

      // Calculate intersection of capabilities.
      var commonCapabilities = getCommonCapabilities(
          transceiver.localCapabilities,
          transceiver.remoteCapabilities);

      var hasRtx = commonCapabilities.codecs.filter(function(c) {
        return c.name.toLowerCase() === 'rtx';
      }).length;
      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
        delete transceiver.sendEncodingParameters[0].rtx;
      }

      sdp += writeMediaSection(transceiver, commonCapabilities,
          'answer', transceiver.stream, pc._dtlsRole);
      if (transceiver.rtcpParameters &&
          transceiver.rtcpParameters.reducedSize) {
        sdp += 'a=rtcp-rsize\r\n';
      }
    });

    var desc = new window.RTCSessionDescription({
      type: 'answer',
      sdp: sdp
    });
    return Promise.resolve(desc);
  };

  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {
    var pc = this;
    var sections;
    if (candidate && !(candidate.sdpMLineIndex !== undefined ||
        candidate.sdpMid)) {
      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));
    }

    // TODO: needs to go into ops queue.
    return new Promise(function(resolve, reject) {
      if (!pc._remoteDescription) {
        return reject(makeError('InvalidStateError',
            'Can not add ICE candidate without a remote description'));
      } else if (!candidate || candidate.candidate === '') {
        for (var j = 0; j < pc.transceivers.length; j++) {
          if (pc.transceivers[j].rejected) {
            continue;
          }
          pc.transceivers[j].iceTransport.addRemoteCandidate({});
          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
          sections[j] += 'a=end-of-candidates\r\n';
          pc._remoteDescription.sdp =
              SDPUtils.getDescription(pc._remoteDescription.sdp) +
              sections.join('');
          if (pc.usingBundle) {
            break;
          }
        }
      } else {
        var sdpMLineIndex = candidate.sdpMLineIndex;
        if (candidate.sdpMid) {
          for (var i = 0; i < pc.transceivers.length; i++) {
            if (pc.transceivers[i].mid === candidate.sdpMid) {
              sdpMLineIndex = i;
              break;
            }
          }
        }
        var transceiver = pc.transceivers[sdpMLineIndex];
        if (transceiver) {
          if (transceiver.rejected) {
            return resolve();
          }
          var cand = Object.keys(candidate.candidate).length > 0 ?
              SDPUtils.parseCandidate(candidate.candidate) : {};
          // Ignore Chrome's invalid candidates since Edge does not like them.
          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {
            return resolve();
          }
          // Ignore RTCP candidates, we assume RTCP-MUX.
          if (cand.component && cand.component !== 1) {
            return resolve();
          }
          // when using bundle, avoid adding candidates to the wrong
          // ice transport. And avoid adding candidates added in the SDP.
          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&
              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {
            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
              return reject(makeError('OperationError',
                  'Can not add ICE candidate'));
            }
          }

          // update the remoteDescription.
          var candidateString = candidate.candidate.trim();
          if (candidateString.indexOf('a=') === 0) {
            candidateString = candidateString.substr(2);
          }
          sections = SDPUtils.getMediaSections(pc._remoteDescription.sdp);
          sections[sdpMLineIndex] += 'a=' +
              (cand.type ? candidateString : 'end-of-candidates')
              + '\r\n';
          pc._remoteDescription.sdp =
              SDPUtils.getDescription(pc._remoteDescription.sdp) +
              sections.join('');
        } else {
          return reject(makeError('OperationError',
              'Can not add ICE candidate'));
        }
      }
      resolve();
    });
  };

  RTCPeerConnection.prototype.getStats = function(selector) {
    if (selector && selector instanceof window.MediaStreamTrack) {
      var senderOrReceiver = null;
      this.transceivers.forEach(function(transceiver) {
        if (transceiver.rtpSender &&
            transceiver.rtpSender.track === selector) {
          senderOrReceiver = transceiver.rtpSender;
        } else if (transceiver.rtpReceiver &&
            transceiver.rtpReceiver.track === selector) {
          senderOrReceiver = transceiver.rtpReceiver;
        }
      });
      if (!senderOrReceiver) {
        throw makeError('InvalidAccessError', 'Invalid selector.');
      }
      return senderOrReceiver.getStats();
    }

    var promises = [];
    this.transceivers.forEach(function(transceiver) {
      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',
          'dtlsTransport'].forEach(function(method) {
            if (transceiver[method]) {
              promises.push(transceiver[method].getStats());
            }
          });
    });
    return Promise.all(promises).then(function(allStats) {
      var results = new Map();
      allStats.forEach(function(stats) {
        stats.forEach(function(stat) {
          results.set(stat.id, stat);
        });
      });
      return results;
    });
  };

  // fix low-level stat names and return Map instead of object.
  var ortcObjects = ['RTCRtpSender', 'RTCRtpReceiver', 'RTCIceGatherer',
    'RTCIceTransport', 'RTCDtlsTransport'];
  ortcObjects.forEach(function(ortcObjectName) {
    var obj = window[ortcObjectName];
    if (obj && obj.prototype && obj.prototype.getStats) {
      var nativeGetstats = obj.prototype.getStats;
      obj.prototype.getStats = function() {
        return nativeGetstats.apply(this)
        .then(function(nativeStats) {
          var mapStats = new Map();
          Object.keys(nativeStats).forEach(function(id) {
            nativeStats[id].type = fixStatsType(nativeStats[id]);
            mapStats.set(id, nativeStats[id]);
          });
          return mapStats;
        });
      };
    }
  });

  // legacy callback shims. Should be moved to adapter.js some days.
  var methods = ['createOffer', 'createAnswer'];
  methods.forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[0] === 'function' ||
          typeof args[1] === 'function') { // legacy
        return nativeMethod.apply(this, [arguments[2]])
        .then(function(description) {
          if (typeof args[0] === 'function') {
            args[0].apply(null, [description]);
          }
        }, function(error) {
          if (typeof args[1] === 'function') {
            args[1].apply(null, [error]);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];
  methods.forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[1] === 'function' ||
          typeof args[2] === 'function') { // legacy
        return nativeMethod.apply(this, arguments)
        .then(function() {
          if (typeof args[1] === 'function') {
            args[1].apply(null);
          }
        }, function(error) {
          if (typeof args[2] === 'function') {
            args[2].apply(null, [error]);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  // getStats is special. It doesn't have a spec legacy method yet we support
  // getStats(something, cb) without error callbacks.
  ['getStats'].forEach(function(method) {
    var nativeMethod = RTCPeerConnection.prototype[method];
    RTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      if (typeof args[1] === 'function') {
        return nativeMethod.apply(this, arguments)
        .then(function() {
          if (typeof args[1] === 'function') {
            args[1].apply(null);
          }
        });
      }
      return nativeMethod.apply(this, arguments);
    };
  });

  return RTCPeerConnection;
};

},{"sdp":2}],2:[function(require,module,exports){
 /* eslint-env node */


// SDP helpers.
var SDPUtils = {};

// Generate an alphanumeric identifier for cname or mids.
// TODO: use UUIDs instead? https://gist.github.com/jed/982883
SDPUtils.generateIdentifier = function() {
  return Math.random().toString(36).substr(2, 10);
};

// The RTCP CNAME used by all peerconnections from the same JS.
SDPUtils.localCName = SDPUtils.generateIdentifier();

// Splits SDP into lines, dealing with both CRLF and LF.
SDPUtils.splitLines = function(blob) {
  return blob.trim().split('\n').map(function(line) {
    return line.trim();
  });
};
// Splits SDP into sessionpart and mediasections. Ensures CRLF.
SDPUtils.splitSections = function(blob) {
  var parts = blob.split('\nm=');
  return parts.map(function(part, index) {
    return (index > 0 ? 'm=' + part : part).trim() + '\r\n';
  });
};

// returns the session description.
SDPUtils.getDescription = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  return sections && sections[0];
};

// returns the individual media sections.
SDPUtils.getMediaSections = function(blob) {
  var sections = SDPUtils.splitSections(blob);
  sections.shift();
  return sections;
};

// Returns lines that start with a certain prefix.
SDPUtils.matchPrefix = function(blob, prefix) {
  return SDPUtils.splitLines(blob).filter(function(line) {
    return line.indexOf(prefix) === 0;
  });
};

// Parses an ICE candidate line. Sample input:
// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8
// rport 55996"
SDPUtils.parseCandidate = function(line) {
  var parts;
  // Parse both variants.
  if (line.indexOf('a=candidate:') === 0) {
    parts = line.substring(12).split(' ');
  } else {
    parts = line.substring(10).split(' ');
  }

  var candidate = {
    foundation: parts[0],
    component: parseInt(parts[1], 10),
    protocol: parts[2].toLowerCase(),
    priority: parseInt(parts[3], 10),
    ip: parts[4],
    port: parseInt(parts[5], 10),
    // skip parts[6] == 'typ'
    type: parts[7]
  };

  for (var i = 8; i < parts.length; i += 2) {
    switch (parts[i]) {
      case 'raddr':
        candidate.relatedAddress = parts[i + 1];
        break;
      case 'rport':
        candidate.relatedPort = parseInt(parts[i + 1], 10);
        break;
      case 'tcptype':
        candidate.tcpType = parts[i + 1];
        break;
      case 'ufrag':
        candidate.ufrag = parts[i + 1]; // for backward compability.
        candidate.usernameFragment = parts[i + 1];
        break;
      default: // extension handling, in particular ufrag
        candidate[parts[i]] = parts[i + 1];
        break;
    }
  }
  return candidate;
};

// Translates a candidate object into SDP candidate attribute.
SDPUtils.writeCandidate = function(candidate) {
  var sdp = [];
  sdp.push(candidate.foundation);
  sdp.push(candidate.component);
  sdp.push(candidate.protocol.toUpperCase());
  sdp.push(candidate.priority);
  sdp.push(candidate.ip);
  sdp.push(candidate.port);

  var type = candidate.type;
  sdp.push('typ');
  sdp.push(type);
  if (type !== 'host' && candidate.relatedAddress &&
      candidate.relatedPort) {
    sdp.push('raddr');
    sdp.push(candidate.relatedAddress);
    sdp.push('rport');
    sdp.push(candidate.relatedPort);
  }
  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {
    sdp.push('tcptype');
    sdp.push(candidate.tcpType);
  }
  if (candidate.usernameFragment || candidate.ufrag) {
    sdp.push('ufrag');
    sdp.push(candidate.usernameFragment || candidate.ufrag);
  }
  return 'candidate:' + sdp.join(' ');
};

// Parses an ice-options line, returns an array of option tags.
// a=ice-options:foo bar
SDPUtils.parseIceOptions = function(line) {
  return line.substr(14).split(' ');
}

// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:
// a=rtpmap:111 opus/48000/2
SDPUtils.parseRtpMap = function(line) {
  var parts = line.substr(9).split(' ');
  var parsed = {
    payloadType: parseInt(parts.shift(), 10) // was: id
  };

  parts = parts[0].split('/');

  parsed.name = parts[0];
  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate
  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
  // legacy alias, got renamed back to channels in ORTC.
  parsed.numChannels = parsed.channels;
  return parsed;
};

// Generate an a=rtpmap line from RTCRtpCodecCapability or
// RTCRtpCodecParameters.
SDPUtils.writeRtpMap = function(codec) {
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  var channels = codec.channels || codec.numChannels || 1;
  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +
      (channels !== 1 ? '/' + channels : '') + '\r\n';
};

// Parses an a=extmap line (headerextension from RFC 5285). Sample input:
// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset
SDPUtils.parseExtmap = function(line) {
  var parts = line.substr(9).split(' ');
  return {
    id: parseInt(parts[0], 10),
    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
    uri: parts[1]
  };
};

// Generates a=extmap line from RTCRtpHeaderExtensionParameters or
// RTCRtpHeaderExtension.
SDPUtils.writeExtmap = function(headerExtension) {
  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +
      (headerExtension.direction && headerExtension.direction !== 'sendrecv'
          ? '/' + headerExtension.direction
          : '') +
      ' ' + headerExtension.uri + '\r\n';
};

// Parses an ftmp line, returns dictionary. Sample input:
// a=fmtp:96 vbr=on;cng=on
// Also deals with vbr=on; cng=on
SDPUtils.parseFmtp = function(line) {
  var parsed = {};
  var kv;
  var parts = line.substr(line.indexOf(' ') + 1).split(';');
  for (var j = 0; j < parts.length; j++) {
    kv = parts[j].trim().split('=');
    parsed[kv[0].trim()] = kv[1];
  }
  return parsed;
};

// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeFmtp = function(codec) {
  var line = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.parameters && Object.keys(codec.parameters).length) {
    var params = [];
    Object.keys(codec.parameters).forEach(function(param) {
      if (codec.parameters[param]) {
        params.push(param + '=' + codec.parameters[param]);
      } else {
        params.push(param);
      }
    });
    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\r\n';
  }
  return line;
};

// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:
// a=rtcp-fb:98 nack rpsi
SDPUtils.parseRtcpFb = function(line) {
  var parts = line.substr(line.indexOf(' ') + 1).split(' ');
  return {
    type: parts.shift(),
    parameter: parts.join(' ')
  };
};
// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.
SDPUtils.writeRtcpFb = function(codec) {
  var lines = '';
  var pt = codec.payloadType;
  if (codec.preferredPayloadType !== undefined) {
    pt = codec.preferredPayloadType;
  }
  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
    // FIXME: special handling for trr-int?
    codec.rtcpFeedback.forEach(function(fb) {
      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +
      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +
          '\r\n';
    });
  }
  return lines;
};

// Parses an RFC 5576 ssrc media attribute. Sample input:
// a=ssrc:3735928559 cname:something
SDPUtils.parseSsrcMedia = function(line) {
  var sp = line.indexOf(' ');
  var parts = {
    ssrc: parseInt(line.substr(7, sp - 7), 10)
  };
  var colon = line.indexOf(':', sp);
  if (colon > -1) {
    parts.attribute = line.substr(sp + 1, colon - sp - 1);
    parts.value = line.substr(colon + 1);
  } else {
    parts.attribute = line.substr(sp + 1);
  }
  return parts;
};

// Extracts the MID (RFC 5888) from a media section.
// returns the MID or undefined if no mid line was found.
SDPUtils.getMid = function(mediaSection) {
  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
  if (mid) {
    return mid.substr(6);
  }
}

SDPUtils.parseFingerprint = function(line) {
  var parts = line.substr(14).split(' ');
  return {
    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.
    value: parts[1]
  };
};

// Extracts DTLS parameters from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the fingerprint line as input. See also getIceParameters.
SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,
      'a=fingerprint:');
  // Note: a=setup line is ignored since we use the 'auto' role.
  // Note2: 'algorithm' is not case sensitive except in Edge.
  return {
    role: 'auto',
    fingerprints: lines.map(SDPUtils.parseFingerprint)
  };
};

// Serializes DTLS parameters to SDP.
SDPUtils.writeDtlsParameters = function(params, setupType) {
  var sdp = 'a=setup:' + setupType + '\r\n';
  params.fingerprints.forEach(function(fp) {
    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\r\n';
  });
  return sdp;
};
// Parses ICE information from SDP media section or sessionpart.
// FIXME: for consistency with other functions this should only
//   get the ice-ufrag and ice-pwd lines as input.
SDPUtils.getIceParameters = function(mediaSection, sessionpart) {
  var lines = SDPUtils.splitLines(mediaSection);
  // Search in session part, too.
  lines = lines.concat(SDPUtils.splitLines(sessionpart));
  var iceParameters = {
    usernameFragment: lines.filter(function(line) {
      return line.indexOf('a=ice-ufrag:') === 0;
    })[0].substr(12),
    password: lines.filter(function(line) {
      return line.indexOf('a=ice-pwd:') === 0;
    })[0].substr(10)
  };
  return iceParameters;
};

// Serializes ICE parameters to SDP.
SDPUtils.writeIceParameters = function(params) {
  return 'a=ice-ufrag:' + params.usernameFragment + '\r\n' +
      'a=ice-pwd:' + params.password + '\r\n';
};

// Parses the SDP media section and returns RTCRtpParameters.
SDPUtils.parseRtpParameters = function(mediaSection) {
  var description = {
    codecs: [],
    headerExtensions: [],
    fecMechanisms: [],
    rtcp: []
  };
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]
    var pt = mline[i];
    var rtpmapline = SDPUtils.matchPrefix(
        mediaSection, 'a=rtpmap:' + pt + ' ')[0];
    if (rtpmapline) {
      var codec = SDPUtils.parseRtpMap(rtpmapline);
      var fmtps = SDPUtils.matchPrefix(
          mediaSection, 'a=fmtp:' + pt + ' ');
      // Only the first a=fmtp:<pt> is considered.
      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};
      codec.rtcpFeedback = SDPUtils.matchPrefix(
          mediaSection, 'a=rtcp-fb:' + pt + ' ')
        .map(SDPUtils.parseRtcpFb);
      description.codecs.push(codec);
      // parse FEC mechanisms from rtpmap lines.
      switch (codec.name.toUpperCase()) {
        case 'RED':
        case 'ULPFEC':
          description.fecMechanisms.push(codec.name.toUpperCase());
          break;
        default: // only RED and ULPFEC are recognized as FEC mechanisms.
          break;
      }
    }
  }
  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {
    description.headerExtensions.push(SDPUtils.parseExtmap(line));
  });
  // FIXME: parse rtcp.
  return description;
};

// Generates parts of the SDP media section describing the capabilities /
// parameters.
SDPUtils.writeRtpDescription = function(kind, caps) {
  var sdp = '';

  // Build the mline.
  sdp += 'm=' + kind + ' ';
  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.
  sdp += ' UDP/TLS/RTP/SAVPF ';
  sdp += caps.codecs.map(function(codec) {
    if (codec.preferredPayloadType !== undefined) {
      return codec.preferredPayloadType;
    }
    return codec.payloadType;
  }).join(' ') + '\r\n';

  sdp += 'c=IN IP4 0.0.0.0\r\n';
  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';

  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.
  caps.codecs.forEach(function(codec) {
    sdp += SDPUtils.writeRtpMap(codec);
    sdp += SDPUtils.writeFmtp(codec);
    sdp += SDPUtils.writeRtcpFb(codec);
  });
  var maxptime = 0;
  caps.codecs.forEach(function(codec) {
    if (codec.maxptime > maxptime) {
      maxptime = codec.maxptime;
    }
  });
  if (maxptime > 0) {
    sdp += 'a=maxptime:' + maxptime + '\r\n';
  }
  sdp += 'a=rtcp-mux\r\n';

  if (caps.headerExtensions) {
    caps.headerExtensions.forEach(function(extension) {
      sdp += SDPUtils.writeExtmap(extension);
    });
  }
  // FIXME: write fecMechanisms.
  return sdp;
};

// Parses the SDP media section and returns an array of
// RTCRtpEncodingParameters.
SDPUtils.parseRtpEncodingParameters = function(mediaSection) {
  var encodingParameters = [];
  var description = SDPUtils.parseRtpParameters(mediaSection);
  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;
  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;

  // filter a=ssrc:... cname:, ignore PlanB-msid
  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'cname';
  });
  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
  var secondarySsrc;

  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')
  .map(function(line) {
    var parts = line.substr(17).split(' ');
    return parts.map(function(part) {
      return parseInt(part, 10);
    });
  });
  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
    secondarySsrc = flows[0][1];
  }

  description.codecs.forEach(function(codec) {
    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
      var encParam = {
        ssrc: primarySsrc,
        codecPayloadType: parseInt(codec.parameters.apt, 10),
      };
      if (primarySsrc && secondarySsrc) {
        encParam.rtx = {ssrc: secondarySsrc};
      }
      encodingParameters.push(encParam);
      if (hasRed) {
        encParam = JSON.parse(JSON.stringify(encParam));
        encParam.fec = {
          ssrc: secondarySsrc,
          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'
        };
        encodingParameters.push(encParam);
      }
    }
  });
  if (encodingParameters.length === 0 && primarySsrc) {
    encodingParameters.push({
      ssrc: primarySsrc
    });
  }

  // we support both b=AS and b=TIAS but interpret AS as TIAS.
  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
  if (bandwidth.length) {
    if (bandwidth[0].indexOf('b=TIAS:') === 0) {
      bandwidth = parseInt(bandwidth[0].substr(7), 10);
    } else if (bandwidth[0].indexOf('b=AS:') === 0) {
      // use formula from JSEP to convert b=AS to TIAS value.
      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95
          - (50 * 40 * 8);
    } else {
      bandwidth = undefined;
    }
    encodingParameters.forEach(function(params) {
      params.maxBitrate = bandwidth;
    });
  }
  return encodingParameters;
};

// parses http://draft.ortc.org/#rtcrtcpparameters*
SDPUtils.parseRtcpParameters = function(mediaSection) {
  var rtcpParameters = {};

  var cname;
  // Gets the first SSRC. Note that with RTX there might be multiple
  // SSRCs.
  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
      .map(function(line) {
        return SDPUtils.parseSsrcMedia(line);
      })
      .filter(function(obj) {
        return obj.attribute === 'cname';
      })[0];
  if (remoteSsrc) {
    rtcpParameters.cname = remoteSsrc.value;
    rtcpParameters.ssrc = remoteSsrc.ssrc;
  }

  // Edge uses the compound attribute instead of reducedSize
  // compound is !reducedSize
  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
  rtcpParameters.reducedSize = rsize.length > 0;
  rtcpParameters.compound = rsize.length === 0;

  // parses the rtcp-mux attrіbute.
  // Note that Edge does not support unmuxed RTCP.
  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
  rtcpParameters.mux = mux.length > 0;

  return rtcpParameters;
};

// parses either a=msid: or a=ssrc:... msid lines and returns
// the id of the MediaStream and MediaStreamTrack.
SDPUtils.parseMsid = function(mediaSection) {
  var parts;
  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
  if (spec.length === 1) {
    parts = spec[0].substr(7).split(' ');
    return {stream: parts[0], track: parts[1]};
  }
  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
  .map(function(line) {
    return SDPUtils.parseSsrcMedia(line);
  })
  .filter(function(parts) {
    return parts.attribute === 'msid';
  });
  if (planB.length > 0) {
    parts = planB[0].value.split(' ');
    return {stream: parts[0], track: parts[1]};
  }
};

// Generate a session ID for SDP.
// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1
// recommends using a cryptographically random +ve 64-bit value
// but right now this should be acceptable and within the right range
SDPUtils.generateSessionId = function() {
  return Math.random().toString().substr(2, 21);
};

// Write boilder plate for start of SDP
// sessId argument is optional - if not supplied it will
// be generated randomly
// sessVersion is optional and defaults to 2
SDPUtils.writeSessionBoilerplate = function(sessId, sessVer) {
  var sessionId;
  var version = sessVer !== undefined ? sessVer : 2;
  if (sessId) {
    sessionId = sessId;
  } else {
    sessionId = SDPUtils.generateSessionId();
  }
  // FIXME: sess-id should be an NTP timestamp.
  return 'v=0\r\n' +
      'o=thisisadapterortc ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\r\n' +
      's=-\r\n' +
      't=0 0\r\n';
};

SDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {
  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);

  // Map ICE parameters (ufrag, pwd) to SDP.
  sdp += SDPUtils.writeIceParameters(
      transceiver.iceGatherer.getLocalParameters());

  // Map DTLS parameters to SDP.
  sdp += SDPUtils.writeDtlsParameters(
      transceiver.dtlsTransport.getLocalParameters(),
      type === 'offer' ? 'actpass' : 'active');

  sdp += 'a=mid:' + transceiver.mid + '\r\n';

  if (transceiver.direction) {
    sdp += 'a=' + transceiver.direction + '\r\n';
  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
    sdp += 'a=sendrecv\r\n';
  } else if (transceiver.rtpSender) {
    sdp += 'a=sendonly\r\n';
  } else if (transceiver.rtpReceiver) {
    sdp += 'a=recvonly\r\n';
  } else {
    sdp += 'a=inactive\r\n';
  }

  if (transceiver.rtpSender) {
    // spec.
    var msid = 'msid:' + stream.id + ' ' +
        transceiver.rtpSender.track.id + '\r\n';
    sdp += 'a=' + msid;

    // for Chrome.
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
        ' ' + msid;
    if (transceiver.sendEncodingParameters[0].rtx) {
      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
          ' ' + msid;
      sdp += 'a=ssrc-group:FID ' +
          transceiver.sendEncodingParameters[0].ssrc + ' ' +
          transceiver.sendEncodingParameters[0].rtx.ssrc +
          '\r\n';
    }
  }
  // FIXME: this should be written by writeRtpDescription.
  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +
      ' cname:' + SDPUtils.localCName + '\r\n';
  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {
    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +
        ' cname:' + SDPUtils.localCName + '\r\n';
  }
  return sdp;
};

// Gets the direction from the mediaSection or the sessionpart.
SDPUtils.getDirection = function(mediaSection, sessionpart) {
  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.
  var lines = SDPUtils.splitLines(mediaSection);
  for (var i = 0; i < lines.length; i++) {
    switch (lines[i]) {
      case 'a=sendrecv':
      case 'a=sendonly':
      case 'a=recvonly':
      case 'a=inactive':
        return lines[i].substr(2);
      default:
        // FIXME: What should happen here?
    }
  }
  if (sessionpart) {
    return SDPUtils.getDirection(sessionpart);
  }
  return 'sendrecv';
};

SDPUtils.getKind = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var mline = lines[0].split(' ');
  return mline[0].substr(2);
};

SDPUtils.isRejected = function(mediaSection) {
  return mediaSection.split(' ', 2)[1] === '0';
};

SDPUtils.parseMLine = function(mediaSection) {
  var lines = SDPUtils.splitLines(mediaSection);
  var parts = lines[0].substr(2).split(' ');
  return {
    kind: parts[0],
    port: parseInt(parts[1], 10),
    protocol: parts[2],
    fmt: parts.slice(3).join(' ')
  };
};

SDPUtils.parseOLine = function(mediaSection) {
  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
  var parts = line.substr(2).split(' ');
  return {
    username: parts[0],
    sessionId: parts[1],
    sessionVersion: parseInt(parts[2], 10),
    netType: parts[3],
    addressType: parts[4],
    address: parts[5],
  };
}

// Expose public methods.
if (typeof module === 'object') {
  module.exports = SDPUtils;
}

},{}],3:[function(require,module,exports){
(function (global){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */



var adapterFactory = require('./adapter_factory.js');
module.exports = adapterFactory({window: global.window});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./adapter_factory.js":4}],4:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */



var utils = require('./utils');
// Shimming starts here.
module.exports = function(dependencies, opts) {
  var window = dependencies && dependencies.window;

  var options = {
    shimChrome: true,
    shimFirefox: true,
    shimEdge: true,
    shimSafari: true,
  };

  for (var key in opts) {
    if (hasOwnProperty.call(opts, key)) {
      options[key] = opts[key];
    }
  }

  // Utils.
  var logging = utils.log;
  var browserDetails = utils.detectBrowser(window);

  // Uncomment the line below if you want logging to occur, including logging
  // for the switch statement below. Can also be turned on in the browser via
  // adapter.disableLog(false), but then logging from the switch statement below
  // will not appear.
  // require('./utils').disableLog(false);

  // Browser shims.
  var chromeShim = require('./chrome/chrome_shim') || null;
  var edgeShim = require('./edge/edge_shim') || null;
  var firefoxShim = require('./firefox/firefox_shim') || null;
  var safariShim = require('./safari/safari_shim') || null;
  var commonShim = require('./common_shim') || null;

  // Export to the adapter global object visible in the browser.
  var adapter = {
    browserDetails: browserDetails,
    commonShim: commonShim,
    extractVersion: utils.extractVersion,
    disableLog: utils.disableLog,
    disableWarnings: utils.disableWarnings
  };

  // Shim browser if found.
  switch (browserDetails.browser) {
    case 'chrome':
      if (!chromeShim || !chromeShim.shimPeerConnection ||
          !options.shimChrome) {
        logging('Chrome shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming chrome.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = chromeShim;
      commonShim.shimCreateObjectURL(window);

      chromeShim.shimGetUserMedia(window);
      chromeShim.shimMediaStream(window);
      chromeShim.shimSourceObject(window);
      chromeShim.shimPeerConnection(window);
      chromeShim.shimOnTrack(window);
      chromeShim.shimAddTrackRemoveTrack(window);
      chromeShim.shimGetSendersWithDtmf(window);
      chromeShim.shimSenderReceiverGetStats(window);
      chromeShim.fixNegotiationNeeded(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'firefox':
      if (!firefoxShim || !firefoxShim.shimPeerConnection ||
          !options.shimFirefox) {
        logging('Firefox shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming firefox.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = firefoxShim;
      commonShim.shimCreateObjectURL(window);

      firefoxShim.shimGetUserMedia(window);
      firefoxShim.shimSourceObject(window);
      firefoxShim.shimPeerConnection(window);
      firefoxShim.shimOnTrack(window);
      firefoxShim.shimRemoveStream(window);
      firefoxShim.shimSenderGetStats(window);
      firefoxShim.shimReceiverGetStats(window);
      firefoxShim.shimRTCDataChannel(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'edge':
      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {
        logging('MS edge shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming edge.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = edgeShim;
      commonShim.shimCreateObjectURL(window);

      edgeShim.shimGetUserMedia(window);
      edgeShim.shimPeerConnection(window);
      edgeShim.shimReplaceTrack(window);

      // the edge shim implements the full RTCIceCandidate object.

      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    case 'safari':
      if (!safariShim || !options.shimSafari) {
        logging('Safari shim is not included in this adapter release.');
        return adapter;
      }
      logging('adapter.js shimming safari.');
      // Export to the adapter global object visible in the browser.
      adapter.browserShim = safariShim;
      commonShim.shimCreateObjectURL(window);

      safariShim.shimRTCIceServerUrls(window);
      safariShim.shimCallbacksAPI(window);
      safariShim.shimLocalStreamsAPI(window);
      safariShim.shimRemoteStreamsAPI(window);
      safariShim.shimTrackEventTransceiver(window);
      safariShim.shimGetUserMedia(window);
      safariShim.shimCreateOfferLegacy(window);

      commonShim.shimRTCIceCandidate(window);
      commonShim.shimMaxMessageSize(window);
      commonShim.shimSendThrowTypeError(window);
      break;
    default:
      logging('Unsupported browser!');
      break;
  }

  return adapter;
};

},{"./chrome/chrome_shim":5,"./common_shim":7,"./edge/edge_shim":8,"./firefox/firefox_shim":11,"./safari/safari_shim":13,"./utils":14}],5:[function(require,module,exports){

/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

var utils = require('../utils.js');
var logging = utils.log;

/* iterates the stats graph recursively. */
function walkStats(stats, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach(function(name) {
    if (name.endsWith('Id')) {
      walkStats(stats, stats.get(base[name]), resultSet);
    } else if (name.endsWith('Ids')) {
      base[name].forEach(function(id) {
        walkStats(stats, stats.get(id), resultSet);
      });
    }
  });
}

/* filter getStats for a sender/receiver track. */
function filterStats(result, track, outbound) {
  var streamStatsType = outbound ? 'outbound-rtp' : 'inbound-rtp';
  var filteredResult = new Map();
  if (track === null) {
    return filteredResult;
  }
  var trackStats = [];
  result.forEach(function(value) {
    if (value.type === 'track' &&
        value.trackIdentifier === track.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach(function(trackStat) {
    result.forEach(function(stats) {
      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
        walkStats(result, stats, filteredResult);
      }
    });
  });
  return filteredResult;
}

module.exports = {
  shimGetUserMedia: require('./getusermedia'),
  shimMediaStream: function(window) {
    window.MediaStream = window.MediaStream || window.webkitMediaStream;
  },

  shimOnTrack: function(window) {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
          }
          this.addEventListener('track', this._ontrack = f);
        },
        enumerable: true,
        configurable: true
      });
      var origSetRemoteDescription =
          window.RTCPeerConnection.prototype.setRemoteDescription;
      window.RTCPeerConnection.prototype.setRemoteDescription = function() {
        var pc = this;
        if (!pc._ontrackpoly) {
          pc._ontrackpoly = function(e) {
            // onaddstream does not fire when a track is added to an existing
            // stream. But stream.onaddtrack is implemented so we use that.
            e.stream.addEventListener('addtrack', function(te) {
              var receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = pc.getReceivers().find(function(r) {
                  return r.track && r.track.id === te.track.id;
                });
              } else {
                receiver = {track: te.track};
              }

              var event = new Event('track');
              event.track = te.track;
              event.receiver = receiver;
              event.transceiver = {receiver: receiver};
              event.streams = [e.stream];
              pc.dispatchEvent(event);
            });
            e.stream.getTracks().forEach(function(track) {
              var receiver;
              if (window.RTCPeerConnection.prototype.getReceivers) {
                receiver = pc.getReceivers().find(function(r) {
                  return r.track && r.track.id === track.id;
                });
              } else {
                receiver = {track: track};
              }
              var event = new Event('track');
              event.track = track;
              event.receiver = receiver;
              event.transceiver = {receiver: receiver};
              event.streams = [e.stream];
              pc.dispatchEvent(event);
            });
          };
          pc.addEventListener('addstream', pc._ontrackpoly);
        }
        return origSetRemoteDescription.apply(pc, arguments);
      };
    } else if (!('RTCRtpTransceiver' in window)) {
      utils.wrapPeerConnectionEvent(window, 'track', function(e) {
        if (!e.transceiver) {
          e.transceiver = {receiver: e.receiver};
        }
        return e;
      });
    }
  },

  shimGetSendersWithDtmf: function(window) {
    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.
    if (typeof window === 'object' && window.RTCPeerConnection &&
        !('getSenders' in window.RTCPeerConnection.prototype) &&
        'createDTMFSender' in window.RTCPeerConnection.prototype) {
      var shimSenderWithDtmf = function(pc, track) {
        return {
          track: track,
          get dtmf() {
            if (this._dtmf === undefined) {
              if (track.kind === 'audio') {
                this._dtmf = pc.createDTMFSender(track);
              } else {
                this._dtmf = null;
              }
            }
            return this._dtmf;
          },
          _pc: pc
        };
      };

      // augment addTrack when getSenders is not available.
      if (!window.RTCPeerConnection.prototype.getSenders) {
        window.RTCPeerConnection.prototype.getSenders = function() {
          this._senders = this._senders || [];
          return this._senders.slice(); // return a copy of the internal state.
        };
        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
        window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
          var pc = this;
          var sender = origAddTrack.apply(pc, arguments);
          if (!sender) {
            sender = shimSenderWithDtmf(pc, track);
            pc._senders.push(sender);
          }
          return sender;
        };

        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
        window.RTCPeerConnection.prototype.removeTrack = function(sender) {
          var pc = this;
          origRemoveTrack.apply(pc, arguments);
          var idx = pc._senders.indexOf(sender);
          if (idx !== -1) {
            pc._senders.splice(idx, 1);
          }
        };
      }
      var origAddStream = window.RTCPeerConnection.prototype.addStream;
      window.RTCPeerConnection.prototype.addStream = function(stream) {
        var pc = this;
        pc._senders = pc._senders || [];
        origAddStream.apply(pc, [stream]);
        stream.getTracks().forEach(function(track) {
          pc._senders.push(shimSenderWithDtmf(pc, track));
        });
      };

      var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
      window.RTCPeerConnection.prototype.removeStream = function(stream) {
        var pc = this;
        pc._senders = pc._senders || [];
        origRemoveStream.apply(pc, [stream]);

        stream.getTracks().forEach(function(track) {
          var sender = pc._senders.find(function(s) {
            return s.track === track;
          });
          if (sender) {
            pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender
          }
        });
      };
    } else if (typeof window === 'object' && window.RTCPeerConnection &&
               'getSenders' in window.RTCPeerConnection.prototype &&
               'createDTMFSender' in window.RTCPeerConnection.prototype &&
               window.RTCRtpSender &&
               !('dtmf' in window.RTCRtpSender.prototype)) {
      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      window.RTCPeerConnection.prototype.getSenders = function() {
        var pc = this;
        var senders = origGetSenders.apply(pc, []);
        senders.forEach(function(sender) {
          sender._pc = pc;
        });
        return senders;
      };

      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = this._pc.createDTMFSender(this.track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
  },

  shimSenderReceiverGetStats: function(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender && window.RTCRtpReceiver)) {
      return;
    }

    // shim sender stats.
    if (!('getStats' in window.RTCRtpSender.prototype)) {
      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
      if (origGetSenders) {
        window.RTCPeerConnection.prototype.getSenders = function() {
          var pc = this;
          var senders = origGetSenders.apply(pc, []);
          senders.forEach(function(sender) {
            sender._pc = pc;
          });
          return senders;
        };
      }

      var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
      if (origAddTrack) {
        window.RTCPeerConnection.prototype.addTrack = function() {
          var sender = origAddTrack.apply(this, arguments);
          sender._pc = this;
          return sender;
        };
      }
      window.RTCRtpSender.prototype.getStats = function() {
        var sender = this;
        return this._pc.getStats().then(function(result) {
          /* Note: this will include stats of all senders that
           *   send a track with the same id as sender.track as
           *   it is not possible to identify the RTCRtpSender.
           */
          return filterStats(result, sender.track, true);
        });
      };
    }

    // shim receiver stats.
    if (!('getStats' in window.RTCRtpReceiver.prototype)) {
      var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
      if (origGetReceivers) {
        window.RTCPeerConnection.prototype.getReceivers = function() {
          var pc = this;
          var receivers = origGetReceivers.apply(pc, []);
          receivers.forEach(function(receiver) {
            receiver._pc = pc;
          });
          return receivers;
        };
      }
      utils.wrapPeerConnectionEvent(window, 'track', function(e) {
        e.receiver._pc = e.srcElement;
        return e;
      });
      window.RTCRtpReceiver.prototype.getStats = function() {
        var receiver = this;
        return this._pc.getStats().then(function(result) {
          return filterStats(result, receiver.track, false);
        });
      };
    }

    if (!('getStats' in window.RTCRtpSender.prototype &&
        'getStats' in window.RTCRtpReceiver.prototype)) {
      return;
    }

    // shim RTCPeerConnection.getStats(track).
    var origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function() {
      var pc = this;
      if (arguments.length > 0 &&
          arguments[0] instanceof window.MediaStreamTrack) {
        var track = arguments[0];
        var sender;
        var receiver;
        var err;
        pc.getSenders().forEach(function(s) {
          if (s.track === track) {
            if (sender) {
              err = true;
            } else {
              sender = s;
            }
          }
        });
        pc.getReceivers().forEach(function(r) {
          if (r.track === track) {
            if (receiver) {
              err = true;
            } else {
              receiver = r;
            }
          }
          return r.track === track;
        });
        if (err || (sender && receiver)) {
          return Promise.reject(new DOMException(
            'There are more than one sender or receiver for the track.',
            'InvalidAccessError'));
        } else if (sender) {
          return sender.getStats();
        } else if (receiver) {
          return receiver.getStats();
        }
        return Promise.reject(new DOMException(
          'There is no sender or receiver for the track.',
          'InvalidAccessError'));
      }
      return origGetStats.apply(pc, arguments);
    };
  },

  shimSourceObject: function(window) {
    var URL = window && window.URL;

    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this._srcObject;
          },
          set: function(stream) {
            var self = this;
            // Use _srcObject as a private property for this shim
            this._srcObject = stream;
            if (this.src) {
              URL.revokeObjectURL(this.src);
            }

            if (!stream) {
              this.src = '';
              return undefined;
            }
            this.src = URL.createObjectURL(stream);
            // We need to recreate the blob url when a track is added or
            // removed. Doing it manually since we want to avoid a recursion.
            stream.addEventListener('addtrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
            stream.addEventListener('removetrack', function() {
              if (self.src) {
                URL.revokeObjectURL(self.src);
              }
              self.src = URL.createObjectURL(stream);
            });
          }
        });
      }
    }
  },

  shimAddTrackRemoveTrackWithNative: function(window) {
    // shim addTrack/removeTrack with native variants in order to make
    // the interactions with legacy getLocalStreams behave as in other browsers.
    // Keeps a mapping stream.id => [stream, rtpsenders...]
    window.RTCPeerConnection.prototype.getLocalStreams = function() {
      var pc = this;
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      return Object.keys(this._shimmedLocalStreams).map(function(streamId) {
        return pc._shimmedLocalStreams[streamId][0];
      });
    };

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
      if (!stream) {
        return origAddTrack.apply(this, arguments);
      }
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      var sender = origAddTrack.apply(this, arguments);
      if (!this._shimmedLocalStreams[stream.id]) {
        this._shimmedLocalStreams[stream.id] = [stream, sender];
      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
        this._shimmedLocalStreams[stream.id].push(sender);
      }
      return sender;
    };

    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function(stream) {
      var pc = this;
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};

      stream.getTracks().forEach(function(track) {
        var alreadyExists = pc.getSenders().find(function(s) {
          return s.track === track;
        });
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
              'InvalidAccessError');
        }
      });
      var existingSenders = pc.getSenders();
      origAddStream.apply(this, arguments);
      var newSenders = pc.getSenders().filter(function(newSender) {
        return existingSenders.indexOf(newSender) === -1;
      });
      this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      delete this._shimmedLocalStreams[stream.id];
      return origRemoveStream.apply(this, arguments);
    };

    var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;
    window.RTCPeerConnection.prototype.removeTrack = function(sender) {
      var pc = this;
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      if (sender) {
        Object.keys(this._shimmedLocalStreams).forEach(function(streamId) {
          var idx = pc._shimmedLocalStreams[streamId].indexOf(sender);
          if (idx !== -1) {
            pc._shimmedLocalStreams[streamId].splice(idx, 1);
          }
          if (pc._shimmedLocalStreams[streamId].length === 1) {
            delete pc._shimmedLocalStreams[streamId];
          }
        });
      }
      return origRemoveTrack.apply(this, arguments);
    };
  },

  shimAddTrackRemoveTrack: function(window) {
    var browserDetails = utils.detectBrowser(window);
    // shim addTrack and removeTrack.
    if (window.RTCPeerConnection.prototype.addTrack &&
        browserDetails.version >= 65) {
      return this.shimAddTrackRemoveTrackWithNative(window);
    }

    // also shim pc.getLocalStreams when addTrack is shimmed
    // to return the original streams.
    var origGetLocalStreams = window.RTCPeerConnection.prototype
        .getLocalStreams;
    window.RTCPeerConnection.prototype.getLocalStreams = function() {
      var pc = this;
      var nativeStreams = origGetLocalStreams.apply(this);
      pc._reverseStreams = pc._reverseStreams || {};
      return nativeStreams.map(function(stream) {
        return pc._reverseStreams[stream.id];
      });
    };

    var origAddStream = window.RTCPeerConnection.prototype.addStream;
    window.RTCPeerConnection.prototype.addStream = function(stream) {
      var pc = this;
      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};

      stream.getTracks().forEach(function(track) {
        var alreadyExists = pc.getSenders().find(function(s) {
          return s.track === track;
        });
        if (alreadyExists) {
          throw new DOMException('Track already exists.',
              'InvalidAccessError');
        }
      });
      // Add identity mapping for consistency with addTrack.
      // Unless this is being used with a stream from addTrack.
      if (!pc._reverseStreams[stream.id]) {
        var newStream = new window.MediaStream(stream.getTracks());
        pc._streams[stream.id] = newStream;
        pc._reverseStreams[newStream.id] = stream;
        stream = newStream;
      }
      origAddStream.apply(pc, [stream]);
    };

    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      var pc = this;
      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};

      origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);
      delete pc._reverseStreams[(pc._streams[stream.id] ?
          pc._streams[stream.id].id : stream.id)];
      delete pc._streams[stream.id];
    };

    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
      var pc = this;
      if (pc.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      var streams = [].slice.call(arguments, 1);
      if (streams.length !== 1 ||
          !streams[0].getTracks().find(function(t) {
            return t === track;
          })) {
        // this is not fully correct but all we can manage without
        // [[associated MediaStreams]] internal slot.
        throw new DOMException(
          'The adapter.js addTrack polyfill only supports a single ' +
          ' stream which is associated with the specified track.',
          'NotSupportedError');
      }

      var alreadyExists = pc.getSenders().find(function(s) {
        return s.track === track;
      });
      if (alreadyExists) {
        throw new DOMException('Track already exists.',
            'InvalidAccessError');
      }

      pc._streams = pc._streams || {};
      pc._reverseStreams = pc._reverseStreams || {};
      var oldStream = pc._streams[stream.id];
      if (oldStream) {
        // this is using odd Chrome behaviour, use with caution:
        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815
        // Note: we rely on the high-level addTrack/dtmf shim to
        // create the sender with a dtmf sender.
        oldStream.addTrack(track);

        // Trigger ONN async.
        Promise.resolve().then(function() {
          pc.dispatchEvent(new Event('negotiationneeded'));
        });
      } else {
        var newStream = new window.MediaStream([track]);
        pc._streams[stream.id] = newStream;
        pc._reverseStreams[newStream.id] = stream;
        pc.addStream(newStream);
      }
      return pc.getSenders().find(function(s) {
        return s.track === track;
      });
    };

    // replace the internal stream id with the external one and
    // vice versa.
    function replaceInternalStreamId(pc, description) {
      var sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {
        var externalStream = pc._reverseStreams[internalId];
        var internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(internalStream.id, 'g'),
            externalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp
      });
    }
    function replaceExternalStreamId(pc, description) {
      var sdp = description.sdp;
      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {
        var externalStream = pc._reverseStreams[internalId];
        var internalStream = pc._streams[externalStream.id];
        sdp = sdp.replace(new RegExp(externalStream.id, 'g'),
            internalStream.id);
      });
      return new RTCSessionDescription({
        type: description.type,
        sdp: sdp
      });
    }
    ['createOffer', 'createAnswer'].forEach(function(method) {
      var nativeMethod = window.RTCPeerConnection.prototype[method];
      window.RTCPeerConnection.prototype[method] = function() {
        var pc = this;
        var args = arguments;
        var isLegacyCall = arguments.length &&
            typeof arguments[0] === 'function';
        if (isLegacyCall) {
          return nativeMethod.apply(pc, [
            function(description) {
              var desc = replaceInternalStreamId(pc, description);
              args[0].apply(null, [desc]);
            },
            function(err) {
              if (args[1]) {
                args[1].apply(null, err);
              }
            }, arguments[2]
          ]);
        }
        return nativeMethod.apply(pc, arguments)
        .then(function(description) {
          return replaceInternalStreamId(pc, description);
        });
      };
    });

    var origSetLocalDescription =
        window.RTCPeerConnection.prototype.setLocalDescription;
    window.RTCPeerConnection.prototype.setLocalDescription = function() {
      var pc = this;
      if (!arguments.length || !arguments[0].type) {
        return origSetLocalDescription.apply(pc, arguments);
      }
      arguments[0] = replaceExternalStreamId(pc, arguments[0]);
      return origSetLocalDescription.apply(pc, arguments);
    };

    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier

    var origLocalDescription = Object.getOwnPropertyDescriptor(
        window.RTCPeerConnection.prototype, 'localDescription');
    Object.defineProperty(window.RTCPeerConnection.prototype,
        'localDescription', {
          get: function() {
            var pc = this;
            var description = origLocalDescription.get.apply(this);
            if (description.type === '') {
              return description;
            }
            return replaceInternalStreamId(pc, description);
          }
        });

    window.RTCPeerConnection.prototype.removeTrack = function(sender) {
      var pc = this;
      if (pc.signalingState === 'closed') {
        throw new DOMException(
          'The RTCPeerConnection\'s signalingState is \'closed\'.',
          'InvalidStateError');
      }
      // We can not yet check for sender instanceof RTCRtpSender
      // since we shim RTPSender. So we check if sender._pc is set.
      if (!sender._pc) {
        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +
            'does not implement interface RTCRtpSender.', 'TypeError');
      }
      var isLocal = sender._pc === pc;
      if (!isLocal) {
        throw new DOMException('Sender was not created by this connection.',
            'InvalidAccessError');
      }

      // Search for the native stream the senders track belongs to.
      pc._streams = pc._streams || {};
      var stream;
      Object.keys(pc._streams).forEach(function(streamid) {
        var hasTrack = pc._streams[streamid].getTracks().find(function(track) {
          return sender.track === track;
        });
        if (hasTrack) {
          stream = pc._streams[streamid];
        }
      });

      if (stream) {
        if (stream.getTracks().length === 1) {
          // if this is the last track of the stream, remove the stream. This
          // takes care of any shimmed _senders.
          pc.removeStream(pc._reverseStreams[stream.id]);
        } else {
          // relying on the same odd chrome behaviour as above.
          stream.removeTrack(sender.track);
        }
        pc.dispatchEvent(new Event('negotiationneeded'));
      }
    };
  },

  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        // Translate iceTransportPolicy to iceTransports,
        // see https://code.google.com/p/webrtc/issues/detail?id=4869
        // this was fixed in M56 along with unprefixing RTCPeerConnection.
        logging('PeerConnection');
        if (pcConfig && pcConfig.iceTransportPolicy) {
          pcConfig.iceTransports = pcConfig.iceTransportPolicy;
        }

        return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype =
          window.webkitRTCPeerConnection.prototype;
      // wrap static methods. Currently just generateCertificate.
      if (window.webkitRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return window.webkitRTCPeerConnection.generateCertificate;
          }
        });
      }
    } else {
      // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
      var OrigPeerConnection = window.RTCPeerConnection;
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        if (pcConfig && pcConfig.iceServers) {
          var newIceServers = [];
          for (var i = 0; i < pcConfig.iceServers.length; i++) {
            var server = pcConfig.iceServers[i];
            if (!server.hasOwnProperty('urls') &&
                server.hasOwnProperty('url')) {
              utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
              server = JSON.parse(JSON.stringify(server));
              server.urls = server.url;
              newIceServers.push(server);
            } else {
              newIceServers.push(pcConfig.iceServers[i]);
            }
          }
          pcConfig.iceServers = newIceServers;
        }
        return new OrigPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
      // wrap static methods. Currently just generateCertificate.
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }

    var origGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function(selector,
        successCallback, errorCallback) {
      var pc = this;
      var args = arguments;

      // If selector is a function then we are in the old style stats so just
      // pass back the original getStats format to avoid breaking old users.
      if (arguments.length > 0 && typeof selector === 'function') {
        return origGetStats.apply(this, arguments);
      }

      // When spec-style getStats is supported, return those when called with
      // either no arguments or the selector argument is null.
      if (origGetStats.length === 0 && (arguments.length === 0 ||
          typeof arguments[0] !== 'function')) {
        return origGetStats.apply(this, []);
      }

      var fixChromeStats_ = function(response) {
        var standardReport = {};
        var reports = response.result();
        reports.forEach(function(report) {
          var standardStats = {
            id: report.id,
            timestamp: report.timestamp,
            type: {
              localcandidate: 'local-candidate',
              remotecandidate: 'remote-candidate'
            }[report.type] || report.type
          };
          report.names().forEach(function(name) {
            standardStats[name] = report.stat(name);
          });
          standardReport[standardStats.id] = standardStats;
        });

        return standardReport;
      };

      // shim getStats with maplike support
      var makeMapStats = function(stats) {
        return new Map(Object.keys(stats).map(function(key) {
          return [key, stats[key]];
        }));
      };

      if (arguments.length >= 2) {
        var successCallbackWrapper_ = function(response) {
          args[1](makeMapStats(fixChromeStats_(response)));
        };

        return origGetStats.apply(this, [successCallbackWrapper_,
          arguments[0]]);
      }

      // promise-support
      return new Promise(function(resolve, reject) {
        origGetStats.apply(pc, [
          function(response) {
            resolve(makeMapStats(fixChromeStats_(response)));
          }, reject]);
      }).then(successCallback, errorCallback);
    };

    // add promise support -- natively available in Chrome 51
    if (browserDetails.version < 51) {
      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
          .forEach(function(method) {
            var nativeMethod = window.RTCPeerConnection.prototype[method];
            window.RTCPeerConnection.prototype[method] = function() {
              var args = arguments;
              var pc = this;
              var promise = new Promise(function(resolve, reject) {
                nativeMethod.apply(pc, [args[0], resolve, reject]);
              });
              if (args.length < 2) {
                return promise;
              }
              return promise.then(function() {
                args[1].apply(null, []);
              },
              function(err) {
                if (args.length >= 3) {
                  args[2].apply(null, [err]);
                }
              });
            };
          });
    }

    // promise support for createOffer and createAnswer. Available (without
    // bugs) since M52: crbug/619289
    if (browserDetails.version < 52) {
      ['createOffer', 'createAnswer'].forEach(function(method) {
        var nativeMethod = window.RTCPeerConnection.prototype[method];
        window.RTCPeerConnection.prototype[method] = function() {
          var pc = this;
          if (arguments.length < 1 || (arguments.length === 1 &&
              typeof arguments[0] === 'object')) {
            var opts = arguments.length === 1 ? arguments[0] : undefined;
            return new Promise(function(resolve, reject) {
              nativeMethod.apply(pc, [resolve, reject, opts]);
            });
          }
          return nativeMethod.apply(this, arguments);
        };
      });
    }

    // shim implicit creation of RTCSessionDescription/RTCIceCandidate
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = window.RTCPeerConnection.prototype[method];
          window.RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };
  },

  fixNegotiationNeeded: function(window) {
    utils.wrapPeerConnectionEvent(window, 'negotiationneeded', function(e) {
      var pc = e.target;
      if (pc.signalingState !== 'stable') {
        return;
      }
      return e;
    });
  },

  shimGetDisplayMedia: function(window, getSourceId) {
    if ('getDisplayMedia' in window.navigator) {
      return;
    }
    // getSourceId is a function that returns a promise resolving with
    // the sourceId of the screen/window/tab to be shared.
    if (typeof getSourceId !== 'function') {
      console.error('shimGetDisplayMedia: getSourceId argument is not ' +
          'a function');
      return;
    }
    navigator.getDisplayMedia = function(constraints) {
      return getSourceId(constraints)
        .then(function(sourceId) {
          constraints.video = {
            mandatory: {
              chromeMediaSource: 'desktop',
              chromeMediaSourceId: sourceId,
              maxFrameRate: constraints.video.frameRate || 3
            }
          };
          return navigator.mediaDevices.getUserMedia(constraints);
        });
    };
  }
};

},{"../utils.js":14,"./getusermedia":6}],6:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */

var utils = require('../utils.js');
var logging = utils.log;

// Expose public methods.
module.exports = function(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;

  var constraintsToChrome_ = function(c) {
    if (typeof c !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    var cc = {};
    Object.keys(c).forEach(function(key) {
      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
        return;
      }
      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      var oldname_ = function(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return (name === 'deviceId') ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        var oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname_('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(function(mix) {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  var shimConstraints_ = function(constraints, func) {
    if (browserDetails.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && typeof constraints.audio === 'object') {
      var remap = function(obj, a, b) {
        if (a in obj && !(b in obj)) {
          obj[b] = obj[a];
          delete obj[a];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');
      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === 'object') {
      // Shim facingMode for mobile & surface pro.
      var face = constraints.video.facingMode;
      face = face && ((typeof face === 'object') ? face : {ideal: face});
      var getSupportedFacingModeLies = browserDetails.version < 66;

      if ((face && (face.exact === 'user' || face.exact === 'environment' ||
                    face.ideal === 'user' || face.ideal === 'environment')) &&
          !(navigator.mediaDevices.getSupportedConstraints &&
            navigator.mediaDevices.getSupportedConstraints().facingMode &&
            !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        var matches;
        if (face.exact === 'environment' || face.ideal === 'environment') {
          matches = ['back', 'rear'];
        } else if (face.exact === 'user' || face.ideal === 'user') {
          matches = ['front'];
        }
        if (matches) {
          // Look for matches in label, or use last cam for back (typical).
          return navigator.mediaDevices.enumerateDevices()
          .then(function(devices) {
            devices = devices.filter(function(d) {
              return d.kind === 'videoinput';
            });
            var dev = devices.find(function(d) {
              return matches.some(function(match) {
                return d.label.toLowerCase().indexOf(match) !== -1;
              });
            });
            if (!dev && devices.length && matches.indexOf('back') !== -1) {
              dev = devices[devices.length - 1]; // more likely the back cam
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :
                                                        {ideal: dev.deviceId};
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging('chrome: ' + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging('chrome: ' + JSON.stringify(constraints));
    return func(constraints);
  };

  var shimError_ = function(e) {
    return {
      name: {
        PermissionDeniedError: 'NotAllowedError',
        PermissionDismissedError: 'NotAllowedError',
        InvalidStateError: 'NotAllowedError',
        DevicesNotFoundError: 'NotFoundError',
        ConstraintNotSatisfiedError: 'OverconstrainedError',
        TrackStartError: 'NotReadableError',
        MediaDeviceFailedDueToShutdown: 'NotAllowedError',
        MediaDeviceKillSwitchOn: 'NotAllowedError',
        TabCaptureError: 'AbortError',
        ScreenCaptureError: 'AbortError',
        DeviceCaptureError: 'AbortError'
      }[e.name] || e.name,
      message: e.message,
      constraint: e.constraint || e.constraintName,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  var getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, function(c) {
      navigator.webkitGetUserMedia(c, onSuccess, function(e) {
        if (onError) {
          onError(shimError_(e));
        }
      });
    });
  };

  navigator.getUserMedia = getUserMedia_;

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      navigator.getUserMedia(constraints, resolve, reject);
    });
  };

  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {
      getUserMedia: getUserMediaPromise_,
      enumerateDevices: function() {
        return new Promise(function(resolve) {
          var kinds = {audio: 'audioinput', video: 'videoinput'};
          return window.MediaStreamTrack.getSources(function(devices) {
            resolve(devices.map(function(device) {
              return {label: device.label,
                kind: kinds[device.kind],
                deviceId: device.id,
                groupId: ''};
            }));
          });
        });
      },
      getSupportedConstraints: function() {
        return {
          deviceId: true, echoCancellation: true, facingMode: true,
          frameRate: true, height: true, width: true
        };
      }
    };
  }

  // A shim for getUserMedia method on the mediaDevices object.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (!navigator.mediaDevices.getUserMedia) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      return getUserMediaPromise_(constraints);
    };
  } else {
    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
    // function which returns a Promise, it does not accept spec-style
    // constraints.
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, function(c) {
        return origGetUserMedia(c).then(function(stream) {
          if (c.audio && !stream.getAudioTracks().length ||
              c.video && !stream.getVideoTracks().length) {
            stream.getTracks().forEach(function(track) {
              track.stop();
            });
            throw new DOMException('', 'NotFoundError');
          }
          return stream;
        }, function(e) {
          return Promise.reject(shimError_(e));
        });
      });
    };
  }

  // Dummy devicechange event methods.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {
    navigator.mediaDevices.addEventListener = function() {
      logging('Dummy mediaDevices.addEventListener called.');
    };
  }
  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {
    navigator.mediaDevices.removeEventListener = function() {
      logging('Dummy mediaDevices.removeEventListener called.');
    };
  }
};

},{"../utils.js":14}],7:[function(require,module,exports){
/*
 *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */


var SDPUtils = require('sdp');
var utils = require('./utils');

module.exports = {
  shimRTCIceCandidate: function(window) {
    // foundation is arbitrarily chosen as an indicator for full support for
    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface
    if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in
        window.RTCIceCandidate.prototype)) {
      return;
    }

    var NativeRTCIceCandidate = window.RTCIceCandidate;
    window.RTCIceCandidate = function(args) {
      // Remove the a= which shouldn't be part of the candidate string.
      if (typeof args === 'object' && args.candidate &&
          args.candidate.indexOf('a=') === 0) {
        args = JSON.parse(JSON.stringify(args));
        args.candidate = args.candidate.substr(2);
      }

      if (args.candidate && args.candidate.length) {
        // Augment the native candidate with the parsed fields.
        var nativeCandidate = new NativeRTCIceCandidate(args);
        var parsedCandidate = SDPUtils.parseCandidate(args.candidate);
        var augmentedCandidate = Object.assign(nativeCandidate,
            parsedCandidate);

        // Add a serializer that does not serialize the extra attributes.
        augmentedCandidate.toJSON = function() {
          return {
            candidate: augmentedCandidate.candidate,
            sdpMid: augmentedCandidate.sdpMid,
            sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
            usernameFragment: augmentedCandidate.usernameFragment,
          };
        };
        return augmentedCandidate;
      }
      return new NativeRTCIceCandidate(args);
    };
    window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;

    // Hook up the augmented candidate in onicecandidate and
    // addEventListener('icecandidate', ...)
    utils.wrapPeerConnectionEvent(window, 'icecandidate', function(e) {
      if (e.candidate) {
        Object.defineProperty(e, 'candidate', {
          value: new window.RTCIceCandidate(e.candidate),
          writable: 'false'
        });
      }
      return e;
    });
  },

  // shimCreateObjectURL must be called before shimSourceObject to avoid loop.

  shimCreateObjectURL: function(window) {
    var URL = window && window.URL;

    if (!(typeof window === 'object' && window.HTMLMediaElement &&
          'srcObject' in window.HTMLMediaElement.prototype &&
        URL.createObjectURL && URL.revokeObjectURL)) {
      // Only shim CreateObjectURL using srcObject if srcObject exists.
      return undefined;
    }

    var nativeCreateObjectURL = URL.createObjectURL.bind(URL);
    var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);
    var streams = new Map(), newId = 0;

    URL.createObjectURL = function(stream) {
      if ('getTracks' in stream) {
        var url = 'polyblob:' + (++newId);
        streams.set(url, stream);
        utils.deprecated('URL.createObjectURL(stream)',
            'elem.srcObject = stream');
        return url;
      }
      return nativeCreateObjectURL(stream);
    };
    URL.revokeObjectURL = function(url) {
      nativeRevokeObjectURL(url);
      streams.delete(url);
    };

    var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype,
                                              'src');
    Object.defineProperty(window.HTMLMediaElement.prototype, 'src', {
      get: function() {
        return dsc.get.apply(this);
      },
      set: function(url) {
        this.srcObject = streams.get(url) || null;
        return dsc.set.apply(this, [url]);
      }
    });

    var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;
    window.HTMLMediaElement.prototype.setAttribute = function() {
      if (arguments.length === 2 &&
          ('' + arguments[0]).toLowerCase() === 'src') {
        this.srcObject = streams.get(arguments[1]) || null;
      }
      return nativeSetAttribute.apply(this, arguments);
    };
  },

  shimMaxMessageSize: function(window) {
    if (window.RTCSctpTransport || !window.RTCPeerConnection) {
      return;
    }
    var browserDetails = utils.detectBrowser(window);

    if (!('sctp' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {
        get: function() {
          return typeof this._sctp === 'undefined' ? null : this._sctp;
        }
      });
    }

    var sctpInDescription = function(description) {
      var sections = SDPUtils.splitSections(description.sdp);
      sections.shift();
      return sections.some(function(mediaSection) {
        var mLine = SDPUtils.parseMLine(mediaSection);
        return mLine && mLine.kind === 'application'
            && mLine.protocol.indexOf('SCTP') !== -1;
      });
    };

    var getRemoteFirefoxVersion = function(description) {
      // TODO: Is there a better solution for detecting Firefox?
      var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
      if (match === null || match.length < 2) {
        return -1;
      }
      var version = parseInt(match[1], 10);
      // Test for NaN (yes, this is ugly)
      return version !== version ? -1 : version;
    };

    var getCanSendMaxMessageSize = function(remoteIsFirefox) {
      // Every implementation we know can send at least 64 KiB.
      // Note: Although Chrome is technically able to send up to 256 KiB, the
      //       data does not reach the other peer reliably.
      //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419
      var canSendMaxMessageSize = 65536;
      if (browserDetails.browser === 'firefox') {
        if (browserDetails.version < 57) {
          if (remoteIsFirefox === -1) {
            // FF < 57 will send in 16 KiB chunks using the deprecated PPID
            // fragmentation.
            canSendMaxMessageSize = 16384;
          } else {
            // However, other FF (and RAWRTC) can reassemble PPID-fragmented
            // messages. Thus, supporting ~2 GiB when sending.
            canSendMaxMessageSize = 2147483637;
          }
        } else if (browserDetails.version < 60) {
          // Currently, all FF >= 57 will reset the remote maximum message size
          // to the default value when a data channel is created at a later
          // stage. :(
          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831
          canSendMaxMessageSize =
            browserDetails.version === 57 ? 65535 : 65536;
        } else {
          // FF >= 60 supports sending ~2 GiB
          canSendMaxMessageSize = 2147483637;
        }
      }
      return canSendMaxMessageSize;
    };

    var getMaxMessageSize = function(description, remoteIsFirefox) {
      // Note: 65536 bytes is the default value from the SDP spec. Also,
      //       every implementation we know supports receiving 65536 bytes.
      var maxMessageSize = 65536;

      // FF 57 has a slightly incorrect default remote max message size, so
      // we need to adjust it here to avoid a failure when sending.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697
      if (browserDetails.browser === 'firefox'
           && browserDetails.version === 57) {
        maxMessageSize = 65535;
      }

      var match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');
      if (match.length > 0) {
        maxMessageSize = parseInt(match[0].substr(19), 10);
      } else if (browserDetails.browser === 'firefox' &&
                  remoteIsFirefox !== -1) {
        // If the maximum message size is not present in the remote SDP and
        // both local and remote are Firefox, the remote peer can receive
        // ~2 GiB.
        maxMessageSize = 2147483637;
      }
      return maxMessageSize;
    };

    var origSetRemoteDescription =
        window.RTCPeerConnection.prototype.setRemoteDescription;
    window.RTCPeerConnection.prototype.setRemoteDescription = function() {
      var pc = this;
      pc._sctp = null;

      if (sctpInDescription(arguments[0])) {
        // Check if the remote is FF.
        var isFirefox = getRemoteFirefoxVersion(arguments[0]);

        // Get the maximum message size the local peer is capable of sending
        var canSendMMS = getCanSendMaxMessageSize(isFirefox);

        // Get the maximum message size of the remote peer.
        var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);

        // Determine final maximum message size
        var maxMessageSize;
        if (canSendMMS === 0 && remoteMMS === 0) {
          maxMessageSize = Number.POSITIVE_INFINITY;
        } else if (canSendMMS === 0 || remoteMMS === 0) {
          maxMessageSize = Math.max(canSendMMS, remoteMMS);
        } else {
          maxMessageSize = Math.min(canSendMMS, remoteMMS);
        }

        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'
        // attribute.
        var sctp = {};
        Object.defineProperty(sctp, 'maxMessageSize', {
          get: function() {
            return maxMessageSize;
          }
        });
        pc._sctp = sctp;
      }

      return origSetRemoteDescription.apply(pc, arguments);
    };
  },

  shimSendThrowTypeError: function(window) {
    if (!(window.RTCPeerConnection &&
        'createDataChannel' in window.RTCPeerConnection.prototype)) {
      return;
    }

    // Note: Although Firefox >= 57 has a native implementation, the maximum
    //       message size can be reset for all data channels at a later stage.
    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831

    function wrapDcSend(dc, pc) {
      var origDataChannelSend = dc.send;
      dc.send = function() {
        var data = arguments[0];
        var length = data.length || data.size || data.byteLength;
        if (dc.readyState === 'open' &&
            pc.sctp && length > pc.sctp.maxMessageSize) {
          throw new TypeError('Message too large (can send a maximum of ' +
            pc.sctp.maxMessageSize + ' bytes)');
        }
        return origDataChannelSend.apply(dc, arguments);
      };
    }
    var origCreateDataChannel =
      window.RTCPeerConnection.prototype.createDataChannel;
    window.RTCPeerConnection.prototype.createDataChannel = function() {
      var pc = this;
      var dataChannel = origCreateDataChannel.apply(pc, arguments);
      wrapDcSend(dataChannel, pc);
      return dataChannel;
    };
    utils.wrapPeerConnectionEvent(window, 'datachannel', function(e) {
      wrapDcSend(e.channel, e.target);
      return e;
    });
  }
};

},{"./utils":14,"sdp":2}],8:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */


var utils = require('../utils');
var filterIceServers = require('./filtericeservers');
var shimRTCPeerConnection = require('rtcpeerconnection-shim');

module.exports = {
  shimGetUserMedia: require('./getusermedia'),
  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    if (window.RTCIceGatherer) {
      if (!window.RTCIceCandidate) {
        window.RTCIceCandidate = function(args) {
          return args;
        };
      }
      if (!window.RTCSessionDescription) {
        window.RTCSessionDescription = function(args) {
          return args;
        };
      }
      // this adds an additional event listener to MediaStrackTrack that signals
      // when a tracks enabled property was changed. Workaround for a bug in
      // addStream, see below. No longer required in 15025+
      if (browserDetails.version < 15025) {
        var origMSTEnabled = Object.getOwnPropertyDescriptor(
            window.MediaStreamTrack.prototype, 'enabled');
        Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {
          set: function(value) {
            origMSTEnabled.set.call(this, value);
            var ev = new Event('enabled');
            ev.enabled = value;
            this.dispatchEvent(ev);
          }
        });
      }
    }

    // ORTC defines the DTMF sender a bit different.
    // https://github.com/w3c/ortc/issues/714
    if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {
      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {
        get: function() {
          if (this._dtmf === undefined) {
            if (this.track.kind === 'audio') {
              this._dtmf = new window.RTCDtmfSender(this);
            } else if (this.track.kind === 'video') {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        }
      });
    }
    // Edge currently only implements the RTCDtmfSender, not the
    // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*
    if (window.RTCDtmfSender && !window.RTCDTMFSender) {
      window.RTCDTMFSender = window.RTCDtmfSender;
    }

    var RTCPeerConnectionShim = shimRTCPeerConnection(window,
        browserDetails.version);
    window.RTCPeerConnection = function(config) {
      if (config && config.iceServers) {
        config.iceServers = filterIceServers(config.iceServers);
      }
      return new RTCPeerConnectionShim(config);
    };
    window.RTCPeerConnection.prototype = RTCPeerConnectionShim.prototype;
  },
  shimReplaceTrack: function(window) {
    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614
    if (window.RTCRtpSender &&
        !('replaceTrack' in window.RTCRtpSender.prototype)) {
      window.RTCRtpSender.prototype.replaceTrack =
          window.RTCRtpSender.prototype.setTrack;
    }
  }
};

},{"../utils":14,"./filtericeservers":9,"./getusermedia":10,"rtcpeerconnection-shim":1}],9:[function(require,module,exports){
/*
 *  Copyright (c) 2018 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */


var utils = require('../utils');
// Edge does not like
// 1) stun: filtered after 14393 unless ?transport=udp is present
// 2) turn: that does not have all of turn:host:port?transport=udp
// 3) turn: with ipv6 addresses
// 4) turn: occurring muliple times
module.exports = function(iceServers, edgeVersion) {
  var hasTurn = false;
  iceServers = JSON.parse(JSON.stringify(iceServers));
  return iceServers.filter(function(server) {
    if (server && (server.urls || server.url)) {
      var urls = server.urls || server.url;
      if (server.url && !server.urls) {
        utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
      }
      var isString = typeof urls === 'string';
      if (isString) {
        urls = [urls];
      }
      urls = urls.filter(function(url) {
        var validTurn = url.indexOf('turn:') === 0 &&
            url.indexOf('transport=udp') !== -1 &&
            url.indexOf('turn:[') === -1 &&
            !hasTurn;

        if (validTurn) {
          hasTurn = true;
          return true;
        }
        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&
            url.indexOf('?transport=udp') === -1;
      });

      delete server.url;
      server.urls = isString ? urls[0] : urls;
      return !!urls.length;
    }
  });
};

},{"../utils":14}],10:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */


// Expose public methods.
module.exports = function(window) {
  var navigator = window && window.navigator;

  var shimError_ = function(e) {
    return {
      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,
      message: e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name;
      }
    };
  };

  // getUserMedia error shim.
  var origGetUserMedia = navigator.mediaDevices.getUserMedia.
      bind(navigator.mediaDevices);
  navigator.mediaDevices.getUserMedia = function(c) {
    return origGetUserMedia(c).catch(function(e) {
      return Promise.reject(shimError_(e));
    });
  };
};

},{}],11:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */


var utils = require('../utils');

module.exports = {
  shimGetUserMedia: require('./getusermedia'),
  shimOnTrack: function(window) {
    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in
        window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {
        get: function() {
          return this._ontrack;
        },
        set: function(f) {
          if (this._ontrack) {
            this.removeEventListener('track', this._ontrack);
            this.removeEventListener('addstream', this._ontrackpoly);
          }
          this.addEventListener('track', this._ontrack = f);
          this.addEventListener('addstream', this._ontrackpoly = function(e) {
            e.stream.getTracks().forEach(function(track) {
              var event = new Event('track');
              event.track = track;
              event.receiver = {track: track};
              event.transceiver = {receiver: event.receiver};
              event.streams = [e.stream];
              this.dispatchEvent(event);
            }.bind(this));
          }.bind(this));
        }
      });
    }
    if (typeof window === 'object' && window.RTCTrackEvent &&
        ('receiver' in window.RTCTrackEvent.prototype) &&
        !('transceiver' in window.RTCTrackEvent.prototype)) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get: function() {
          return {receiver: this.receiver};
        }
      });
    }
  },

  shimSourceObject: function(window) {
    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.
    if (typeof window === 'object') {
      if (window.HTMLMediaElement &&
        !('srcObject' in window.HTMLMediaElement.prototype)) {
        // Shim the srcObject property, once, when HTMLMediaElement is found.
        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {
          get: function() {
            return this.mozSrcObject;
          },
          set: function(stream) {
            this.mozSrcObject = stream;
          }
        });
      }
    }
  },

  shimPeerConnection: function(window) {
    var browserDetails = utils.detectBrowser(window);

    if (typeof window !== 'object' || !(window.RTCPeerConnection ||
        window.mozRTCPeerConnection)) {
      return; // probably media.peerconnection.enabled=false in about:config
    }
    // The RTCPeerConnection object.
    if (!window.RTCPeerConnection) {
      window.RTCPeerConnection = function(pcConfig, pcConstraints) {
        if (browserDetails.version < 38) {
          // .urls is not supported in FF < 38.
          // create RTCIceServers with a single url.
          if (pcConfig && pcConfig.iceServers) {
            var newIceServers = [];
            for (var i = 0; i < pcConfig.iceServers.length; i++) {
              var server = pcConfig.iceServers[i];
              if (server.hasOwnProperty('urls')) {
                for (var j = 0; j < server.urls.length; j++) {
                  var newServer = {
                    url: server.urls[j]
                  };
                  if (server.urls[j].indexOf('turn') === 0) {
                    newServer.username = server.username;
                    newServer.credential = server.credential;
                  }
                  newIceServers.push(newServer);
                }
              } else {
                newIceServers.push(pcConfig.iceServers[i]);
              }
            }
            pcConfig.iceServers = newIceServers;
          }
        }
        return new window.mozRTCPeerConnection(pcConfig, pcConstraints);
      };
      window.RTCPeerConnection.prototype =
          window.mozRTCPeerConnection.prototype;

      // wrap static methods. Currently just generateCertificate.
      if (window.mozRTCPeerConnection.generateCertificate) {
        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
          get: function() {
            return window.mozRTCPeerConnection.generateCertificate;
          }
        });
      }

      window.RTCSessionDescription = window.mozRTCSessionDescription;
      window.RTCIceCandidate = window.mozRTCIceCandidate;
    }

    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']
        .forEach(function(method) {
          var nativeMethod = window.RTCPeerConnection.prototype[method];
          window.RTCPeerConnection.prototype[method] = function() {
            arguments[0] = new ((method === 'addIceCandidate') ?
                window.RTCIceCandidate :
                window.RTCSessionDescription)(arguments[0]);
            return nativeMethod.apply(this, arguments);
          };
        });

    // support for addIceCandidate(null or undefined)
    var nativeAddIceCandidate =
        window.RTCPeerConnection.prototype.addIceCandidate;
    window.RTCPeerConnection.prototype.addIceCandidate = function() {
      if (!arguments[0]) {
        if (arguments[1]) {
          arguments[1].apply(null);
        }
        return Promise.resolve();
      }
      return nativeAddIceCandidate.apply(this, arguments);
    };

    // shim getStats with maplike support
    var makeMapStats = function(stats) {
      var map = new Map();
      Object.keys(stats).forEach(function(key) {
        map.set(key, stats[key]);
        map[key] = stats[key];
      });
      return map;
    };

    var modernStatsTypes = {
      inboundrtp: 'inbound-rtp',
      outboundrtp: 'outbound-rtp',
      candidatepair: 'candidate-pair',
      localcandidate: 'local-candidate',
      remotecandidate: 'remote-candidate'
    };

    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;
    window.RTCPeerConnection.prototype.getStats = function(
      selector,
      onSucc,
      onErr
    ) {
      return nativeGetStats.apply(this, [selector || null])
        .then(function(stats) {
          if (browserDetails.version < 48) {
            stats = makeMapStats(stats);
          }
          if (browserDetails.version < 53 && !onSucc) {
            // Shim only promise getStats with spec-hyphens in type names
            // Leave callback version alone; misc old uses of forEach before Map
            try {
              stats.forEach(function(stat) {
                stat.type = modernStatsTypes[stat.type] || stat.type;
              });
            } catch (e) {
              if (e.name !== 'TypeError') {
                throw e;
              }
              // Avoid TypeError: "type" is read-only, in old versions. 34-43ish
              stats.forEach(function(stat, i) {
                stats.set(i, Object.assign({}, stat, {
                  type: modernStatsTypes[stat.type] || stat.type
                }));
              });
            }
          }
          return stats;
        })
        .then(onSucc, onErr);
    };
  },

  shimSenderGetStats: function(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpSender.prototype) {
      return;
    }
    var origGetSenders = window.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window.RTCPeerConnection.prototype.getSenders = function() {
        var pc = this;
        var senders = origGetSenders.apply(pc, []);
        senders.forEach(function(sender) {
          sender._pc = pc;
        });
        return senders;
      };
    }

    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window.RTCPeerConnection.prototype.addTrack = function() {
        var sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window.RTCRtpSender.prototype.getStats = function() {
      return this.track ? this._pc.getStats(this.track) :
          Promise.resolve(new Map());
    };
  },

  shimReceiverGetStats: function(window) {
    if (!(typeof window === 'object' && window.RTCPeerConnection &&
        window.RTCRtpSender)) {
      return;
    }
    if (window.RTCRtpSender && 'getStats' in window.RTCRtpReceiver.prototype) {
      return;
    }
    var origGetReceivers = window.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window.RTCPeerConnection.prototype.getReceivers = function() {
        var pc = this;
        var receivers = origGetReceivers.apply(pc, []);
        receivers.forEach(function(receiver) {
          receiver._pc = pc;
        });
        return receivers;
      };
    }
    utils.wrapPeerConnectionEvent(window, 'track', function(e) {
      e.receiver._pc = e.srcElement;
      return e;
    });
    window.RTCRtpReceiver.prototype.getStats = function() {
      return this._pc.getStats(this.track);
    };
  },

  shimRemoveStream: function(window) {
    if (!window.RTCPeerConnection ||
        'removeStream' in window.RTCPeerConnection.prototype) {
      return;
    }
    window.RTCPeerConnection.prototype.removeStream = function(stream) {
      var pc = this;
      utils.deprecated('removeStream', 'removeTrack');
      this.getSenders().forEach(function(sender) {
        if (sender.track && stream.getTracks().indexOf(sender.track) !== -1) {
          pc.removeTrack(sender);
        }
      });
    };
  },

  shimRTCDataChannel: function(window) {
    // rename DataChannel to RTCDataChannel (native fix in FF60):
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851
    if (window.DataChannel && !window.RTCDataChannel) {
      window.RTCDataChannel = window.DataChannel;
    }
  },

  shimGetDisplayMedia: function(window, preferredMediaSource) {
    if ('getDisplayMedia' in window.navigator) {
      return;
    }
    navigator.getDisplayMedia = function(constraints) {
      if (!(constraints && constraints.video)) {
        var err = new DOMException('getDisplayMedia without video ' +
            'constraints is undefined');
        err.name = 'NotFoundError';
        // from https://heycam.github.io/webidl/#idl-DOMException-error-names
        err.code = 8;
        return Promise.reject(err);
      }
      if (constraints.video === true) {
        constraints.video = {mediaSource: preferredMediaSource};
      } else {
        constraints.video.mediaSource = preferredMediaSource;
      }
      return navigator.mediaDevices.getUserMedia(constraints);
    };
  }
};

},{"../utils":14,"./getusermedia":12}],12:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */


var utils = require('../utils');
var logging = utils.log;

// Expose public methods.
module.exports = function(window) {
  var browserDetails = utils.detectBrowser(window);
  var navigator = window && window.navigator;
  var MediaStreamTrack = window && window.MediaStreamTrack;

  var shimError_ = function(e) {
    return {
      name: {
        InternalError: 'NotReadableError',
        NotSupportedError: 'TypeError',
        PermissionDeniedError: 'NotAllowedError',
        SecurityError: 'NotAllowedError'
      }[e.name] || e.name,
      message: {
        'The operation is insecure.': 'The request is not allowed by the ' +
        'user agent or the platform in the current context.'
      }[e.message] || e.message,
      constraint: e.constraint,
      toString: function() {
        return this.name + (this.message && ': ') + this.message;
      }
    };
  };

  // getUserMedia constraints shim.
  var getUserMedia_ = function(constraints, onSuccess, onError) {
    var constraintsToFF37_ = function(c) {
      if (typeof c !== 'object' || c.require) {
        return c;
      }
      var require = [];
      Object.keys(c).forEach(function(key) {
        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {
          return;
        }
        var r = c[key] = (typeof c[key] === 'object') ?
            c[key] : {ideal: c[key]};
        if (r.min !== undefined ||
            r.max !== undefined || r.exact !== undefined) {
          require.push(key);
        }
        if (r.exact !== undefined) {
          if (typeof r.exact === 'number') {
            r. min = r.max = r.exact;
          } else {
            c[key] = r.exact;
          }
          delete r.exact;
        }
        if (r.ideal !== undefined) {
          c.advanced = c.advanced || [];
          var oc = {};
          if (typeof r.ideal === 'number') {
            oc[key] = {min: r.ideal, max: r.ideal};
          } else {
            oc[key] = r.ideal;
          }
          c.advanced.push(oc);
          delete r.ideal;
          if (!Object.keys(r).length) {
            delete c[key];
          }
        }
      });
      if (require.length) {
        c.require = require;
      }
      return c;
    };
    constraints = JSON.parse(JSON.stringify(constraints));
    if (browserDetails.version < 38) {
      logging('spec: ' + JSON.stringify(constraints));
      if (constraints.audio) {
        constraints.audio = constraintsToFF37_(constraints.audio);
      }
      if (constraints.video) {
        constraints.video = constraintsToFF37_(constraints.video);
      }
      logging('ff37: ' + JSON.stringify(constraints));
    }
    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {
      onError(shimError_(e));
    });
  };

  // Returns the result of getUserMedia as a Promise.
  var getUserMediaPromise_ = function(constraints) {
    return new Promise(function(resolve, reject) {
      getUserMedia_(constraints, resolve, reject);
    });
  };

  // Shim for mediaDevices on older versions.
  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,
      addEventListener: function() { },
      removeEventListener: function() { }
    };
  }
  navigator.mediaDevices.enumerateDevices =
      navigator.mediaDevices.enumerateDevices || function() {
        return new Promise(function(resolve) {
          var infos = [
            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},
            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}
          ];
          resolve(infos);
        });
      };

  if (browserDetails.version < 41) {
    // Work around http://bugzil.la/1169665
    var orgEnumerateDevices =
        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
    navigator.mediaDevices.enumerateDevices = function() {
      return orgEnumerateDevices().then(undefined, function(e) {
        if (e.name === 'NotFoundError') {
          return [];
        }
        throw e;
      });
    };
  }
  if (browserDetails.version < 49) {
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      return origGetUserMedia(c).then(function(stream) {
        // Work around https://bugzil.la/802326
        if (c.audio && !stream.getAudioTracks().length ||
            c.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach(function(track) {
            track.stop();
          });
          throw new DOMException('The object can not be found here.',
                                 'NotFoundError');
        }
        return stream;
      }, function(e) {
        return Promise.reject(shimError_(e));
      });
    };
  }
  if (!(browserDetails.version > 55 &&
      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {
    var remap = function(obj, a, b) {
      if (a in obj && !(b in obj)) {
        obj[b] = obj[a];
        delete obj[a];
      }
    };

    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      if (typeof c === 'object' && typeof c.audio === 'object') {
        c = JSON.parse(JSON.stringify(c));
        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');
        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');
      }
      return nativeGetUserMedia(c);
    };

    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;
      MediaStreamTrack.prototype.getSettings = function() {
        var obj = nativeGetSettings.apply(this, arguments);
        remap(obj, 'mozAutoGainControl', 'autoGainControl');
        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');
        return obj;
      };
    }

    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
      MediaStreamTrack.prototype.applyConstraints = function(c) {
        if (this.kind === 'audio' && typeof c === 'object') {
          c = JSON.parse(JSON.stringify(c));
          remap(c, 'autoGainControl', 'mozAutoGainControl');
          remap(c, 'noiseSuppression', 'mozNoiseSuppression');
        }
        return nativeApplyConstraints.apply(this, [c]);
      };
    }
  }
  navigator.getUserMedia = function(constraints, onSuccess, onError) {
    if (browserDetails.version < 44) {
      return getUserMedia_(constraints, onSuccess, onError);
    }
    // Replace Firefox 44+'s deprecation warning with unprefixed version.
    utils.deprecated('navigator.getUserMedia',
        'navigator.mediaDevices.getUserMedia');
    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
};

},{"../utils":14}],13:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */

var utils = require('../utils');

module.exports = {
  shimLocalStreamsAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getLocalStreams = function() {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        return this._localStreams;
      };
    }
    if (!('getStreamById' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getStreamById = function(id) {
        var result = null;
        if (this._localStreams) {
          this._localStreams.forEach(function(stream) {
            if (stream.id === id) {
              result = stream;
            }
          });
        }
        if (this._remoteStreams) {
          this._remoteStreams.forEach(function(stream) {
            if (stream.id === id) {
              result = stream;
            }
          });
        }
        return result;
      };
    }
    if (!('addStream' in window.RTCPeerConnection.prototype)) {
      var _addTrack = window.RTCPeerConnection.prototype.addTrack;
      window.RTCPeerConnection.prototype.addStream = function(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        if (this._localStreams.indexOf(stream) === -1) {
          this._localStreams.push(stream);
        }
        var pc = this;
        stream.getTracks().forEach(function(track) {
          _addTrack.call(pc, track, stream);
        });
      };

      window.RTCPeerConnection.prototype.addTrack = function(track, stream) {
        if (stream) {
          if (!this._localStreams) {
            this._localStreams = [stream];
          } else if (this._localStreams.indexOf(stream) === -1) {
            this._localStreams.push(stream);
          }
        }
        return _addTrack.call(this, track, stream);
      };
    }
    if (!('removeStream' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.removeStream = function(stream) {
        if (!this._localStreams) {
          this._localStreams = [];
        }
        var index = this._localStreams.indexOf(stream);
        if (index === -1) {
          return;
        }
        this._localStreams.splice(index, 1);
        var pc = this;
        var tracks = stream.getTracks();
        this.getSenders().forEach(function(sender) {
          if (tracks.indexOf(sender.track) !== -1) {
            pc.removeTrack(sender);
          }
        });
      };
    }
  },
  shimRemoteStreamsAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {
      window.RTCPeerConnection.prototype.getRemoteStreams = function() {
        return this._remoteStreams ? this._remoteStreams : [];
      };
    }
    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {
      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {
        get: function() {
          return this._onaddstream;
        },
        set: function(f) {
          var pc = this;
          if (this._onaddstream) {
            this.removeEventListener('addstream', this._onaddstream);
            this.removeEventListener('track', this._onaddstreampoly);
          }
          this.addEventListener('addstream', this._onaddstream = f);
          this.addEventListener('track', this._onaddstreampoly = function(e) {
            e.streams.forEach(function(stream) {
              if (!pc._remoteStreams) {
                pc._remoteStreams = [];
              }
              if (pc._remoteStreams.indexOf(stream) >= 0) {
                return;
              }
              pc._remoteStreams.push(stream);
              var event = new Event('addstream');
              event.stream = stream;
              pc.dispatchEvent(event);
            });
          });
        }
      });
    }
  },
  shimCallbacksAPI: function(window) {
    if (typeof window !== 'object' || !window.RTCPeerConnection) {
      return;
    }
    var prototype = window.RTCPeerConnection.prototype;
    var createOffer = prototype.createOffer;
    var createAnswer = prototype.createAnswer;
    var setLocalDescription = prototype.setLocalDescription;
    var setRemoteDescription = prototype.setRemoteDescription;
    var addIceCandidate = prototype.addIceCandidate;

    prototype.createOffer = function(successCallback, failureCallback) {
      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      var promise = createOffer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    prototype.createAnswer = function(successCallback, failureCallback) {
      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];
      var promise = createAnswer.apply(this, [options]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };

    var withCallback = function(description, successCallback, failureCallback) {
      var promise = setLocalDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setLocalDescription = withCallback;

    withCallback = function(description, successCallback, failureCallback) {
      var promise = setRemoteDescription.apply(this, [description]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.setRemoteDescription = withCallback;

    withCallback = function(candidate, successCallback, failureCallback) {
      var promise = addIceCandidate.apply(this, [candidate]);
      if (!failureCallback) {
        return promise;
      }
      promise.then(successCallback, failureCallback);
      return Promise.resolve();
    };
    prototype.addIceCandidate = withCallback;
  },
  shimGetUserMedia: function(window) {
    var navigator = window && window.navigator;

    if (!navigator.getUserMedia) {
      if (navigator.webkitGetUserMedia) {
        navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
      } else if (navigator.mediaDevices &&
          navigator.mediaDevices.getUserMedia) {
        navigator.getUserMedia = function(constraints, cb, errcb) {
          navigator.mediaDevices.getUserMedia(constraints)
          .then(cb, errcb);
        }.bind(navigator);
      }
    }
  },
  shimRTCIceServerUrls: function(window) {
    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls
    var OrigPeerConnection = window.RTCPeerConnection;
    window.RTCPeerConnection = function(pcConfig, pcConstraints) {
      if (pcConfig && pcConfig.iceServers) {
        var newIceServers = [];
        for (var i = 0; i < pcConfig.iceServers.length; i++) {
          var server = pcConfig.iceServers[i];
          if (!server.hasOwnProperty('urls') &&
              server.hasOwnProperty('url')) {
            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');
            server = JSON.parse(JSON.stringify(server));
            server.urls = server.url;
            delete server.url;
            newIceServers.push(server);
          } else {
            newIceServers.push(pcConfig.iceServers[i]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
      return new OrigPeerConnection(pcConfig, pcConstraints);
    };
    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
    // wrap static methods. Currently just generateCertificate.
    if ('generateCertificate' in window.RTCPeerConnection) {
      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {
        get: function() {
          return OrigPeerConnection.generateCertificate;
        }
      });
    }
  },
  shimTrackEventTransceiver: function(window) {
    // Add event.transceiver member over deprecated event.receiver
    if (typeof window === 'object' && window.RTCPeerConnection &&
        ('receiver' in window.RTCTrackEvent.prototype) &&
        // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is
        // defined for some reason even when window.RTCTransceiver is not.
        !window.RTCTransceiver) {
      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {
        get: function() {
          return {receiver: this.receiver};
        }
      });
    }
  },

  shimCreateOfferLegacy: function(window) {
    var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;
    window.RTCPeerConnection.prototype.createOffer = function(offerOptions) {
      var pc = this;
      if (offerOptions) {
        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
        }
        var audioTransceiver = pc.getTransceivers().find(function(transceiver) {
          return transceiver.sender.track &&
              transceiver.sender.track.kind === 'audio';
        });
        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
          if (audioTransceiver.direction === 'sendrecv') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('sendonly');
            } else {
              audioTransceiver.direction = 'sendonly';
            }
          } else if (audioTransceiver.direction === 'recvonly') {
            if (audioTransceiver.setDirection) {
              audioTransceiver.setDirection('inactive');
            } else {
              audioTransceiver.direction = 'inactive';
            }
          }
        } else if (offerOptions.offerToReceiveAudio === true &&
            !audioTransceiver) {
          pc.addTransceiver('audio');
        }


        if (typeof offerOptions.offerToReceiveAudio !== 'undefined') {
          // support bit values
          offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
        }
        var videoTransceiver = pc.getTransceivers().find(function(transceiver) {
          return transceiver.sender.track &&
              transceiver.sender.track.kind === 'video';
        });
        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
          if (videoTransceiver.direction === 'sendrecv') {
            videoTransceiver.setDirection('sendonly');
          } else if (videoTransceiver.direction === 'recvonly') {
            videoTransceiver.setDirection('inactive');
          }
        } else if (offerOptions.offerToReceiveVideo === true &&
            !videoTransceiver) {
          pc.addTransceiver('video');
        }
      }
      return origCreateOffer.apply(pc, arguments);
    };
  }
};

},{"../utils":14}],14:[function(require,module,exports){
/*
 *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */
 /* eslint-env node */


var logDisabled_ = true;
var deprecationWarnings_ = true;

/**
 * Extract browser version out of the provided user agent string.
 *
 * @param {!string} uastring userAgent string.
 * @param {!string} expr Regular expression used as match criteria.
 * @param {!number} pos position in the version string to be returned.
 * @return {!number} browser version.
 */
function extractVersion(uastring, expr, pos) {
  var match = uastring.match(expr);
  return match && match.length >= pos && parseInt(match[pos], 10);
}

// Wraps the peerconnection event eventNameToWrap in a function
// which returns the modified event object (or false to prevent
// the event).
function wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {
  if (!window.RTCPeerConnection) {
    return;
  }
  var proto = window.RTCPeerConnection.prototype;
  var nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    var wrappedCallback = function(e) {
      var modifiedEvent = wrapper(e);
      if (modifiedEvent) {
        cb(modifiedEvent);
      }
    };
    this._eventMap = this._eventMap || {};
    this._eventMap[cb] = wrappedCallback;
    return nativeAddEventListener.apply(this, [nativeEventName,
      wrappedCallback]);
  };

  var nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap
        || !this._eventMap[cb]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    var unwrappedCb = this._eventMap[cb];
    delete this._eventMap[cb];
    return nativeRemoveEventListener.apply(this, [nativeEventName,
      unwrappedCb]);
  };

  Object.defineProperty(proto, 'on' + eventNameToWrap, {
    get: function() {
      return this['_on' + eventNameToWrap];
    },
    set: function(cb) {
      if (this['_on' + eventNameToWrap]) {
        this.removeEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap]);
        delete this['_on' + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(eventNameToWrap,
            this['_on' + eventNameToWrap] = cb);
      }
    },
    enumerable: true,
    configurable: true
  });
}

// Utility methods.
module.exports = {
  extractVersion: extractVersion,
  wrapPeerConnectionEvent: wrapPeerConnectionEvent,
  disableLog: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    logDisabled_ = bool;
    return (bool) ? 'adapter.js logging disabled' :
        'adapter.js logging enabled';
  },

  /**
   * Disable or enable deprecation warnings
   * @param {!boolean} bool set to true to disable warnings.
   */
  disableWarnings: function(bool) {
    if (typeof bool !== 'boolean') {
      return new Error('Argument type: ' + typeof bool +
          '. Please use a boolean.');
    }
    deprecationWarnings_ = !bool;
    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');
  },

  log: function() {
    if (typeof window === 'object') {
      if (logDisabled_) {
        return;
      }
      if (typeof console !== 'undefined' && typeof console.log === 'function') {
        console.log.apply(console, arguments);
      }
    }
  },

  /**
   * Shows a deprecation warning suggesting the modern and spec-compatible API.
   */
  deprecated: function(oldMethod, newMethod) {
    if (!deprecationWarnings_) {
      return;
    }
    console.warn(oldMethod + ' is deprecated, please use ' + newMethod +
        ' instead.');
  },

  /**
   * Browser detector.
   *
   * @return {object} result containing browser and version
   *     properties.
   */
  detectBrowser: function(window) {
    var navigator = window && window.navigator;

    // Returned result object.
    var result = {};
    result.browser = null;
    result.version = null;

    // Fail early if it's not a browser
    if (typeof window === 'undefined' || !window.navigator) {
      result.browser = 'Not a browser.';
      return result;
    }

    if (navigator.mozGetUserMedia) { // Firefox.
      result.browser = 'firefox';
      result.version = extractVersion(navigator.userAgent,
          /Firefox\/(\d+)\./, 1);
    } else if (navigator.webkitGetUserMedia) {
      // Chrome, Chromium, Webview, Opera.
      // Version matches Chrome/WebRTC version.
      result.browser = 'chrome';
      result.version = extractVersion(navigator.userAgent,
          /Chrom(e|ium)\/(\d+)\./, 2);
    } else if (navigator.mediaDevices &&
        navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) { // Edge.
      result.browser = 'edge';
      result.version = extractVersion(navigator.userAgent,
          /Edge\/(\d+).(\d+)$/, 2);
    } else if (window.RTCPeerConnection &&
        navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) { // Safari.
      result.browser = 'safari';
      result.version = extractVersion(navigator.userAgent,
          /AppleWebKit\/(\d+)\./, 1);
    } else { // Default fallthrough: not supported.
      result.browser = 'Not a supported browser.';
      return result;
    }

    return result;
  }
};

},{}]},{},[3])(3)
});



// Last Updated On: 2019-05-03 5:27:06 AM UTC

// ________________
// DetectRTC v1.3.9

// Open-Sourced: https://github.com/muaz-khan/DetectRTC

// --------------------------------------------------
// Muaz Khan     - www.MuazKhan.com
// MIT License   - www.WebRTC-Experiment.com/licence
// --------------------------------------------------

!function(){function getBrowserInfo(){var nameOffset,verOffset,ix,nAgt=(navigator.appVersion,navigator.userAgent),browserName=navigator.appName,fullVersion=""+parseFloat(navigator.appVersion),majorVersion=parseInt(navigator.appVersion,10);if(isOpera){browserName="Opera";try{fullVersion=navigator.userAgent.split("OPR/")[1].split(" ")[0],majorVersion=fullVersion.split(".")[0]}catch(e){fullVersion="0.0.0.0",majorVersion=0}}else isIE?(verOffset=nAgt.indexOf("rv:"),verOffset>0?fullVersion=nAgt.substring(verOffset+3):(verOffset=nAgt.indexOf("MSIE"),fullVersion=nAgt.substring(verOffset+5)),browserName="IE"):isChrome?(verOffset=nAgt.indexOf("Chrome"),browserName="Chrome",fullVersion=nAgt.substring(verOffset+7)):isSafari?nAgt.indexOf("CriOS")!==-1?(verOffset=nAgt.indexOf("CriOS"),browserName="Chrome",fullVersion=nAgt.substring(verOffset+6)):nAgt.indexOf("FxiOS")!==-1?(verOffset=nAgt.indexOf("FxiOS"),browserName="Firefox",fullVersion=nAgt.substring(verOffset+6)):(verOffset=nAgt.indexOf("Safari"),browserName="Safari",fullVersion=nAgt.substring(verOffset+7),(verOffset=nAgt.indexOf("Version"))!==-1&&(fullVersion=nAgt.substring(verOffset+8)),navigator.userAgent.indexOf("Version/")!==-1&&(fullVersion=navigator.userAgent.split("Version/")[1].split(" ")[0])):isFirefox?(verOffset=nAgt.indexOf("Firefox"),browserName="Firefox",fullVersion=nAgt.substring(verOffset+8)):(nameOffset=nAgt.lastIndexOf(" ")+1)<(verOffset=nAgt.lastIndexOf("/"))&&(browserName=nAgt.substring(nameOffset,verOffset),fullVersion=nAgt.substring(verOffset+1),browserName.toLowerCase()===browserName.toUpperCase()&&(browserName=navigator.appName));return isEdge&&(browserName="Edge",fullVersion=navigator.userAgent.split("Edge/")[1]),(ix=fullVersion.search(/[; \)]/))!==-1&&(fullVersion=fullVersion.substring(0,ix)),majorVersion=parseInt(""+fullVersion,10),isNaN(majorVersion)&&(fullVersion=""+parseFloat(navigator.appVersion),majorVersion=parseInt(navigator.appVersion,10)),{fullVersion:fullVersion,version:majorVersion,name:browserName,isPrivateBrowsing:!1}}function retry(isDone,next){var currentTrial=0,maxRetry=50,isTimeout=!1,id=window.setInterval(function(){isDone()&&(window.clearInterval(id),next(isTimeout)),currentTrial++>maxRetry&&(window.clearInterval(id),isTimeout=!0,next(isTimeout))},10)}function isIE10OrLater(userAgent){var ua=userAgent.toLowerCase();if(0===ua.indexOf("msie")&&0===ua.indexOf("trident"))return!1;var match=/(?:msie|rv:)\s?([\d\.]+)/.exec(ua);return!!(match&&parseInt(match[1],10)>=10)}function detectPrivateMode(callback){var isPrivate;try{if(window.webkitRequestFileSystem)window.webkitRequestFileSystem(window.TEMPORARY,1,function(){isPrivate=!1},function(e){isPrivate=!0});else if(window.indexedDB&&/Firefox/.test(window.navigator.userAgent)){var db;try{db=window.indexedDB.open("test"),db.onerror=function(){return!0}}catch(e){isPrivate=!0}"undefined"==typeof isPrivate&&retry(function(){return"done"===db.readyState},function(isTimeout){isTimeout||(isPrivate=!db.result)})}else if(isIE10OrLater(window.navigator.userAgent)){isPrivate=!1;try{window.indexedDB||(isPrivate=!0)}catch(e){isPrivate=!0}}else if(window.localStorage&&/Safari/.test(window.navigator.userAgent)){try{window.localStorage.setItem("test",1)}catch(e){isPrivate=!0}"undefined"==typeof isPrivate&&(isPrivate=!1,window.localStorage.removeItem("test"))}}catch(e){isPrivate=!1}retry(function(){return"undefined"!=typeof isPrivate},function(isTimeout){callback(isPrivate)})}function detectDesktopOS(){for(var cs,unknown="-",nVer=navigator.appVersion,nAgt=navigator.userAgent,os=unknown,clientStrings=[{s:"Chrome OS",r:/CrOS/},{s:"Windows 10",r:/(Windows 10.0|Windows NT 10.0)/},{s:"Windows 8.1",r:/(Windows 8.1|Windows NT 6.3)/},{s:"Windows 8",r:/(Windows 8|Windows NT 6.2)/},{s:"Windows 7",r:/(Windows 7|Windows NT 6.1)/},{s:"Windows Vista",r:/Windows NT 6.0/},{s:"Windows Server 2003",r:/Windows NT 5.2/},{s:"Windows XP",r:/(Windows NT 5.1|Windows XP)/},{s:"Windows 2000",r:/(Windows NT 5.0|Windows 2000)/},{s:"Windows ME",r:/(Win 9x 4.90|Windows ME)/},{s:"Windows 98",r:/(Windows 98|Win98)/},{s:"Windows 95",r:/(Windows 95|Win95|Windows_95)/},{s:"Windows NT 4.0",r:/(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/},{s:"Windows CE",r:/Windows CE/},{s:"Windows 3.11",r:/Win16/},{s:"Android",r:/Android/},{s:"Open BSD",r:/OpenBSD/},{s:"Sun OS",r:/SunOS/},{s:"Linux",r:/(Linux|X11)/},{s:"iOS",r:/(iPhone|iPad|iPod)/},{s:"Mac OS X",r:/Mac OS X/},{s:"Mac OS",r:/(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/},{s:"QNX",r:/QNX/},{s:"UNIX",r:/UNIX/},{s:"BeOS",r:/BeOS/},{s:"OS/2",r:/OS\/2/},{s:"Search Bot",r:/(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/}],i=0;cs=clientStrings[i];i++)if(cs.r.test(nAgt)){os=cs.s;break}var osVersion=unknown;switch(/Windows/.test(os)&&(/Windows (.*)/.test(os)&&(osVersion=/Windows (.*)/.exec(os)[1]),os="Windows"),os){case"Mac OS X":/Mac OS X (10[\.\_\d]+)/.test(nAgt)&&(osVersion=/Mac OS X (10[\.\_\d]+)/.exec(nAgt)[1]);break;case"Android":/Android ([\.\_\d]+)/.test(nAgt)&&(osVersion=/Android ([\.\_\d]+)/.exec(nAgt)[1]);break;case"iOS":/OS (\d+)_(\d+)_?(\d+)?/.test(nAgt)&&(osVersion=/OS (\d+)_(\d+)_?(\d+)?/.exec(nVer),osVersion=osVersion[1]+"."+osVersion[2]+"."+(0|osVersion[3]))}return{osName:os,osVersion:osVersion}}function getAndroidVersion(ua){ua=(ua||navigator.userAgent).toLowerCase();var match=ua.match(/android\s([0-9\.]*)/);return!!match&&match[1]}function DetectLocalIPAddress(callback,stream){if(DetectRTC.isWebRTCSupported){var isPublic=!0,isIpv4=!0;getIPs(function(ip){ip?ip.match(regexIpv4Local)?(isPublic=!1,callback("Local: "+ip,isPublic,isIpv4)):ip.match(regexIpv6)?(isIpv4=!1,callback("Public: "+ip,isPublic,isIpv4)):callback("Public: "+ip,isPublic,isIpv4):callback()},stream)}}function getIPs(callback,stream){function handleCandidate(candidate){if(!candidate)return void callback();var match=regexIpv4.exec(candidate);if(match){var ipAddress=match[1],isPublic=candidate.match(regexIpv4Local),isIpv4=!0;void 0===ipDuplicates[ipAddress]&&callback(ipAddress,isPublic,isIpv4),ipDuplicates[ipAddress]=!0}}function afterCreateOffer(){var lines=pc.localDescription.sdp.split("\n");lines.forEach(function(line){line&&0===line.indexOf("a=candidate:")&&handleCandidate(line)})}if("undefined"!=typeof document&&"function"==typeof document.getElementById){var ipDuplicates={},RTCPeerConnection=window.RTCPeerConnection||window.mozRTCPeerConnection||window.webkitRTCPeerConnection;if(!RTCPeerConnection){var iframe=document.getElementById("iframe");if(!iframe)return;var win=iframe.contentWindow;RTCPeerConnection=win.RTCPeerConnection||win.mozRTCPeerConnection||win.webkitRTCPeerConnection}if(RTCPeerConnection){var peerConfig=null;"Chrome"===DetectRTC.browser&&DetectRTC.browser.version<58&&(peerConfig={optional:[{RtpDataChannels:!0}]});var servers={iceServers:[{urls:"stun:stun.l.google.com:19302"}]},pc=new RTCPeerConnection(servers,peerConfig);if(stream&&(pc.addStream?pc.addStream(stream):pc.addTrack&&stream.getTracks()[0]&&pc.addTrack(stream.getTracks()[0],stream)),pc.onicecandidate=function(event){event.candidate&&event.candidate.candidate?handleCandidate(event.candidate.candidate):handleCandidate()},!stream)try{pc.createDataChannel("sctp",{})}catch(e){}DetectRTC.isPromisesSupported?pc.createOffer().then(function(result){pc.setLocalDescription(result).then(afterCreateOffer)}):pc.createOffer(function(result){pc.setLocalDescription(result,afterCreateOffer,function(){})},function(){})}}}function checkDeviceSupport(callback){if(!canEnumerate)return void(callback&&callback());if(!navigator.enumerateDevices&&window.MediaStreamTrack&&window.MediaStreamTrack.getSources&&(navigator.enumerateDevices=window.MediaStreamTrack.getSources.bind(window.MediaStreamTrack)),!navigator.enumerateDevices&&navigator.enumerateDevices&&(navigator.enumerateDevices=navigator.enumerateDevices.bind(navigator)),!navigator.enumerateDevices)return void(callback&&callback());MediaDevices=[],audioInputDevices=[],audioOutputDevices=[],videoInputDevices=[],hasMicrophone=!1,hasSpeakers=!1,hasWebcam=!1,isWebsiteHasMicrophonePermissions=!1,isWebsiteHasWebcamPermissions=!1;var alreadyUsedDevices={};navigator.enumerateDevices(function(devices){devices.forEach(function(_device){var device={};for(var d in _device)try{"function"!=typeof _device[d]&&(device[d]=_device[d])}catch(e){}alreadyUsedDevices[device.deviceId+device.label+device.kind]||("audio"===device.kind&&(device.kind="audioinput"),"video"===device.kind&&(device.kind="videoinput"),device.deviceId||(device.deviceId=device.id),device.id||(device.id=device.deviceId),device.label?("videoinput"!==device.kind||isWebsiteHasWebcamPermissions||(isWebsiteHasWebcamPermissions=!0),"audioinput"!==device.kind||isWebsiteHasMicrophonePermissions||(isWebsiteHasMicrophonePermissions=!0)):(device.isCustomLabel=!0,"videoinput"===device.kind?device.label="Camera "+(videoInputDevices.length+1):"audioinput"===device.kind?device.label="Microphone "+(audioInputDevices.length+1):"audiooutput"===device.kind?device.label="Speaker "+(audioOutputDevices.length+1):device.label="Please invoke getUserMedia once.","undefined"!=typeof DetectRTC&&DetectRTC.browser.isChrome&&DetectRTC.browser.version>=46&&!/^(https:|chrome-extension:)$/g.test(location.protocol||"")&&"undefined"!=typeof document&&"string"==typeof document.domain&&document.domain.search&&document.domain.search(/localhost|127.0./g)===-1&&(device.label="HTTPs is required to get label of this "+device.kind+" device.")),"audioinput"===device.kind&&(hasMicrophone=!0,audioInputDevices.indexOf(device)===-1&&audioInputDevices.push(device)),"audiooutput"===device.kind&&(hasSpeakers=!0,audioOutputDevices.indexOf(device)===-1&&audioOutputDevices.push(device)),"videoinput"===device.kind&&(hasWebcam=!0,videoInputDevices.indexOf(device)===-1&&videoInputDevices.push(device)),MediaDevices.push(device),alreadyUsedDevices[device.deviceId+device.label+device.kind]=device)}),"undefined"!=typeof DetectRTC&&(DetectRTC.MediaDevices=MediaDevices,DetectRTC.hasMicrophone=hasMicrophone,DetectRTC.hasSpeakers=hasSpeakers,DetectRTC.hasWebcam=hasWebcam,DetectRTC.isWebsiteHasWebcamPermissions=isWebsiteHasWebcamPermissions,DetectRTC.isWebsiteHasMicrophonePermissions=isWebsiteHasMicrophonePermissions,DetectRTC.audioInputDevices=audioInputDevices,DetectRTC.audioOutputDevices=audioOutputDevices,DetectRTC.videoInputDevices=videoInputDevices),callback&&callback()})}function getAspectRatio(w,h){function gcd(a,b){return 0==b?a:gcd(b,a%b)}var r=gcd(w,h);return w/r/(h/r)}var browserFakeUserAgent="Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45",isNodejs="object"==typeof process&&"object"==typeof process.versions&&process.versions.node&&!process.browser;if(isNodejs){var version=process.versions.node.toString().replace("v","");browserFakeUserAgent="Nodejs/"+version+" (NodeOS) AppleWebKit/"+version+" (KHTML, like Gecko) Nodejs/"+version+" Nodejs/"+version}!function(that){"undefined"==typeof window&&("undefined"==typeof window&&"undefined"!=typeof global?(global.navigator={userAgent:browserFakeUserAgent,getUserMedia:function(){}},that.window=global):"undefined"==typeof window,"undefined"==typeof location&&(that.location={protocol:"file:",href:"",hash:""}),"undefined"==typeof screen&&(that.screen={width:0,height:0}))}("undefined"!=typeof global?global:window);var navigator=window.navigator;"undefined"!=typeof navigator?("undefined"!=typeof navigator.webkitGetUserMedia&&(navigator.getUserMedia=navigator.webkitGetUserMedia),"undefined"!=typeof navigator.mozGetUserMedia&&(navigator.getUserMedia=navigator.mozGetUserMedia)):navigator={getUserMedia:function(){},userAgent:browserFakeUserAgent};var isMobileDevice=!!/Android|webOS|iPhone|iPad|iPod|BB10|BlackBerry|IEMobile|Opera Mini|Mobile|mobile/i.test(navigator.userAgent||""),isEdge=!(navigator.userAgent.indexOf("Edge")===-1||!navigator.msSaveOrOpenBlob&&!navigator.msSaveBlob),isOpera=!!window.opera||navigator.userAgent.indexOf(" OPR/")>=0,isFirefox=navigator.userAgent.toLowerCase().indexOf("firefox")>-1&&"netscape"in window&&/ rv:/.test(navigator.userAgent),isSafari=/^((?!chrome|android).)*safari/i.test(navigator.userAgent),isChrome=!!window.chrome&&!isOpera,isIE="undefined"!=typeof document&&!!document.documentMode&&!isEdge,isMobile={Android:function(){return navigator.userAgent.match(/Android/i)},BlackBerry:function(){return navigator.userAgent.match(/BlackBerry|BB10/i)},iOS:function(){return navigator.userAgent.match(/iPhone|iPad|iPod/i)},Opera:function(){return navigator.userAgent.match(/Opera Mini/i)},Windows:function(){return navigator.userAgent.match(/IEMobile/i)},any:function(){return isMobile.Android()||isMobile.BlackBerry()||isMobile.iOS()||isMobile.Opera()||isMobile.Windows()},getOsName:function(){var osName="Unknown OS";return isMobile.Android()&&(osName="Android"),isMobile.BlackBerry()&&(osName="BlackBerry"),isMobile.iOS()&&(osName="iOS"),isMobile.Opera()&&(osName="Opera Mini"),isMobile.Windows()&&(osName="Windows"),osName}},osName="Unknown OS",osVersion="Unknown OS Version",osInfo=detectDesktopOS();osInfo&&osInfo.osName&&"-"!=osInfo.osName?(osName=osInfo.osName,osVersion=osInfo.osVersion):isMobile.any()&&(osName=isMobile.getOsName(),"Android"==osName&&(osVersion=getAndroidVersion()));var isNodejs="object"==typeof process&&"object"==typeof process.versions&&process.versions.node;"Unknown OS"===osName&&isNodejs&&(osName="Nodejs",osVersion=process.versions.node.toString().replace("v",""));var isCanvasSupportsStreamCapturing=!1,isVideoSupportsStreamCapturing=!1;["captureStream","mozCaptureStream","webkitCaptureStream"].forEach(function(item){"undefined"!=typeof document&&"function"==typeof document.createElement&&(!isCanvasSupportsStreamCapturing&&item in document.createElement("canvas")&&(isCanvasSupportsStreamCapturing=!0),!isVideoSupportsStreamCapturing&&item in document.createElement("video")&&(isVideoSupportsStreamCapturing=!0))});var regexIpv4Local=/^(192\.168\.|169\.254\.|10\.|172\.(1[6-9]|2\d|3[01]))/,regexIpv4=/([0-9]{1,3}(\.[0-9]{1,3}){3})/,regexIpv6=/[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7}/,MediaDevices=[],audioInputDevices=[],audioOutputDevices=[],videoInputDevices=[];navigator.mediaDevices&&navigator.mediaDevices.enumerateDevices&&(navigator.enumerateDevices=function(callback){var enumerateDevices=navigator.mediaDevices.enumerateDevices();enumerateDevices&&enumerateDevices.then?navigator.mediaDevices.enumerateDevices().then(callback)["catch"](function(){callback([])}):callback([])});var canEnumerate=!1;"undefined"!=typeof MediaStreamTrack&&"getSources"in MediaStreamTrack?canEnumerate=!0:navigator.mediaDevices&&navigator.mediaDevices.enumerateDevices&&(canEnumerate=!0);var hasMicrophone=!1,hasSpeakers=!1,hasWebcam=!1,isWebsiteHasMicrophonePermissions=!1,isWebsiteHasWebcamPermissions=!1,DetectRTC=window.DetectRTC||{};DetectRTC.browser=getBrowserInfo(),detectPrivateMode(function(isPrivateBrowsing){DetectRTC.browser.isPrivateBrowsing=!!isPrivateBrowsing}),DetectRTC.browser["is"+DetectRTC.browser.name]=!0,DetectRTC.osName=osName,DetectRTC.osVersion=osVersion;var isWebRTCSupported=("object"==typeof process&&"object"==typeof process.versions&&process.versions["node-webkit"],!1);["RTCPeerConnection","webkitRTCPeerConnection","mozRTCPeerConnection","RTCIceGatherer"].forEach(function(item){isWebRTCSupported||item in window&&(isWebRTCSupported=!0)}),DetectRTC.isWebRTCSupported=isWebRTCSupported,DetectRTC.isORTCSupported="undefined"!=typeof RTCIceGatherer;var isScreenCapturingSupported=!1;if(DetectRTC.browser.isChrome&&DetectRTC.browser.version>=35?isScreenCapturingSupported=!0:DetectRTC.browser.isFirefox&&DetectRTC.browser.version>=34?isScreenCapturingSupported=!0:DetectRTC.browser.isEdge&&DetectRTC.browser.version>=17?isScreenCapturingSupported=!0:"Android"===DetectRTC.osName&&DetectRTC.browser.isChrome&&(isScreenCapturingSupported=!0),(navigator.getDisplayMedia||navigator.mediaDevices&&navigator.mediaDevices.getDisplayMedia)&&(isScreenCapturingSupported=!0),!/^(https:|chrome-extension:)$/g.test(location.protocol||"")){var isNonLocalHost="undefined"!=typeof document&&"string"==typeof document.domain&&document.domain.search&&document.domain.search(/localhost|127.0./g)===-1;isNonLocalHost&&(DetectRTC.browser.isChrome||DetectRTC.browser.isEdge||DetectRTC.browser.isOpera)?isScreenCapturingSupported=!1:DetectRTC.browser.isFirefox&&(isScreenCapturingSupported=!1)}DetectRTC.isScreenCapturingSupported=isScreenCapturingSupported;var webAudio={isSupported:!1,isCreateMediaStreamSourceSupported:!1};["AudioContext","webkitAudioContext","mozAudioContext","msAudioContext"].forEach(function(item){webAudio.isSupported||item in window&&(webAudio.isSupported=!0,window[item]&&"createMediaStreamSource"in window[item].prototype&&(webAudio.isCreateMediaStreamSourceSupported=!0))}),DetectRTC.isAudioContextSupported=webAudio.isSupported,DetectRTC.isCreateMediaStreamSourceSupported=webAudio.isCreateMediaStreamSourceSupported;var isRtpDataChannelsSupported=!1;DetectRTC.browser.isChrome&&DetectRTC.browser.version>31&&(isRtpDataChannelsSupported=!0),DetectRTC.isRtpDataChannelsSupported=isRtpDataChannelsSupported;var isSCTPSupportd=!1;DetectRTC.browser.isFirefox&&DetectRTC.browser.version>28?isSCTPSupportd=!0:DetectRTC.browser.isChrome&&DetectRTC.browser.version>25?isSCTPSupportd=!0:DetectRTC.browser.isOpera&&DetectRTC.browser.version>=11&&(isSCTPSupportd=!0),DetectRTC.isSctpDataChannelsSupported=isSCTPSupportd,DetectRTC.isMobileDevice=isMobileDevice;var isGetUserMediaSupported=!1;navigator.getUserMedia?isGetUserMediaSupported=!0:navigator.mediaDevices&&navigator.mediaDevices.getUserMedia&&(isGetUserMediaSupported=!0),DetectRTC.browser.isChrome&&DetectRTC.browser.version>=46&&!/^(https:|chrome-extension:)$/g.test(location.protocol||"")&&"undefined"!=typeof document&&"string"==typeof document.domain&&document.domain.search&&document.domain.search(/localhost|127.0./g)===-1&&(isGetUserMediaSupported="Requires HTTPs"),"Nodejs"===DetectRTC.osName&&(isGetUserMediaSupported=!1),DetectRTC.isGetUserMediaSupported=isGetUserMediaSupported;var displayResolution="";if(screen.width){var width=screen.width?screen.width:"",height=screen.height?screen.height:"";displayResolution+=""+width+" x "+height}DetectRTC.displayResolution=displayResolution,DetectRTC.displayAspectRatio=getAspectRatio(screen.width,screen.height).toFixed(2),DetectRTC.isCanvasSupportsStreamCapturing=isCanvasSupportsStreamCapturing,DetectRTC.isVideoSupportsStreamCapturing=isVideoSupportsStreamCapturing,"Chrome"==DetectRTC.browser.name&&DetectRTC.browser.version>=53&&(DetectRTC.isCanvasSupportsStreamCapturing||(DetectRTC.isCanvasSupportsStreamCapturing="Requires chrome flag: enable-experimental-web-platform-features"),DetectRTC.isVideoSupportsStreamCapturing||(DetectRTC.isVideoSupportsStreamCapturing="Requires chrome flag: enable-experimental-web-platform-features")),DetectRTC.DetectLocalIPAddress=DetectLocalIPAddress,DetectRTC.isWebSocketsSupported="WebSocket"in window&&2===window.WebSocket.CLOSING,DetectRTC.isWebSocketsBlocked=!DetectRTC.isWebSocketsSupported,"Nodejs"===DetectRTC.osName&&(DetectRTC.isWebSocketsSupported=!0,DetectRTC.isWebSocketsBlocked=!1),DetectRTC.checkWebSocketsSupport=function(callback){callback=callback||function(){};try{var starttime,websocket=new WebSocket("wss://echo.websocket.org:443/");websocket.onopen=function(){DetectRTC.isWebSocketsBlocked=!1,starttime=(new Date).getTime(),websocket.send("ping")},websocket.onmessage=function(){DetectRTC.WebsocketLatency=(new Date).getTime()-starttime+"ms",callback(),websocket.close(),websocket=null},websocket.onerror=function(){DetectRTC.isWebSocketsBlocked=!0,callback()}}catch(e){DetectRTC.isWebSocketsBlocked=!0,callback()}},DetectRTC.load=function(callback){callback=callback||function(){},checkDeviceSupport(callback)},"undefined"!=typeof MediaDevices?DetectRTC.MediaDevices=MediaDevices:DetectRTC.MediaDevices=[],DetectRTC.hasMicrophone=hasMicrophone,DetectRTC.hasSpeakers=hasSpeakers,DetectRTC.hasWebcam=hasWebcam,DetectRTC.isWebsiteHasWebcamPermissions=isWebsiteHasWebcamPermissions,DetectRTC.isWebsiteHasMicrophonePermissions=isWebsiteHasMicrophonePermissions,DetectRTC.audioInputDevices=audioInputDevices,DetectRTC.audioOutputDevices=audioOutputDevices,DetectRTC.videoInputDevices=videoInputDevices;var isSetSinkIdSupported=!1;"undefined"!=typeof document&&"function"==typeof document.createElement&&"setSinkId"in document.createElement("video")&&(isSetSinkIdSupported=!0),DetectRTC.isSetSinkIdSupported=isSetSinkIdSupported;var isRTPSenderReplaceTracksSupported=!1;DetectRTC.browser.isFirefox&&"undefined"!=typeof mozRTCPeerConnection?"getSenders"in mozRTCPeerConnection.prototype&&(isRTPSenderReplaceTracksSupported=!0):DetectRTC.browser.isChrome&&"undefined"!=typeof webkitRTCPeerConnection&&"getSenders"in webkitRTCPeerConnection.prototype&&(isRTPSenderReplaceTracksSupported=!0),DetectRTC.isRTPSenderReplaceTracksSupported=isRTPSenderReplaceTracksSupported;var isRemoteStreamProcessingSupported=!1;DetectRTC.browser.isFirefox&&DetectRTC.browser.version>38&&(isRemoteStreamProcessingSupported=!0),DetectRTC.isRemoteStreamProcessingSupported=isRemoteStreamProcessingSupported;var isApplyConstraintsSupported=!1;"undefined"!=typeof MediaStreamTrack&&"applyConstraints"in MediaStreamTrack.prototype&&(isApplyConstraintsSupported=!0),DetectRTC.isApplyConstraintsSupported=isApplyConstraintsSupported;var isMultiMonitorScreenCapturingSupported=!1;DetectRTC.browser.isFirefox&&DetectRTC.browser.version>=43&&(isMultiMonitorScreenCapturingSupported=!0),DetectRTC.isMultiMonitorScreenCapturingSupported=isMultiMonitorScreenCapturingSupported,DetectRTC.isPromisesSupported=!!("Promise"in window),DetectRTC.version="1.3.9","undefined"==typeof DetectRTC&&(window.DetectRTC={});var MediaStream=window.MediaStream;"undefined"==typeof MediaStream&&"undefined"!=typeof webkitMediaStream&&(MediaStream=webkitMediaStream),"undefined"!=typeof MediaStream&&"function"==typeof MediaStream?DetectRTC.MediaStream=Object.keys(MediaStream.prototype):DetectRTC.MediaStream=!1,"undefined"!=typeof MediaStreamTrack?DetectRTC.MediaStreamTrack=Object.keys(MediaStreamTrack.prototype):DetectRTC.MediaStreamTrack=!1;var RTCPeerConnection=window.RTCPeerConnection||window.mozRTCPeerConnection||window.webkitRTCPeerConnection;"undefined"!=typeof RTCPeerConnection?DetectRTC.RTCPeerConnection=Object.keys(RTCPeerConnection.prototype):DetectRTC.RTCPeerConnection=!1,window.DetectRTC=DetectRTC,"undefined"!=typeof module&&(module.exports=DetectRTC),"function"==typeof define&&define.amd&&define("DetectRTC",[],function(){return DetectRTC})}();

/*************************
 * Croppie
 * Copyright 2019
 * Foliotek
 * Version: 2.6.4
 *************************/
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define('croppie',factory);
    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {
        // CommonJS
        module.exports = factory();
    } else {
        // Browser globals
        root.Croppie = factory();
    }
}(typeof self !== 'undefined' ? self : this, function () {

    /* Polyfills */
    if (typeof Promise !== 'function') {
        /*! promise-polyfill 3.1.0 */
        !function(a){function b(a,b){return function(){a.apply(b,arguments)}}function c(a){if("object"!==typeof this)throw new TypeError("Promises must be constructed via new");if("function"!==typeof a)throw new TypeError("not a function");this._state=null,this._value=null,this._deferreds=[],i(a,b(e,this),b(f,this))}function d(a){var b=this;return null===this._state?void this._deferreds.push(a):void k(function(){var c=b._state?a.onFulfilled:a.onRejected;if(null===c)return void(b._state?a.resolve:a.reject)(b._value);var d;try{d=c(b._value)}catch(e){return void a.reject(e)}a.resolve(d)})}function e(a){try{if(a===this)throw new TypeError("A promise cannot be resolved with itself.");if(a&&("object"===typeof a||"function"===typeof a)){var c=a.then;if("function"===typeof c)return void i(b(c,a),b(e,this),b(f,this))}this._state=!0,this._value=a,g.call(this)}catch(d){f.call(this,d)}}function f(a){this._state=!1,this._value=a,g.call(this)}function g(){for(var a=0,b=this._deferreds.length;b>a;a++)d.call(this,this._deferreds[a]);this._deferreds=null}function h(a,b,c,d){this.onFulfilled="function"===typeof a?a:null,this.onRejected="function"===typeof b?b:null,this.resolve=c,this.reject=d}function i(a,b,c){var d=!1;try{a(function(a){d||(d=!0,b(a))},function(a){d||(d=!0,c(a))})}catch(e){if(d)return;d=!0,c(e)}}var j=setTimeout,k="function"===typeof setImmediate&&setImmediate||function(a){j(a,1)},l=Array.isArray||function(a){return"[object Array]"===Object.prototype.toString.call(a)};c.prototype["catch"]=function(a){return this.then(null,a)},c.prototype.then=function(a,b){var e=this;return new c(function(c,f){d.call(e,new h(a,b,c,f))})},c.all=function(){var a=Array.prototype.slice.call(1===arguments.length&&l(arguments[0])?arguments[0]:arguments);return new c(function(b,c){function d(f,g){try{if(g&&("object"===typeof g||"function"===typeof g)){var h=g.then;if("function"===typeof h)return void h.call(g,function(a){d(f,a)},c)}a[f]=g,0===--e&&b(a)}catch(i){c(i)}}if(0===a.length)return b([]);for(var e=a.length,f=0;f<a.length;f++)d(f,a[f])})},c.resolve=function(a){return a&&"object"===typeof a&&a.constructor===c?a:new c(function(b){b(a)})},c.reject=function(a){return new c(function(b,c){c(a)})},c.race=function(a){return new c(function(b,c){for(var d=0,e=a.length;e>d;d++)a[d].then(b,c)})},c._setImmediateFn=function(a){k=a},"undefined"!==typeof module&&module.exports?module.exports=c:a.Promise||(a.Promise=c)}(this);
    }

    if (typeof window !== 'undefined' && typeof window.CustomEvent !== "function") {
        (function(){
            function CustomEvent ( event, params ) {
                params = params || { bubbles: false, cancelable: false, detail: undefined };
                var evt = document.createEvent( 'CustomEvent' );
                evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );
                return evt;
            }
            CustomEvent.prototype = window.Event.prototype;
            window.CustomEvent = CustomEvent;
        }());
    }

    if (typeof HTMLCanvasElement !== 'undefined' && !HTMLCanvasElement.prototype.toBlob) {
        Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {
            value: function (callback, type, quality) {
                var binStr = atob( this.toDataURL(type, quality).split(',')[1] ),
                len = binStr.length,
                arr = new Uint8Array(len);

                for (var i=0; i<len; i++ ) {
                    arr[i] = binStr.charCodeAt(i);
                }

                callback( new Blob( [arr], {type: type || 'image/png'} ) );
            }
        });
    }
    /* End Polyfills */

    var cssPrefixes = ['Webkit', 'Moz', 'ms'],
        emptyStyles = typeof document !== 'undefined' ? document.createElement('div').style : {},
        EXIF_NORM = [1,8,3,6],
        EXIF_FLIP = [2,7,4,5],
        CSS_TRANS_ORG,
        CSS_TRANSFORM,
        CSS_USERSELECT;

    function vendorPrefix(prop) {
        if (prop in emptyStyles) {
            return prop;
        }

        var capProp = prop[0].toUpperCase() + prop.slice(1),
            i = cssPrefixes.length;

        while (i--) {
            prop = cssPrefixes[i] + capProp;
            if (prop in emptyStyles) {
                return prop;
            }
        }
    }

    CSS_TRANSFORM = vendorPrefix('transform');
    CSS_TRANS_ORG = vendorPrefix('transformOrigin');
    CSS_USERSELECT = vendorPrefix('userSelect');

    function getExifOffset(ornt, rotate) {
        var arr = EXIF_NORM.indexOf(ornt) > -1 ? EXIF_NORM : EXIF_FLIP,
            index = arr.indexOf(ornt),
            offset = (rotate / 90) % arr.length;// 180 = 2%4 = 2 shift exif by 2 indexes

        return arr[(arr.length + index + (offset % arr.length)) % arr.length];
    }

    // Credits to : Andrew Dupont - http://andrewdupont.net/2009/08/28/deep-extending-objects-in-javascript/
    function deepExtend(destination, source) {
        destination = destination || {};
        for (var property in source) {
            if (source[property] && source[property].constructor && source[property].constructor === Object) {
                destination[property] = destination[property] || {};
                deepExtend(destination[property], source[property]);
            } else {
                destination[property] = source[property];
            }
        }
        return destination;
    }

    function clone(object) {
        return deepExtend({}, object);
    }

    function debounce(func, wait, immediate) {
        var timeout;
        return function () {
            var context = this, args = arguments;
            var later = function () {
                timeout = null;
                if (!immediate) func.apply(context, args);
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func.apply(context, args);
        };
    }

    function dispatchChange(element) {
        if ("createEvent" in document) {
            var evt = document.createEvent("HTMLEvents");
            evt.initEvent("change", false, true);
            element.dispatchEvent(evt);
        }
        else {
            element.fireEvent("onchange");
        }
    }

    //http://jsperf.com/vanilla-css
    function css(el, styles, val) {
        if (typeof (styles) === 'string') {
            var tmp = styles;
            styles = {};
            styles[tmp] = val;
        }

        for (var prop in styles) {
            el.style[prop] = styles[prop];
        }
    }

    function addClass(el, c) {
        if (el.classList) {
            el.classList.add(c);
        }
        else {
            el.className += ' ' + c;
        }
    }

    function removeClass(el, c) {
        if (el.classList) {
            el.classList.remove(c);
        }
        else {
            el.className = el.className.replace(c, '');
        }
    }

    function setAttributes(el, attrs) {
        for (var key in attrs) {
            el.setAttribute(key, attrs[key]);
        }
    }

    function num(v) {
        return parseInt(v, 10);
    }

    /* Utilities */
    function loadImage(src, doExif) {
        if (!src) { throw 'Source image missing'; }

        var img = new Image();
        img.style.opacity = '0';
        return new Promise(function (resolve, reject) {
            function _resolve() {
                img.style.opacity = '1';
                setTimeout(function () {
                    resolve(img);
                }, 1);
            }

            img.removeAttribute('crossOrigin');
            if (src.match(/^https?:\/\/|^\/\//)) {
                img.setAttribute('crossOrigin', 'anonymous');
            }

            img.onload = function () {
                if (doExif) {
                    EXIF.getData(img, function () {
                        _resolve();
                    });
                }
                else {
                    _resolve();
                }
            };
            img.onerror = function (ev) {
                img.style.opacity = 1;
                setTimeout(function () {
                    reject(ev);
                }, 1);
            };
            img.src = src;
        });
    }

    function naturalImageDimensions(img, ornt) {
        var w = img.naturalWidth;
        var h = img.naturalHeight;
        var orient = ornt || getExifOrientation(img);
        if (orient && orient >= 5) {
            var x= w;
            w = h;
            h = x;
        }
        return { width: w, height: h };
    }

    /* CSS Transform Prototype */
    var TRANSLATE_OPTS = {
        'translate3d': {
            suffix: ', 0px'
        },
        'translate': {
            suffix: ''
        }
    };
    var Transform = function (x, y, scale) {
        this.x = parseFloat(x);
        this.y = parseFloat(y);
        this.scale = parseFloat(scale);
    };

    Transform.parse = function (v) {
        if (v.style) {
            return Transform.parse(v.style[CSS_TRANSFORM]);
        }
        else if (v.indexOf('matrix') > -1 || v.indexOf('none') > -1) {
            return Transform.fromMatrix(v);
        }
        else {
            return Transform.fromString(v);
        }
    };

    Transform.fromMatrix = function (v) {
        var vals = v.substring(7).split(',');
        if (!vals.length || v === 'none') {
            vals = [1, 0, 0, 1, 0, 0];
        }

        return new Transform(num(vals[4]), num(vals[5]), parseFloat(vals[0]));
    };

    Transform.fromString = function (v) {
        var values = v.split(') '),
            translate = values[0].substring(Croppie.globals.translate.length + 1).split(','),
            scale = values.length > 1 ? values[1].substring(6) : 1,
            x = translate.length > 1 ? translate[0] : 0,
            y = translate.length > 1 ? translate[1] : 0;

        return new Transform(x, y, scale);
    };

    Transform.prototype.toString = function () {
        var suffix = TRANSLATE_OPTS[Croppie.globals.translate].suffix || '';
        return Croppie.globals.translate + '(' + this.x + 'px, ' + this.y + 'px' + suffix + ') scale(' + this.scale + ')';
    };

    var TransformOrigin = function (el) {
        if (!el || !el.style[CSS_TRANS_ORG]) {
            this.x = 0;
            this.y = 0;
            return;
        }
        var css = el.style[CSS_TRANS_ORG].split(' ');
        this.x = parseFloat(css[0]);
        this.y = parseFloat(css[1]);
    };

    TransformOrigin.prototype.toString = function () {
        return this.x + 'px ' + this.y + 'px';
    };

    function getExifOrientation (img) {
        return img.exifdata && img.exifdata.Orientation ? num(img.exifdata.Orientation) : 1;
    }

    function drawCanvas(canvas, img, orientation) {
        var width = img.width,
            height = img.height,
            ctx = canvas.getContext('2d');

        canvas.width = img.width;
        canvas.height = img.height;

        ctx.save();
        switch (orientation) {
          case 2:
             ctx.translate(width, 0);
             ctx.scale(-1, 1);
             break;

          case 3:
              ctx.translate(width, height);
              ctx.rotate(180*Math.PI/180);
              break;

          case 4:
              ctx.translate(0, height);
              ctx.scale(1, -1);
              break;

          case 5:
              canvas.width = height;
              canvas.height = width;
              ctx.rotate(90*Math.PI/180);
              ctx.scale(1, -1);
              break;

          case 6:
              canvas.width = height;
              canvas.height = width;
              ctx.rotate(90*Math.PI/180);
              ctx.translate(0, -height);
              break;

          case 7:
              canvas.width = height;
              canvas.height = width;
              ctx.rotate(-90*Math.PI/180);
              ctx.translate(-width, height);
              ctx.scale(1, -1);
              break;

          case 8:
              canvas.width = height;
              canvas.height = width;
              ctx.translate(0, width);
              ctx.rotate(-90*Math.PI/180);
              break;
        }
        ctx.drawImage(img, 0,0, width, height);
        ctx.restore();
    }

    /* Private Methods */
    function _create() {
        var self = this,
            contClass = 'croppie-container',
            customViewportClass = self.options.viewport.type ? 'cr-vp-' + self.options.viewport.type : null,
            boundary, img, viewport, overlay, bw, bh;

        self.options.useCanvas = self.options.enableOrientation || _hasExif.call(self);
        // Properties on class
        self.data = {};
        self.elements = {};

        boundary = self.elements.boundary = document.createElement('div');
        viewport = self.elements.viewport = document.createElement('div');
        img = self.elements.img = document.createElement('img');
        overlay = self.elements.overlay = document.createElement('div');

        if (self.options.useCanvas) {
            self.elements.canvas = document.createElement('canvas');
            self.elements.preview = self.elements.canvas;
        }
        else {
            self.elements.preview = img;
        }

        addClass(boundary, 'cr-boundary');
        boundary.setAttribute('aria-dropeffect', 'none');
        bw = self.options.boundary.width;
        bh = self.options.boundary.height;
        css(boundary, {
            width: (bw + (isNaN(bw) ? '' : 'px')),
            height: (bh + (isNaN(bh) ? '' : 'px'))
        });

        addClass(viewport, 'cr-viewport');
        if (customViewportClass) {
            addClass(viewport, customViewportClass);
        }
        css(viewport, {
            width: self.options.viewport.width + 'px',
            height: self.options.viewport.height + 'px'
        });
        viewport.setAttribute('tabindex', 0);

        addClass(self.elements.preview, 'cr-image');
        setAttributes(self.elements.preview, { 'alt': 'preview', 'aria-grabbed': 'false' });
        addClass(overlay, 'cr-overlay');

        self.element.appendChild(boundary);
        boundary.appendChild(self.elements.preview);
        boundary.appendChild(viewport);
        boundary.appendChild(overlay);

        addClass(self.element, contClass);
        if (self.options.customClass) {
            addClass(self.element, self.options.customClass);
        }

        _initDraggable.call(this);

        if (self.options.enableZoom) {
            _initializeZoom.call(self);
        }

        // if (self.options.enableOrientation) {
        //     _initRotationControls.call(self);
        // }

        if (self.options.enableResize) {
            _initializeResize.call(self);
        }
    }

    // function _initRotationControls () {
    //     var self = this,
    //         wrap, btnLeft, btnRight, iLeft, iRight;

    //     wrap = document.createElement('div');
    //     self.elements.orientationBtnLeft = btnLeft = document.createElement('button');
    //     self.elements.orientationBtnRight = btnRight = document.createElement('button');

    //     wrap.appendChild(btnLeft);
    //     wrap.appendChild(btnRight);

    //     iLeft = document.createElement('i');
    //     iRight = document.createElement('i');
    //     btnLeft.appendChild(iLeft);
    //     btnRight.appendChild(iRight);

    //     addClass(wrap, 'cr-rotate-controls');
    //     addClass(btnLeft, 'cr-rotate-l');
    //     addClass(btnRight, 'cr-rotate-r');

    //     self.elements.boundary.appendChild(wrap);

    //     btnLeft.addEventListener('click', function () {
    //         self.rotate(-90);
    //     });
    //     btnRight.addEventListener('click', function () {
    //         self.rotate(90);
    //     });
    // }

    function _hasExif() {
        return this.options.enableExif && window.EXIF;
    }

    function _initializeResize () {
        var self = this;
        var wrap = document.createElement('div');
        var isDragging = false;
        var direction;
        var originalX;
        var originalY;
        var minSize = 50;
        var maxWidth;
        var maxHeight;
        var vr;
        var hr;

        addClass(wrap, 'cr-resizer');
        css(wrap, {
            width: this.options.viewport.width + 'px',
            height: this.options.viewport.height + 'px'
        });

        if (this.options.resizeControls.height) {
            vr = document.createElement('div');
            addClass(vr, 'cr-resizer-vertical');
            wrap.appendChild(vr);
        }

        if (this.options.resizeControls.width) {
            hr = document.createElement('div');
            addClass(hr, 'cr-resizer-horisontal');
            wrap.appendChild(hr);
        }

        function mouseDown(ev) {
            if (ev.button !== undefined && ev.button !== 0) return;

            ev.preventDefault();
            if (isDragging) {
                return;
            }

            var overlayRect = self.elements.overlay.getBoundingClientRect();

            isDragging = true;
            originalX = ev.pageX;
            originalY = ev.pageY;
            direction = ev.currentTarget.className.indexOf('vertical') !== -1 ? 'v' : 'h';
            maxWidth = overlayRect.width;
            maxHeight = overlayRect.height;

            if (ev.touches) {
                var touches = ev.touches[0];
                originalX = touches.pageX;
                originalY = touches.pageY;
            }

            window.addEventListener('mousemove', mouseMove);
            window.addEventListener('touchmove', mouseMove);
            window.addEventListener('mouseup', mouseUp);
            window.addEventListener('touchend', mouseUp);
            document.body.style[CSS_USERSELECT] = 'none';
        }

        function mouseMove(ev) {
            var pageX = ev.pageX;
            var pageY = ev.pageY;

            ev.preventDefault();

            if (ev.touches) {
                var touches = ev.touches[0];
                pageX = touches.pageX;
                pageY = touches.pageY;
            }

            var deltaX = pageX - originalX;
            var deltaY = pageY - originalY;
            var newHeight = self.options.viewport.height + deltaY;
            var newWidth = self.options.viewport.width + deltaX;

            if (direction === 'v' && newHeight >= minSize && newHeight <= maxHeight) {
                css(wrap, {
                    height: newHeight + 'px'
                });

                self.options.boundary.height += deltaY;
                css(self.elements.boundary, {
                    height: self.options.boundary.height + 'px'
                });

                self.options.viewport.height += deltaY;
                css(self.elements.viewport, {
                    height: self.options.viewport.height + 'px'
                });
            }
            else if (direction === 'h' && newWidth >= minSize && newWidth <= maxWidth) {
                css(wrap, {
                    width: newWidth + 'px'
                });

                self.options.boundary.width += deltaX;
                css(self.elements.boundary, {
                    width: self.options.boundary.width + 'px'
                });

                self.options.viewport.width += deltaX;
                css(self.elements.viewport, {
                    width: self.options.viewport.width + 'px'
                });
            }

            _updateOverlay.call(self);
            _updateZoomLimits.call(self);
            _updateCenterPoint.call(self);
            _triggerUpdate.call(self);
            originalY = pageY;
            originalX = pageX;
        }

        function mouseUp() {
            isDragging = false;
            window.removeEventListener('mousemove', mouseMove);
            window.removeEventListener('touchmove', mouseMove);
            window.removeEventListener('mouseup', mouseUp);
            window.removeEventListener('touchend', mouseUp);
            document.body.style[CSS_USERSELECT] = '';
        }

        if (vr) {
            vr.addEventListener('mousedown', mouseDown);
            vr.addEventListener('touchstart', mouseDown);
        }

        if (hr) {
            hr.addEventListener('mousedown', mouseDown);
            hr.addEventListener('touchstart', mouseDown);
        }

        this.elements.boundary.appendChild(wrap);
    }

    function _setZoomerVal(v) {
        if (this.options.enableZoom) {
            var z = this.elements.zoomer,
                val = fix(v, 4);

            z.value = Math.max(parseFloat(z.min), Math.min(parseFloat(z.max), val)).toString();
        }
    }

    function _initializeZoom() {
        var self = this,
            wrap = self.elements.zoomerWrap = document.createElement('div'),
            zoomer = self.elements.zoomer = document.createElement('input');

        addClass(wrap, 'cr-slider-wrap');
        addClass(zoomer, 'cr-slider');
        zoomer.type = 'range';
        zoomer.step = '0.0001';
        zoomer.value = '1';
        zoomer.setAttribute('min', '0');
        zoomer.setAttribute('max', '1');

        zoomer.style.display = self.options.showZoomer ? '' : 'none';
        zoomer.setAttribute('aria-label', 'zoom');
        self.element.appendChild(wrap);
        wrap.appendChild(zoomer);

        self._currentZoom = 0.5;

        function change() {
            _onZoom.call(self, {
                value: parseFloat(zoomer.value),
                origin: new TransformOrigin(self.elements.preview),
                viewportRect: self.elements.viewport.getBoundingClientRect(),
                transform: Transform.parse(self.elements.preview)
            });
        }

        function scroll(ev) {
            var delta, targetZoom;

            if(self.options.mouseWheelZoom === 'ctrl' && ev.ctrlKey !== true){
              return 0;
            } else if (ev.wheelDelta) {
                delta = ev.wheelDelta / 1200; //wheelDelta min: -120 max: 120 // max x 10 x 2
            } else if (ev.deltaY) {
                delta = ev.deltaY / 1060; //deltaY min: -53 max: 53 // max x 10 x 2
            } else if (ev.detail) {
                delta = ev.detail / -60; //delta min: -3 max: 3 // max x 10 x 2
            } else {
                delta = 0;
            }

            targetZoom = self._currentZoom + (delta * self._currentZoom);

            ev.preventDefault();
            _setZoomerVal.call(self, targetZoom);
            change.call(self);
        }

        self.elements.zoomer.addEventListener('input', change);// this is being fired twice on keypress
        self.elements.zoomer.addEventListener('change', change);

        if (self.options.mouseWheelZoom) {
            self.elements.boundary.addEventListener('mousewheel', scroll);
            self.elements.boundary.addEventListener('DOMMouseScroll', scroll);
        }
    }

    function _onZoom(ui) {
        var self = this,
            transform = ui ? ui.transform : Transform.parse(self.elements.preview),
            vpRect = ui ? ui.viewportRect : self.elements.viewport.getBoundingClientRect(),
            origin = ui ? ui.origin : new TransformOrigin(self.elements.preview);

        function applyCss() {
            var transCss = {};
            transCss[CSS_TRANSFORM] = transform.toString();
            transCss[CSS_TRANS_ORG] = origin.toString();
            css(self.elements.preview, transCss);
        }

        self._currentZoom = ui ? ui.value : self._currentZoom;
        transform.scale = self._currentZoom;
        self.elements.zoomer.setAttribute('aria-valuenow', self._currentZoom);
        applyCss();

        if (self.options.enforceBoundary) {
            var boundaries = _getVirtualBoundaries.call(self, vpRect),
                transBoundaries = boundaries.translate,
                oBoundaries = boundaries.origin;

            if (transform.x >= transBoundaries.maxX) {
                origin.x = oBoundaries.minX;
                transform.x = transBoundaries.maxX;
            }

            if (transform.x <= transBoundaries.minX) {
                origin.x = oBoundaries.maxX;
                transform.x = transBoundaries.minX;
            }

            if (transform.y >= transBoundaries.maxY) {
                origin.y = oBoundaries.minY;
                transform.y = transBoundaries.maxY;
            }

            if (transform.y <= transBoundaries.minY) {
                origin.y = oBoundaries.maxY;
                transform.y = transBoundaries.minY;
            }
        }
        applyCss();
        _debouncedOverlay.call(self);
        _triggerUpdate.call(self);
    }

    function _getVirtualBoundaries(viewport) {
        var self = this,
            scale = self._currentZoom,
            vpWidth = viewport.width,
            vpHeight = viewport.height,
            centerFromBoundaryX = self.elements.boundary.clientWidth / 2,
            centerFromBoundaryY = self.elements.boundary.clientHeight / 2,
            imgRect = self.elements.preview.getBoundingClientRect(),
            curImgWidth = imgRect.width,
            curImgHeight = imgRect.height,
            halfWidth = vpWidth / 2,
            halfHeight = vpHeight / 2;

        var maxX = ((halfWidth / scale) - centerFromBoundaryX) * -1;
        var minX = maxX - ((curImgWidth * (1 / scale)) - (vpWidth * (1 / scale)));

        var maxY = ((halfHeight / scale) - centerFromBoundaryY) * -1;
        var minY = maxY - ((curImgHeight * (1 / scale)) - (vpHeight * (1 / scale)));

        var originMinX = (1 / scale) * halfWidth;
        var originMaxX = (curImgWidth * (1 / scale)) - originMinX;

        var originMinY = (1 / scale) * halfHeight;
        var originMaxY = (curImgHeight * (1 / scale)) - originMinY;

        return {
            translate: {
                maxX: maxX,
                minX: minX,
                maxY: maxY,
                minY: minY
            },
            origin: {
                maxX: originMaxX,
                minX: originMinX,
                maxY: originMaxY,
                minY: originMinY
            }
        };
    }

    function _updateCenterPoint(rotate) {
        var self = this,
            scale = self._currentZoom,
            data = self.elements.preview.getBoundingClientRect(),
            vpData = self.elements.viewport.getBoundingClientRect(),
            transform = Transform.parse(self.elements.preview.style[CSS_TRANSFORM]),
            pc = new TransformOrigin(self.elements.preview),
            top = (vpData.top - data.top) + (vpData.height / 2),
            left = (vpData.left - data.left) + (vpData.width / 2),
            center = {},
            adj = {};

        if (rotate) {
            var cx = pc.x;
            var cy = pc.y;
            var tx = transform.x;
            var ty = transform.y;

            center.y = cx;
            center.x = cy;
            transform.y = tx;
            transform.x = ty;
        }
        else {
            center.y = top / scale;
            center.x = left / scale;

            adj.y = (center.y - pc.y) * (1 - scale);
            adj.x = (center.x - pc.x) * (1 - scale);

            transform.x -= adj.x;
            transform.y -= adj.y;
        }

        var newCss = {};
        newCss[CSS_TRANS_ORG] = center.x + 'px ' + center.y + 'px';
        newCss[CSS_TRANSFORM] = transform.toString();
        css(self.elements.preview, newCss);
    }

    function _initDraggable() {
        var self = this,
            isDragging = false,
            originalX,
            originalY,
            originalDistance,
            vpRect,
            transform;

        function assignTransformCoordinates(deltaX, deltaY) {
            var imgRect = self.elements.preview.getBoundingClientRect(),
                top = transform.y + deltaY,
                left = transform.x + deltaX;


            if (self.options.enforceBoundary) {
                if (vpRect.top > imgRect.top + deltaY && vpRect.bottom < imgRect.bottom + deltaY) {
                    transform.y = top;
                }

                if (vpRect.left > imgRect.left + deltaX && vpRect.right < imgRect.right + deltaX) {
                    transform.x = left;
                }
            }
            else {
                transform.y = top;
                transform.x = left;
            }
        }

        function toggleGrabState(isDragging) {
          self.elements.preview.setAttribute('aria-grabbed', isDragging);
          self.elements.boundary.setAttribute('aria-dropeffect', isDragging? 'move': 'none');
        }

        function keyDown(ev) {
            var LEFT_ARROW  = 37,
                UP_ARROW    = 38,
                RIGHT_ARROW = 39,
                DOWN_ARROW  = 40;

            if (ev.shiftKey && (ev.keyCode === UP_ARROW || ev.keyCode === DOWN_ARROW)) {
                var zoom;
                if (ev.keyCode === UP_ARROW) {
                    zoom = parseFloat(self.elements.zoomer.value) + parseFloat(self.elements.zoomer.step)
                }
                else {
                    zoom = parseFloat(self.elements.zoomer.value) - parseFloat(self.elements.zoomer.step)
                }
                self.setZoom(zoom);
            }
            else if (self.options.enableKeyMovement && (ev.keyCode >= 37 && ev.keyCode <= 40)) {
                ev.preventDefault();
                var movement = parseKeyDown(ev.keyCode);

                transform = Transform.parse(self.elements.preview);
                document.body.style[CSS_USERSELECT] = 'none';
                vpRect = self.elements.viewport.getBoundingClientRect();
                keyMove(movement);
            }

            function parseKeyDown(key) {
                switch (key) {
                    case LEFT_ARROW:
                        return [1, 0];
                    case UP_ARROW:
                        return [0, 1];
                    case RIGHT_ARROW:
                        return [-1, 0];
                    case DOWN_ARROW:
                        return [0, -1];
                }
            }
        }

        function keyMove(movement) {
            var deltaX = movement[0],
                deltaY = movement[1],
                newCss = {};

            assignTransformCoordinates(deltaX, deltaY);

            newCss[CSS_TRANSFORM] = transform.toString();
            css(self.elements.preview, newCss);
            _updateOverlay.call(self);
            document.body.style[CSS_USERSELECT] = '';
            _updateCenterPoint.call(self);
            _triggerUpdate.call(self);
            originalDistance = 0;
        }

        function mouseDown(ev) {
            if (ev.button !== undefined && ev.button !== 0) return;

            ev.preventDefault();
            if (isDragging) return;
            isDragging = true;
            originalX = ev.pageX;
            originalY = ev.pageY;

            if (ev.touches) {
                var touches = ev.touches[0];
                originalX = touches.pageX;
                originalY = touches.pageY;
            }
            toggleGrabState(isDragging);
            transform = Transform.parse(self.elements.preview);
            window.addEventListener('mousemove', mouseMove);
            window.addEventListener('touchmove', mouseMove);
            window.addEventListener('mouseup', mouseUp);
            window.addEventListener('touchend', mouseUp);
            document.body.style[CSS_USERSELECT] = 'none';
            vpRect = self.elements.viewport.getBoundingClientRect();
        }

        function mouseMove(ev) {
            ev.preventDefault();
            var pageX = ev.pageX,
                pageY = ev.pageY;

            if (ev.touches) {
                var touches = ev.touches[0];
                pageX = touches.pageX;
                pageY = touches.pageY;
            }

            var deltaX = pageX - originalX,
                deltaY = pageY - originalY,
                newCss = {};

            if (ev.type === 'touchmove') {
                if (ev.touches.length > 1) {
                    var touch1 = ev.touches[0];
                    var touch2 = ev.touches[1];
                    var dist = Math.sqrt((touch1.pageX - touch2.pageX) * (touch1.pageX - touch2.pageX) + (touch1.pageY - touch2.pageY) * (touch1.pageY - touch2.pageY));

                    if (!originalDistance) {
                        originalDistance = dist / self._currentZoom;
                    }

                    var scale = dist / originalDistance;

                    _setZoomerVal.call(self, scale);
                    dispatchChange(self.elements.zoomer);
                    return;
                }
            }

            assignTransformCoordinates(deltaX, deltaY);

            newCss[CSS_TRANSFORM] = transform.toString();
            css(self.elements.preview, newCss);
            _updateOverlay.call(self);
            originalY = pageY;
            originalX = pageX;
        }

        function mouseUp() {
            isDragging = false;
            toggleGrabState(isDragging);
            window.removeEventListener('mousemove', mouseMove);
            window.removeEventListener('touchmove', mouseMove);
            window.removeEventListener('mouseup', mouseUp);
            window.removeEventListener('touchend', mouseUp);
            document.body.style[CSS_USERSELECT] = '';
            _updateCenterPoint.call(self);
            _triggerUpdate.call(self);
            originalDistance = 0;
        }

        self.elements.overlay.addEventListener('mousedown', mouseDown);
        self.elements.viewport.addEventListener('keydown', keyDown);
        self.elements.overlay.addEventListener('touchstart', mouseDown);
    }

    function _updateOverlay() {
        if (!this.elements) return; // since this is debounced, it can be fired after destroy
        var self = this,
            boundRect = self.elements.boundary.getBoundingClientRect(),
            imgData = self.elements.preview.getBoundingClientRect();

        css(self.elements.overlay, {
            width: imgData.width + 'px',
            height: imgData.height + 'px',
            top: (imgData.top - boundRect.top) + 'px',
            left: (imgData.left - boundRect.left) + 'px'
        });
    }
    var _debouncedOverlay = debounce(_updateOverlay, 500);

    function _triggerUpdate() {
        var self = this,
            data = self.get();

        if (!_isVisible.call(self)) {
            return;
        }

        self.options.update.call(self, data);
        if (self.$ && typeof Prototype === 'undefined') {
            self.$(self.element).trigger('update.croppie', data);
        }
        else {
            var ev;
            if (window.CustomEvent) {
                ev = new CustomEvent('update', { detail: data });
            } else {
                ev = document.createEvent('CustomEvent');
                ev.initCustomEvent('update', true, true, data);
            }

            self.element.dispatchEvent(ev);
        }
    }

    function _isVisible() {
        return this.elements.preview.offsetHeight > 0 && this.elements.preview.offsetWidth > 0;
    }

    function _updatePropertiesFromImage() {
        var self = this,
            initialZoom = 1,
            cssReset = {},
            img = self.elements.preview,
            imgData,
            transformReset = new Transform(0, 0, initialZoom),
            originReset = new TransformOrigin(),
            isVisible = _isVisible.call(self);

        if (!isVisible || self.data.bound) {// if the croppie isn't visible or it doesn't need binding
            return;
        }

        self.data.bound = true;
        cssReset[CSS_TRANSFORM] = transformReset.toString();
        cssReset[CSS_TRANS_ORG] = originReset.toString();
        cssReset['opacity'] = 1;
        css(img, cssReset);

        imgData = self.elements.preview.getBoundingClientRect();

        self._originalImageWidth = imgData.width;
        self._originalImageHeight = imgData.height;
        self.data.orientation = _hasExif.call(self) ? getExifOrientation(self.elements.img) : self.data.orientation;

        if (self.options.enableZoom) {
            _updateZoomLimits.call(self, true);
        }
        else {
            self._currentZoom = initialZoom;
        }

        transformReset.scale = self._currentZoom;
        cssReset[CSS_TRANSFORM] = transformReset.toString();
        css(img, cssReset);

        if (self.data.points.length) {
            _bindPoints.call(self, self.data.points);
        }
        else {
            _centerImage.call(self);
        }

        _updateCenterPoint.call(self);
        _updateOverlay.call(self);
    }

    function _updateZoomLimits (initial) {
        var self = this,
            minZoom = Math.max(self.options.minZoom, 0) || 0,
            maxZoom = self.options.maxZoom || 1.5,
            initialZoom,
            defaultInitialZoom,
            zoomer = self.elements.zoomer,
            scale = parseFloat(zoomer.value),
            boundaryData = self.elements.boundary.getBoundingClientRect(),
            imgData = naturalImageDimensions(self.elements.img, self.data.orientation),
            vpData = self.elements.viewport.getBoundingClientRect(),
            minW,
            minH;
        if (self.options.enforceBoundary) {
            minW = vpData.width / imgData.width;
            minH = vpData.height / imgData.height;
            minZoom = Math.max(minW, minH);
        }

        if (minZoom >= maxZoom) {
            maxZoom = minZoom + 1;
        }
        var min = fix(minZoom, 4);
        console.log('zoomer min:');
        console.log(min);
        zoomer.min = min;
        zoomer.max = fix(maxZoom, 4);

        if (!initial && (scale < zoomer.min || scale > zoomer.max)) {
            _setZoomerVal.call(self, scale < zoomer.min ? zoomer.min : zoomer.max);
        }
        else if (initial) {
            // defaultInitialZoom = self.options.initialZoom ? self.options.initialZoom : Math.max((boundaryData.width / imgData.width), (boundaryData.height / imgData.height));
            defaultInitialZoom = Math.max((boundaryData.width / imgData.width), (boundaryData.height / imgData.height));
            initialZoom = self.data.boundZoom !== null ? self.data.boundZoom : defaultInitialZoom;
            _setZoomerVal.call(self, initialZoom);
        }

        dispatchChange(zoomer);
    }

    function _bindPoints(points) {
        if (points.length !== 4) {
            throw "Croppie - Invalid number of points supplied: " + points;
        }
        var self = this,
            pointsWidth = points[2] - points[0],
            // pointsHeight = points[3] - points[1],
            vpData = self.elements.viewport.getBoundingClientRect(),
            boundRect = self.elements.boundary.getBoundingClientRect(),
            vpOffset = {
                left: vpData.left - boundRect.left,
                top: vpData.top - boundRect.top
            },
            scale = vpData.width / pointsWidth,
            originTop = points[1],
            originLeft = points[0],
            transformTop = (-1 * points[1]) + vpOffset.top,
            transformLeft = (-1 * points[0]) + vpOffset.left,
            newCss = {};

        newCss[CSS_TRANS_ORG] = originLeft + 'px ' + originTop + 'px';
        newCss[CSS_TRANSFORM] = new Transform(transformLeft, transformTop, scale).toString();
        css(self.elements.preview, newCss);

        _setZoomerVal.call(self, scale);
        self._currentZoom = scale;
    }

    function _centerImage() {
        var self = this,
            imgDim = self.elements.preview.getBoundingClientRect(),
            vpDim = self.elements.viewport.getBoundingClientRect(),
            boundDim = self.elements.boundary.getBoundingClientRect(),
            vpLeft = vpDim.left - boundDim.left,
            vpTop = vpDim.top - boundDim.top,
            w = vpLeft - ((imgDim.width - vpDim.width) / 2),
            h = vpTop - ((imgDim.height - vpDim.height) / 2),
            transform = new Transform(w, h, self._currentZoom);

        css(self.elements.preview, CSS_TRANSFORM, transform.toString());
    }

    function _transferImageToCanvas(customOrientation) {
        var self = this,
            canvas = self.elements.canvas,
            img = self.elements.img,
            ctx = canvas.getContext('2d');

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.width = img.width;
        canvas.height = img.height;

        var orientation = self.options.enableOrientation && customOrientation || getExifOrientation(img);
        drawCanvas(canvas, img, orientation);
    }

    function _getCanvas(data) {
        var self = this,
            points = data.points,
            left = num(points[0]),
            top = num(points[1]),
            right = num(points[2]),
            bottom = num(points[3]),
            width = right-left,
            height = bottom-top,
            circle = data.circle,
            canvas = document.createElement('canvas'),
            ctx = canvas.getContext('2d'),
            startX = 0,
            startY = 0,
            canvasWidth = data.outputWidth || width,
            canvasHeight = data.outputHeight || height;

        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        if (data.backgroundColor) {
            ctx.fillStyle = data.backgroundColor;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        }

        // By default assume we're going to draw the entire
        // source image onto the destination canvas.
        var sx = left,
            sy = top,
            sWidth = width,
            sHeight = height,
            dx = 0,
            dy = 0,
            dWidth = canvasWidth,
            dHeight = canvasHeight;

        //
        // Do not go outside of the original image's bounds along the x-axis.
        // Handle translations when projecting onto the destination canvas.
        //

        // The smallest possible source x-position is 0.
        if (left < 0) {
            sx = 0;
            dx = (Math.abs(left) / width) * canvasWidth;
        }

        // The largest possible source width is the original image's width.
        if (sWidth + sx > self._originalImageWidth) {
            sWidth = self._originalImageWidth - sx;
            dWidth =  (sWidth / width) * canvasWidth;
        }

        //
        // Do not go outside of the original image's bounds along the y-axis.
        //

        // The smallest possible source y-position is 0.
        if (top < 0) {
            sy = 0;
            dy = (Math.abs(top) / height) * canvasHeight;
        }

        // The largest possible source height is the original image's height.
        if (sHeight + sy > self._originalImageHeight) {
            sHeight = self._originalImageHeight - sy;
            dHeight = (sHeight / height) * canvasHeight;
        }

        // console.table({ left, right, top, bottom, canvasWidth, canvasHeight, width, height, startX, startY, circle, sx, sy, dx, dy, sWidth, sHeight, dWidth, dHeight });

        ctx.drawImage(this.elements.preview, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
        if (circle) {
            ctx.fillStyle = '#fff';
            ctx.globalCompositeOperation = 'destination-in';
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, canvas.width / 2, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fill();
        }
        return canvas;
    }

    function _getHtmlResult(data) {
        var points = data.points;
        var  div = document.createElement('div');
        var  img = document.createElement('img');
            width = points[2] - points[0],
            height = points[3] - points[1];

        addClass(div, 'croppie-result');
        div.appendChild(img);
        css(img, {
            left: (-1 * points[0]) + 'px',
            top: (-1 * points[1]) + 'px'
        });
        img.src = data.url;
        css(div, {
            width: width + 'px',
            height: height + 'px'
        });

        return div;
    }

    function _getBase64Result(data) {
        return _getCanvas.call(this, data).toDataURL(data.format, data.quality);
    }

    function _getBlobResult(data) {
        var self = this;
        return new Promise(function (resolve) {
            _getCanvas.call(self, data).toBlob(function (blob) {
                resolve(blob);
            }, data.format, data.quality);
        });
    }

    function _replaceImage(img) {
        if (this.elements.img.parentNode) {
            Array.prototype.forEach.call(this.elements.img.classList, function(c) { img.classList.add(c); });
            this.elements.img.parentNode.replaceChild(img, this.elements.img);
            this.elements.preview = img; // if the img is attached to the DOM, they're not using the canvas
        }
        this.elements.img = img;
    }

    function _bind(options, cb) {
        var self = this,
            url,
            points = [],
            zoom = null,
            hasExif = _hasExif.call(self);

        if (typeof (options) === 'string') {
            url = options;
            options = {};
        }
        else if (Array.isArray(options)) {
            points = options.slice();
        }
        else if (typeof (options) === 'undefined' && self.data.url) { //refreshing
            _updatePropertiesFromImage.call(self);
            _triggerUpdate.call(self);
            return null;
        }
        else {
            url = options.url;
            points = options.points || [];
            zoom = typeof(options.zoom) === 'undefined' ? null : options.zoom;
        }

        self.data.bound = false;
        self.data.url = url || self.data.url;
        self.data.boundZoom = zoom;

        return loadImage(url, hasExif).then(function (img) {
            _replaceImage.call(self, img);
            if (!points.length) {
                var natDim = naturalImageDimensions(img);
                var rect = self.elements.viewport.getBoundingClientRect();
                var aspectRatio = rect.width / rect.height;
                var imgAspectRatio = natDim.width / natDim.height;
                var width, height;

                if (imgAspectRatio > aspectRatio) {
                    height = natDim.height;
                    width = height * aspectRatio;
                }
                else {
                    width = natDim.width;
                    height = natDim.height / aspectRatio;
                }

                var x0 = (natDim.width - width) / 2;
                var y0 = (natDim.height - height) / 2;
                var x1 = x0 + width;
                var y1 = y0 + height;
                self.data.points = [x0, y0, x1, y1];
            }
            else if (self.options.relative) {
                points = [
                    points[0] * img.naturalWidth / 100,
                    points[1] * img.naturalHeight / 100,
                    points[2] * img.naturalWidth / 100,
                    points[3] * img.naturalHeight / 100
                ];
            }

            self.data.orientation = options.orientation || 1;
            self.data.points = points.map(function (p) {
                return parseFloat(p);
            });
            if (self.options.useCanvas) {
                _transferImageToCanvas.call(self, self.data.orientation);
            }
            _updatePropertiesFromImage.call(self);
            _triggerUpdate.call(self);
            cb && cb();
        });
    }

    function fix(v, decimalPoints) {
        return parseFloat(v).toFixed(decimalPoints || 0);
    }

    function _get() {
        var self = this,
            imgData = self.elements.preview.getBoundingClientRect(),
            vpData = self.elements.viewport.getBoundingClientRect(),
            x1 = vpData.left - imgData.left,
            y1 = vpData.top - imgData.top,
            widthDiff = (vpData.width - self.elements.viewport.offsetWidth) / 2, //border
            heightDiff = (vpData.height - self.elements.viewport.offsetHeight) / 2,
            x2 = x1 + self.elements.viewport.offsetWidth + widthDiff,
            y2 = y1 + self.elements.viewport.offsetHeight + heightDiff,
            scale = self._currentZoom;

        if (scale === Infinity || isNaN(scale)) {
            scale = 1;
        }

        var max = self.options.enforceBoundary ? 0 : Number.NEGATIVE_INFINITY;
        x1 = Math.max(max, x1 / scale);
        y1 = Math.max(max, y1 / scale);
        x2 = Math.max(max, x2 / scale);
        y2 = Math.max(max, y2 / scale);

        return {
            points: [fix(x1), fix(y1), fix(x2), fix(y2)],
            zoom: scale,
            orientation: self.data.orientation
        };
    }

    var RESULT_DEFAULTS = {
            type: 'canvas',
            format: 'png',
            quality: 1
        },
        RESULT_FORMATS = ['jpeg', 'webp', 'png'];

    function _result(options) {
        var self = this,
            data = _get.call(self),
            opts = deepExtend(clone(RESULT_DEFAULTS), clone(options)),
            resultType = (typeof (options) === 'string' ? options : (opts.type || 'base64')),
            size = opts.size || 'viewport',
            format = opts.format,
            quality = opts.quality,
            backgroundColor = opts.backgroundColor,
            circle = typeof opts.circle === 'boolean' ? opts.circle : (self.options.viewport.type === 'circle'),
            vpRect = self.elements.viewport.getBoundingClientRect(),
            ratio = vpRect.width / vpRect.height,
            prom;

        if (size === 'viewport') {
            data.outputWidth = vpRect.width;
            data.outputHeight = vpRect.height;
        } else if (typeof size === 'object') {
            if (size.width && size.height) {
                data.outputWidth = size.width;
                data.outputHeight = size.height;
            } else if (size.width) {
                data.outputWidth = size.width;
                data.outputHeight = size.width / ratio;
            } else if (size.height) {
                data.outputWidth = size.height * ratio;
                data.outputHeight = size.height;
            }
        }

        if (RESULT_FORMATS.indexOf(format) > -1) {
            data.format = 'image/' + format;
            data.quality = quality;
        }

        data.circle = circle;
        data.url = self.data.url;
        data.backgroundColor = backgroundColor;

        prom = new Promise(function (resolve) {
            switch(resultType.toLowerCase())
            {
                case 'rawcanvas':
                    resolve(_getCanvas.call(self, data));
                    break;
                case 'canvas':
                case 'base64':
                    resolve(_getBase64Result.call(self, data));
                    break;
                case 'blob':
                    _getBlobResult.call(self, data).then(resolve);
                    break;
                default:
                    resolve(_getHtmlResult.call(self, data));
                    break;
            }
        });
        return prom;
    }

    function _refresh() {
        _updatePropertiesFromImage.call(this);
    }

    function _rotate(deg) {
        if (!this.options.useCanvas || !this.options.enableOrientation) {
            throw 'Croppie: Cannot rotate without enableOrientation && EXIF.js included';
        }

        var self = this,
            canvas = self.elements.canvas;

        self.data.orientation = getExifOffset(self.data.orientation, deg);
        drawCanvas(canvas, self.elements.img, self.data.orientation);
        _updateCenterPoint.call(self, true);
        _updateZoomLimits.call(self);

        // Reverses image dimensions if the degrees of rotation is not divisible by 180.
        if ((Math.abs(deg) / 90) % 2 === 1) {
            let oldHeight = self._originalImageHeight;
            let oldWidth = self._originalImageWidth;
            self._originalImageWidth = oldHeight;
            self._originalImageHeight = oldWidth;
        }
    }

    function _destroy() {
        var self = this;
        self.element.removeChild(self.elements.boundary);
        removeClass(self.element, 'croppie-container');
        if (self.options.enableZoom) {
            self.element.removeChild(self.elements.zoomerWrap);
        }
        delete self.elements;
    }

    if (typeof window !== 'undefined' && window.jQuery) {
        var $ = window.jQuery;
        $.fn.croppie = function (opts) {
            var ot = typeof opts;

            if (ot === 'string') {
                var args = Array.prototype.slice.call(arguments, 1);
                var singleInst = $(this).data('croppie');

                if (opts === 'get') {
                    return singleInst.get();
                }
                else if (opts === 'result') {
                    return singleInst.result.apply(singleInst, args);
                }
                else if (opts === 'bind') {
                    return singleInst.bind.apply(singleInst, args);
                }

                return this.each(function () {
                    var i = $(this).data('croppie');
                    if (!i) return;

                    var method = i[opts];
                    if ($.isFunction(method)) {
                        method.apply(i, args);
                        if (opts === 'destroy') {
                            $(this).removeData('croppie');
                        }
                    }
                    else {
                        throw 'Croppie ' + opts + ' method not found';
                    }
                });
            }
            else {
                return this.each(function () {
                    var i = new Croppie(this, opts);
                    i.$ = $;
                    $(this).data('croppie', i);
                });
            }
        };
    }

    function Croppie(element, opts) {
        if (element.className.indexOf('croppie-container') > -1) {
            throw new Error("Croppie: Can't initialize croppie more than once");
        }
        this.element = element;
        this.options = deepExtend(clone(Croppie.defaults), opts);

        if (this.element.tagName.toLowerCase() === 'img') {
            var origImage = this.element;
            addClass(origImage, 'cr-original-image');
            setAttributes(origImage, {'aria-hidden' : 'true', 'alt' : '' });
            var replacementDiv = document.createElement('div');
            this.element.parentNode.appendChild(replacementDiv);
            replacementDiv.appendChild(origImage);
            this.element = replacementDiv;
            this.options.url = this.options.url || origImage.src;
        }

        _create.call(this);
        if (this.options.url) {
            var bindOpts = {
                url: this.options.url,
                points: this.options.points
            };
            delete this.options['url'];
            delete this.options['points'];
            _bind.call(this, bindOpts);
        }
    }

    Croppie.defaults = {
        viewport: {
            width: 100,
            height: 100,
            type: 'square'
        },
        boundary: { },
        orientationControls: {
            enabled: true,
            leftClass: '',
            rightClass: ''
        },
        resizeControls: {
            width: true,
            height: true
        },
        customClass: '',
        showZoomer: true,
        enableZoom: true,
        enableResize: false,
        mouseWheelZoom: true,
        enableExif: false,
        enforceBoundary: true,
        enableOrientation: false,
        enableKeyMovement: true,
        update: function () { }
    };

    Croppie.globals = {
        translate: 'translate3d'
    };

    deepExtend(Croppie.prototype, {
        bind: function (options, cb) {
            return _bind.call(this, options, cb);
        },
        get: function () {
            var data = _get.call(this);
            var points = data.points;
            if (this.options.relative) {
                points[0] /= this.elements.img.naturalWidth / 100;
                points[1] /= this.elements.img.naturalHeight / 100;
                points[2] /= this.elements.img.naturalWidth / 100;
                points[3] /= this.elements.img.naturalHeight / 100;
            }
            return data;
        },
        result: function (type) {
            return _result.call(this, type);
        },
        refresh: function () {
            return _refresh.call(this);
        },
        setZoom: function (v) {
            _setZoomerVal.call(this, v);
            dispatchChange(this.elements.zoomer);
        },
        rotate: function (deg) {
            _rotate.call(this, deg);
        },
        destroy: function () {
            return _destroy.call(this);
        }
    });
    return Croppie;
}));



define('format-converter',[],function(){

    var FormatConverter = {

      /**
       * Converts base64 data into a Blob.
       * @param  {[type]} base64 [description]
       * @param  {[type]} mime   [description]
       * @return {Blob}        [description]
       */
      base64ToBlob:function(base64, mime){
          mime = mime || '';
          base64 = base64.replace(/^data:.*;base64,/, "");
          var sliceSize = 1024;
          var byteChars = window.atob(base64);
          var byteArrays = [];

          for (var offset = 0, len = byteChars.length; offset < len; offset += sliceSize) {
              var slice = byteChars.slice(offset, offset + sliceSize);

              var byteNumbers = new Array(slice.length);
              for (var i = 0; i < slice.length; i++) {
                  byteNumbers[i] = slice.charCodeAt(i);
              }

              var byteArray = new Uint8Array(byteNumbers);
              byteArrays.push(byteArray);
          }

          return new Blob(byteArrays, {type: mime});
      }
    }

  return FormatConverter;
})
;
define('text-utilities',[], function(){
  var ENTER_KEY = 13;
  var TAB_KEY = 9;

  var TextUtilities = function(){}

  TextUtilities.onKeyPress = function(e){
    var code = e.keyCode;
    if(code == TAB_KEY){
      e.preventDefault();
      this.insertTab(e.target);
      return false;
    }
    else if(e.shiftKey && code == ENTER_KEY){
      return true; // go to new line.
    }
    else if(code == ENTER_KEY){
      if(!e.send || typeof e.send != 'function'){
        throw new Error('send function must be attached to event.');
      }
      e.send();
    }
    else{
      return true;
    }
  }

  TextUtilities.insertTab = function(target){
      var start = target.selectionStart;
      var end = target.selectionEnd;
      var cursorPrefix = target.value.substring(0, start);
      var tab = "\t";
      var cursorPostfix = target.value.substring(end);
      target.selectionStart = target.selectionEnd = start + 1;
      target.value = cursorPrefix + tab + cursorPostfix;
    }


    TextUtilities.formatToHTML = function(text){
      text = TextUtilities.escapeHTML(text);
      text = TextUtilities.insertLineBreaks(text);
      return TextUtilities.insertHTMLTabs(text);
    }

    TextUtilities.escapeHTML = function(str){
      var after = str.replace(/[&<>"]/g, function (tag) {
        var chars_to_replace = {
              '&': '&amp;',
              '<': '&lt;',
              '>': '&gt;',
              '"': '&quot;',
              "'": '&apos;'
          };
          return chars_to_replace[tag] || tag;
      });
      return after;
    }
    
  TextUtilities.insertLineBreaks = function(text){
      var lines = text.split(/\n/gm);
      var messageWithBreaks = '';
      for(var i = 0; i < lines.length; i++){
        if(i < lines.length - 1){
            messageWithBreaks += lines[i] + '<br>';
        }
        else{
            messageWithBreaks += lines[i];
        }
      }
      return messageWithBreaks;
    }


  TextUtilities.insertHTMLTabs = function(text){
      var lines = text.split(/\t/gm);
      var withTabs = '';
      for(var i = 0; i < lines.length; i++){
        if(i == lines.length - 1 && lines[i] == ''){
          break;
        }
        withTabs += lines[i] + '\u00A0\u00A0\u00A0\u00A0';
      }
      return withTabs;
    }


  TextUtilities.wrapLinks = function(text, styleClass){
      if(/iframe/.test(text) == true){
        return text;
      }
      let regex = /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[\-;:&=\+\$,\w]+@)?[A-Za-z0-9\.\-]+|(?:www\.|[\-;:&=\+\$,\w]+@)[A-Za-z0-9\.\-]+)((?:\/[\+~%\/\.\w\-_]*)?\??(?:[\-\+=&;%@\.\w_]*)#?(?:[\.\!\/\\\w]*))?)/;
      if(regex.test(text)){
          var match = (text.match(regex))[0];
          var replacement = '<a target="_blank" ' +
                               'class="' + styleClass + '" ' +
                               'href="'  + match + '">' +
                                match
                          + '</a>';
          text = text.replace(match, replacement);
      }
      return text;
    }


return TextUtilities;
});

/**
 *  Used for closing a widget when the user clicks somewhere else on the document.
 *
 *  element should be an ancester of all elements in the widget
 *
 * valueAccessor must be a function that executes the closing of the widget
 * (this closing function should be defined in the view model.)
 *
 */
define('complementClick',['ko','jquery'],function(ko,$){

  ko.bindingHandlers.complementClick = {


    init :  function(element,valueAccessor,allBindings,viewModel){

        var $e = $(element);

        $(document).mouseup(function(event){
          var $target = $(event.target);
          var matchCount = $target.closest($e).length;
          if(matchCount > 0){
            return true;
          }
          else {
            // no child of the menu was clicked (nor the menu its self.).
            var callback = valueAccessor(); // returns the argument that was passed to the binding.
            callback();
          }
        });
    },

    update: function(element,valueAccessor,allBindings,viewModel){


    }
  };
});

define('sliderValue',['ko','jquery'],function(ko,$){


  ko.bindingHandlers.sliderValue = {
    // Init, runs on initialization
    init: function (element, valueAccessor, allBindings, viewModel, bindingContext)  {
      if ( ko.isObservable(valueAccessor()) && (element instanceof HTMLInputElement) && (element.type === "range") )
      {
        // Add event listener to the slider, this will update the observable on input (just moving the slider),
        // Otherwise, you have to move the slider then release it for the value to change
        element.addEventListener('input', function(){
          // Update the observable
          if (ko.unwrap(valueAccessor()) != element.value)
          {
            valueAccessor()(element.value);

            // Trigger the change event, awesome fix that makes
            // changing a dropdown and a range slider function the same way
            element.dispatchEvent(new Event('change'));
          }
        }); // End event listener
      }

    }, // End init

    // Update, runs whenever observables for this binding change(and on initialization)
    update: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
      // Make sure the parameter passed is an observable
      if ( ko.isObservable(valueAccessor()) && (element instanceof HTMLInputElement) && (element.type === "range") )
      {
        // Update the slider value (so if the value changes programatically, the slider will update)
        if (element.value != ko.unwrap(valueAccessor()))
        {
          element.value = ko.unwrap(valueAccessor());
          element.dispatchEvent(new Event('input'));
        }
      }
    } // End update

  }; // End sliderValue

});


define('dispatcher/Dispatcher',[],
function(){
  // private and only one instance of this.
  var _callbacks = [];
  var _idCounter = 0;
  var _orderedNames = [];

  var Dispatcher = function(){

    this.reg = function(name, callback){
      if(!name || typeof name != 'string' || name.length < 2){
        throw new Error('name must be a non-empty string.');
      }
      if(!callback || typeof callback != 'function'){
        throw new Error('callback must be a function.');
      }
      var callbacksId = _idCounter;
      _callbacks.push({
        name:name,
        callback:callback,
        id:callbacksId
      });
      _idCounter++;
      return callbacksId;
    }

    this.getCallback = function(name){
      var cbs = _callbacks;
      for(var i = 0; i < cbs.length; i++){
        if(cbs[i].name == name){
          return cbs[i].callback;
        }
      }
    }

    this.getCallbackById = function(id){
      if(isNaN(id) || id < 0){
        throw new Error('id must be a positive integer.');
      }
      var cbs = _callbacks;
      for(var i = 0; i < cbs.length; i++){
        if(cbs[i].id == id){
          return cbs[i].callback;
        }
      }
    }

    /**
      moves all the actions with 'name'
      to the front so that are dispatched first.
    */
    this.waitFor = function(name){
      var tmp = [];

      for(var i = 0; i < _callbacks.length; i++){
        var c =  _callbacks[i];
        if(name == c.name){
          tmp.push(c);
        }
      }

      _callbacks = array.filter(function(value, index, arr){
        return value.name == name;
      });

      tmp.forEach(function(t){
        _callbacks.unshift(t);
      })
    }



    this.dispatch = function(name, data){
      for(var i = 0; i < _callbacks.length; i++){
        if(_callbacks[i].name == name){
          _callbacks[i].callback(data);
        }
      }
    }





};

  return Dispatcher;
});


define('enterKey',['ko'],function(ko){
  ko.bindingHandlers.enterKey = {
    init :  function(element,valueAccessor,allBindings,viewModel){
      var callBack = valueAccessor();
     // alert(callBack);
     // alert(element);
  //adsdfadsdf does not work.
      $(element).keypress(function(event){

        var keyCode = (event.which ? event.which : event.keyCode);

        if(keyCode === 13){
          //console.log(keyCode);
          //console.log($(element).text());
          callBack.call(viewModel);

          return false;
        }
        return true;
      });
    }
  };
});


define('RootViewModel',['ko','enterKey', "jquery",'complementClick'],
function(ko, enterKey, $, complementClick){


  ko.options.deferUpdates = true;

  ko.components.register('environment',    {require:'environment/Component'});
  ko.components.register('auth',                  {require:'auth/AuthViewModel'});

  ko.components.register('forum-reply',        {require:'forum-reply/Component'});
  ko.components.register('forum-poster',        {require:'forum-poster/Component'});
  ko.components.register('forum-feed',        {require:'forum-feed/Component'});
  ko.components.register('forum-stats',        {require:'forum-stats/Component'});
  ko.components.register('session-tracker',        {require:'session-tracker/Component'});
  ko.components.register('account-info',        {require:'account-info/Component'});
  ko.components.register('punch-clock',        {require:'punch-clock/Component'});
  ko.components.register('profile-setter',        {require:'profile-setter/ViewModel'});
  ko.components.register('user-info',             {require:'user-info/Component'});
  ko.components.register('profile-webcam',        {require:'webcam/Component'});
  ko.components.register('permission-error',      {require:'permission-error/Component'});
  ko.components.register('photo-controls',        {require:'photo-controls/Component'});

  ko.components.register('new-user', {require:'new-user/Component'})
  ko.components.register('banner',                {require:'banner/ViewModel'});
  ko.components.register('notification',          {require:'notification/Component'});


  ko.components.register('search',                {require:'search/Component'});
  ko.components.register('course-groups',           {require:'course-groups/Component'});
  ko.components.register('course-reviews',           {require:'course-reviews/Component'});

  // people.
  ko.components.register('new-pal-list',          {require:'new-pal-list/Component'});
  ko.components.register('pal-list',          {require:'pal-list/Component'});
  ko.components.register('pal-request-list',  {require:'pal-request-list/Component'});
  ko.components.register('class-list',       {require:'class-list/Component'});
  ko.components.register('people-popups',       {require:'people-popups/Component'});


  ko.components.register('course-features',       {require:'course-features/Component'});
    ko.components.register('non-member-prompt',   {require:'non-member-prompt/Component'});
    ko.components.register('in-another-section-prompt',   {require:'in-another-section-prompt/Component'});
    ko.components.register('forum',               {require:'forum/Component'});
    ko.components.register('course-settings',      {require:'course-settings/Component'});
    ko.components.register('tab-selector',      {require:'tab-selector/Component'});
    ko.components.register('course-docs',      {require:'course-docs/container/Component'});
    ko.components.register('doc-list', {require:'doc-list/Component'});
    ko.components.register('doc-list-current', {require:'doc-list-current/Component'});
    ko.components.register('doc-uploader',      {require:'doc-uploader/Component'});
      ko.components.register('doc-attr',      {require:'doc-attr/Component'});

    ko.components.register('document-plans',      {require:'document-plans/Component'});
    ko.components.register('credit-card-info',     {require:'credit-card-info/Component'});
  // one on one stuff.
  ko.components.register('chat-widget',           {require:'chat/ViewModel'});
  ko.components.register('blackboard',            {require:'blackboard/ViewModel'});



  ko.components.register('right-panel',     {require:'right-panel/Component'});

    ko.components.register('current-courses', {require:'right-panel/current-courses/Component'});

    ko.components.register('pre-view',       {require:'right-panel/ad-views/pre-view/Component'});
      ko.components.register('lead-view',       {require:'right-panel/ad-views/lead-view/Component'});

    ko.components.register('course-info',     {require:'right-panel/course-info/Component'});
      ko.components.register('course-photos',        {require:'right-panel/course-info/course-photos/Component'});
      ko.components.register('course-text-info',     {require:'right-panel/course-info/text-info/Component'});

    ko.components.register('file-dropper',    {require:'right-panel/file-dropper/Component'});
    ko.components.register('person-info',     {require:'right-panel/person-info/Component'});
    ko.components.register('video-chat',      {require:'video-chat/Component'});
    ko.components.register('incoming-call',      {require:'video-chat/incoming-call/Component'});
    ko.components.register('tutoring-plans',     {require:'tutoring-plans/Component'})


  return function RootViewModel(){
  };
});

define('RemoteService',['socketio','dispatcher/Dispatcher'],
function(io, Dispatcher){

  var RemoteService = function(){

  this.proto = Object.getPrototypeOf(this);
  this.io = io;
  this.sock = null;
  this.dis = new Dispatcher();

  this._domain = '';

  this.getConstructorName = function(){
    return "RemoteService";
  }

  this.isLive = function(){
    throw new Error('isLive() must be implemented in subclasses.')
  }


    this.getScheme = function(){
      return this._scheme;
    }

    this.setScheme = function(scheme){
      this._scheme = scheme;
    }
    this.getHost = function(){
      return this._host;
    }

    this.setHost = function(host){
      this._host = host + ".";
    }

    this.setMicroServer = function(microServer){
      if(microServer){
          this._microServer = microServer + '.';
      }

    }

    this.getMicroServer = function(){
      return this._microServer;
    }

    this.setDomain = function(domain){
      if(String(domain).length < 1){
        this._domain = '';
      }
      else{
        this._domain = domain;
      }
    }

    this.getDomain = function(){
      return this._domain;
    }


    this.setPath = function(path){
      if(String(path).length < 1){
        this._path = '';
      }
      else{
          this._path = '/' + path;
      }
    }

    this.getPath = function(){
      return this._path;
    }


  this.setPort = function(port){
    if(String(port).length < 1){
      this._port = port;
    }
    else{
      this._port = ":" + port;
    }
  }

  this.getPort = function(){
    return this._port;
  }

  /**
      sets the socket using the accessToken
      and the server url.

      pre: microserver must be set beforehand.
  */
  this.setSock = function(f){
    if(!this.sock){
      var token = this.getAccessToken();
      var url = this.getServerURL();
      var opt = {
        autoConnect:true,
        reconnection:true,
        query: {token: token}
      };
      this.sock = this.io(url,opt);
      if(typeof f == 'function'){
        f();
      }
    }
  }







  this.getServerURL = function(){

    return this.getScheme() +
           this.getHost() +
           this.getMicroServer() +
           this.getDomain() +
           this.getPort() +
           this.getPath();
  }

  /**
   * Sets the authorization header  Or
   * throws an exception if the token is not set.
   * @return {string} The accessToken for this user.
   */
  this.setAuthorizationHeader = function(xhr){
    var token = this.getAccessToken();
    if(!token){
      throw new Error('accessToken must be set.');
    }
    xhr.setRequestHeader('authorization',token);
  }
  this.setAuthorizationHeader = this.setAuthorizationHeader.bind(this);

  this.missingCookiesMessage =  "This site required cookies because it enables enhanced user experience.  Please change your browsers settings to allow cookies for this site.";

  this.getAccessToken = (function(){
    try{
      var token = localStorage.getItem('accessToken');
      if(!token || token.length <= 0){
        throw new Error("accessToken must be a non-empty string.");
      }
      return token;
    }
    catch(err){
      console.log(err);
      // alert(this.missingCookiesMessage);
    }
  }).bind(this)



  this.setAccessToken = function(token){
    try{
      localStorage.setItem('accessToken',token);
    }
    catch(err){
      alert(this.missingCookiesMessage);
    }
  }
  this.setAccessToken = this.setAccessToken.bind(this);

  this.setFakeToken = function(){
    this.setAccessToken('fakeToken');
  }


  this.deleteToken = function(){
    try{
      window.localStorage.removeItem('accessToken');
    }
    catch(err){
      alert(this.missingCookiesMessage);
    }
  }

  this.flatten = function(obj){
    var result = Object.create(obj);
    for(var key in result) {
        result[key] = result[key];
    }
    return result;
  }


  }

  return RemoteService;
})
;
define('ActiveRemoteService',['RemoteService'],
function(RemoteService){

  var LiveRemoteService = function(){

    Object.setPrototypeOf(this, new RemoteService());

    this._scheme = "https://";
    this._host = "www.";
    this._microServer = ''
    this._domain = "palolo.ca";
    this._port = '';
    this._path = '';

    this.isLive = function(){
      return true
    }

    this.getConstructorName = function(){
      return "LiveRemoteService";
    }

  }

  return LiveRemoteService;
})
;

define('user/ProfileRemoteService',['ActiveRemoteService',
        'format-converter',
        'dispatcher/Dispatcher'],
function(ActiveRemoteService,
         FormatConverter,
         Dispatcher){

  var ProfileRemoteService = function(){
      Object.setPrototypeOf(Object.getPrototypeOf(this),new ActiveRemoteService());
      this.setMicroServer("profile");
      this.dis = new Dispatcher();


      this.getProfileInfo = function(){
        var self = this;
        var url = this.getServerURL() + '/getProfileInfo';
        $.ajax({
          url:url,
          type:"GET",
          cache:false,
          contentType:"application/x-www-form-urlencoded; charset=UTF-8",
          beforeSend:this.setAuthorizationHeader,
          success:function(info){
            self.dis.dispatch('profileUpdate',self.setServerUrl(info));
          },
          error:function(jq,status,err){
            console.log(err);
          }
        })
      }
      this.getProfileInfo = this.getProfileInfo.bind(this);


      /**
          handles what happens when the user is authenticated.
      */
      this.onAuthChange = (function(update){
        if(update.state == 'authenticated'){
          this.getProfileInfo();
        }
      }).bind(this)
      this.onAuthId = this.dis.reg('authState', this.onAuthChange);



      this.setServerUrl = function(info){
        var urlPrefix = this.getServerURL();
        if(info.large_photo_url){
           info.large_photo_url = urlPrefix + '/' + info.large_photo_url;
        }
        if(info.small_photo_url){
           info.small_photo_url = urlPrefix + '/' + info.small_photo_url;
        }
        return info;
      }


      /**
       * @param  {[type]} imageData is the image in base64 format.
       * @param {Function} callback is called on successful upload of the imageData.
       */
      this.saveCroppedPhoto = function(img){
        if(!img || typeof img != 'string' || img.length < 1){
          throw new Error('object of img must be passed as an argument.');
        }
        var formData = this.makeForm(img);
        var self = this;
        $.ajax({
          url:this.getServerURL() + '/updatePhoto',
          type:"POST",
          cache:false,
          contentType:false,
          processData:false,
          data:formData,
          beforeSend:this.setAuthorizationHeader,
          success:function(){
            self.getProfileInfo();
          },
          error:function(ajax,status,err){
            console.log("No Face error?");
            console.log(ajax);
            if(ajax.responseText == "NoFace"){
              self.dis.dispatch('updatePhotoNoFaceError');
            }
            else{
              self.onPhotoUploadError(err);
            }
          }
        })
      }
      this.saveCroppedPhoto = this.saveCroppedPhoto.bind(this);
      this.saveCroppedPhotoId = this.dis.reg('saveCroppedPhoto', this.saveCroppedPhoto);



      this.registerOnPhotoUploadError = function(fn){
        this.onPhotoUploadError = fn;
      }


      this.makeForm = function(imageData){
        var formData = new FormData();
        if(imageData){
          var base64Data = imageData;
          var blob = FormatConverter.base64ToBlob(base64Data, 'image/png');
          formData.append('image', blob);
        }
        return formData;
      }


      this.saveMyInfo = function(obj){
        var url = this.getServerURL() + '/saveMyInfo'
        var self = this
        $.ajax({
          url:url,
          beforeSend:this.setAuthorizationHeader,
          type:'POST',
          data:obj,
          success:function(){
            self.getProfileInfo()
          },
          error:function(a, b, err){
            console.log(err);
          }
        })
      }
      this.saveMyInfo = this.saveMyInfo.bind(this)
      this.saveBdId = this.dis.reg('saveMyInfo',this.saveMyInfo)

      this.saveAboutMe = function(text){
        var url = this.getServerURL() + '/saveAboutMe';
        $.ajax({
          url:url,
          beforeSend:this.setAuthorizationHeader,
          type:'POST',
          data:{text:text},
          success:this.getProfileInfo,
          error:function(a, b, err){
            console.log(err);
          }
        })
      }
      this.saveAboutMe = this.saveAboutMe.bind(this);
      this.saveAboutId = this.dis.reg('aboutMe', this.saveAboutMe);


      this.setYearOfStudy = (function(year){
        var url = this.getServerURL() + '/yearOfStudy/' + year;
        var self = this;
        $.ajax({
          url:url,
          beforeSend:this.setAuthorizationHeader,
          type:'POST',
          success:this.getProfileInfo,
          error:function(a, b, err){
            console.log(err);
          }
        })
      }).bind(this)
      this.setYearId = this.dis.reg('selectYear',this.setYearOfStudy);


      this.getMajors = function(input){
        if(!input || typeof input != 'string'){
          throw new Error('input must be a non-empty string.');
        }
        var url = this.getServerURL() + '/majors/' + input;
        var self = this;
        $.ajax({
          url:url,
          type:"GET",
          beforeSend:this.setAuthorizationHeader,
          success:function(json){
            var majors = JSON.parse(json);
            self.dis.dispatch('majors',majors);
          },
          error:function(err){
            console.log(err);
          }
        });
      }
      this.getMajors = this.getMajors.bind(this);
      this.getMajorsId = this.dis.reg('getStudentMajors', this.getMajors);



      this.setMajorTo = function(majorId){
        var url = this.getServerURL() + '/major/' + majorId;
        var self = this;
        $.ajax({
          url:url,
          type:'post',
          beforeSend:this.setAuthorizationHeader,
          success:function(){
            self.getProfileInfo();
          },
          error:function(err){
            console.log(err);
          }
        });
      }
      this.setMajorTo = this.setMajorTo.bind(this);
      this.selectMajorId = this.dis.reg('selectMajor', this.setMajorTo);



      this.recordProfileSetterOpened = function(){
        var url = this.getServerURL() + '/profile_setter_opened';
        $.ajax({
          url:url,
          type:'post',
          beforeSend:this.setAuthorizationHeader,
          success:function(){
              // console.log('success');
          },
          error:function(err){
            console.log(err);
          }
        })
      }


      this._checkType = function(cb){
        if(typeof cb != 'function'){
          throw new Error('callback needs to be a function.');
        }
      }
  }
  return ProfileRemoteService;
})
;
define('abstract-interfaces/Store',[],function(){

  var Store = function(){
    this.subs = [];
    this.onPubDone = null;

    this.pub = function(){
       this.subs.forEach(function(f){
         f();
       });
       if(typeof this.onPubDone == 'function'){
         this.onPubDone();
       }
     }
     this.pub = this.pub.bind(this);

     this.onPub = function(f){
       this.onPubDone = f;
     }
     this.onPub = this.onPub.bind(this);

     this.getDis = function(){
       return this.dis;
     }

     this.sub = function(f){
       this.subs.push(f);
     }

     this.getSubs = function(){
       return this.subs;
     }
  }

  return Store;
})
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
define('user/profile-setter/states/ProfileState',[],
function(){


  var _isVisible = true;
  var _isPhotoCropperVisible = false;
  var _isWebcamVisible = false;
  var _isSearchingMajors = false;
  var _isSavingPhoto = false;
  var _isNewPhotoLoaded = false;
  var _isFaceErrVisible = false;
  var _isPhotoCropperVisible = false;


  function ProfileState(params, componentInfo){


    this.isVisible = function(){
      return _isVisible;
    }

    this.isPhotoCropperVisible = function(){
      return _isPhotoCropperVisible;
    }

    this.isWebcamVisible = function(){
      return _isWebcamVisible;
    }

    this.isSearchingMajors = function(){
      return _isSearchingMajors;
    }

    this.majorsFound = function(){
      return false
    }

    this.isSavingPhoto = function(){
      return _isSavingPhoto;
    }

    this.isNewPhotoLoaded = function(){
      return _isNewPhotoLoaded;
    }

    this.isFaceErrorVisible = function(){
      return _isFaceErrVisible;
    }

    this.isPermissionErrorVisible = function(){
      return _isPhotoCropperVisible;
    }

    this.isSavingMyInfo = function(){
      return false
    }



}; // end ProfileState constructor.
return  ProfileState;


}); // end define.
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
define('user/profile-setter/states/ProfileNotVisible',['user/profile-setter/states/ProfileState'],
function(ProfileState){

  function ProfileNotVisible(){
    // sets the prototype of this to the abstract class ProfileState.
    Object.setPrototypeOf(Object.getPrototypeOf(this), new ProfileState());

    this.isVisible = function(){
      return false;
    }

  }; // end ProfileNotVisible constructor.
return  ProfileNotVisible;

}); // end define.
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
define('user/profile-setter/states/PhotoCropperVisible',['user/profile-setter/states/ProfileState'],
function(ProfileState){

  function PhotoCropperVisible(params, componentInfo){

    Object.setPrototypeOf(Object.getPrototypeOf(this), new ProfileState());

    this.isPhotoCropperVisible = function(){
      return true;
    }


}; // end PhotoCropperVisible constructor.
return  PhotoCropperVisible;


}); // end define.
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
 define('user/profile-setter/states/SearchingMajors',['user/profile-setter/states/ProfileState'],
 function(ProfileState){

  function SearchingMajors(params, componentInfo){
    Object.setPrototypeOf(Object.getPrototypeOf(this), new ProfileState());

    this.isSearchingMajors = function(){
      return true
    }

    this.isPhotoCropperVisible = function(){
      return true;
    }
};
return  SearchingMajors;


}); // end define.
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
 define('user/profile-setter/states/WebcamVisible',['user/profile-setter/states/ProfileState'],
 function(ProfileState){

  function WebcamVisible(params, componentInfo){
    Object.setPrototypeOf(Object.getPrototypeOf(this), new ProfileState());

    this.isWebcamVisible = function(){
      return true;
    }
};
return  WebcamVisible;


}); // end define.
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
define('user/profile-setter/states/NewPhotoUploaded',['user/profile-setter/states/ProfileState'],
function(ProfileState){

  function NewPhotoUploaded(params, componentInfo){

    Object.setPrototypeOf(Object.getPrototypeOf(this), new ProfileState());

    this.isNewPhotoLoaded = function(){
      return true;
    }

    this.isPhotoCropperVisible = function(){
      return true;
    }



}; // end NewPhotoUploaded constructor.
return  NewPhotoUploaded;


}); // end define.
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
 define('user/profile-setter/states/SavingProfilePhoto',['user/profile-setter/states/ProfileState'],
 function(ProfileState){

  function SavingProfilePhoto(params, componentInfo){
    Object.setPrototypeOf(Object.getPrototypeOf(this), new ProfileState());

    this.isSavingPhoto = function(){
      return true;
    }


};
return  SavingProfilePhoto;


}); // end define.
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
define('user/profile-setter/states/NoFaceError',['user/profile-setter/states/ProfileState'],
function(ProfileState){

  function NoFaceError(){

    Object.setPrototypeOf(Object.getPrototypeOf(this), new ProfileState());

    this.isFaceErrorVisible = function(){
      return true;
    }


}; // end NoFaceError constructor.
return  NoFaceError;


}); // end define.
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
define('user/profile-setter/states/PermissionError',['user/profile-setter/states/ProfileState'],
function(ProfileState){

  function PermissionError(){

    Object.setPrototypeOf(Object.getPrototypeOf(this), new ProfileState());

    this.isPermissionErrorVisible = function(){
      return true;
    }
}; // end PermissionError constructor.
return  PermissionError;
}); // end define.
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
 define('user/profile-setter/states/SavingMyInfo',['user/profile-setter/states/ProfileState'],
 function(ProfileState){

  function SavingProfilePhoto(params, componentInfo){
    Object.setPrototypeOf(Object.getPrototypeOf(this), new ProfileState());

    this.isSavingMyInfo = function(){
      return true;
    }

    this.isPhotoCropperVisible = function(){
      return true;
    }

};
return  SavingProfilePhoto;


}); // end define.
;

 define('user/profile-setter/states/MajorsFound',['user/profile-setter/states/ProfileState'],
 function(ProfileState){

  function MajorsFound(params, componentInfo){
    Object.setPrototypeOf(Object.getPrototypeOf(this), new ProfileState());

    this.majorsFound = function(){
      return true
    }

    this.isPhotoCropperVisible = function(){
      return true;
    }

};
return  MajorsFound;


}); // end define.
;

define('user/profile-setter/ProfileStore',['user/ProfileRemoteService',
         'dispatcher/Dispatcher',
         'abstract-interfaces/Store',
         'user/profile-setter/states/ProfileState',
         'user/profile-setter/states/ProfileNotVisible',
         'user/profile-setter/states/PhotoCropperVisible',
         'user/profile-setter/states/SearchingMajors',
         'user/profile-setter/states/WebcamVisible',
         'user/profile-setter/states/NewPhotoUploaded',
         'user/profile-setter/states/SavingProfilePhoto',
         'user/profile-setter/states/NoFaceError',
         'user/profile-setter/states/PermissionError',
         'user/profile-setter/states/SavingMyInfo',
         'user/profile-setter/states/MajorsFound'],
function(ProfileRemoteService,
         Dispatcher,
         AbstractStore,
         ProfileState,
        ProfileNotVisible,
        PhotoCropperVisible,
        SearchingMajors,
        WebcamVisible,
        NewPhotoUploaded,
        SavingProfilePhoto,
        NoFaceError,
        PermissionError,
        SavingMyInfo,
        MajorsFound){

   new ProfileRemoteService();

   var instance = null

  var ProfileStore = function(){

      Object.setPrototypeOf(this, new AbstractStore())
      this.currentState = new ProfileNotVisible();
      this.userInfo = null;
      this.newPhoto = null;
      this.dis = new Dispatcher();
      this.majors = [];

      this.getUserInfo = function(){
        return this.userInfo;
      }

      this.getMajors = function(){
        return this.majors;
      }

      this.getProfilePhotoUrl = function(){
        return this.userInfo.large_photo_url;
      }

      this.getNewPhoto = function(){
        return this.newPhoto;
      }

      this.getCurrentState = function(){
       return this.currentState;
      }

      this.onEvent = function(event){

       switch(event.action){

         case 'showProfileSetter':
            if(this.currentState instanceof ProfileNotVisible){
              this.currentState = new PhotoCropperVisible();
            }
         break;

         case 'hideProfileSetter':
          if(this.currentState instanceof ProfileState){
            this.currentState = new ProfileNotVisible();
          }
          break;

        case 'searchingMajors':
          if(this.currentState instanceof PhotoCropperVisible){
            this.currentState = new SearchingMajors();
          }
        break;

        case 'showWebcam':
          var showIt = this.currentState instanceof PhotoCropperVisible
                     ||this.currentState instanceof NewPhotoUploaded;
          if(showIt){
            this.currentState = new WebcamVisible();
          }
        break;

        case 'newImgUploaded':
          var s = this.currentState;
          if(s instanceof PhotoCropperVisible || s instanceof NewPhotoUploaded){
            this.newPhoto = event.photo;
            this.currentState = new NewPhotoUploaded();
          }
        break;

        case 'majors':
          if(this.currentState instanceof SearchingMajors){
            console.log(event)
            this.majors = event.majors;
            this.currentState = new MajorsFound();
          }
          break;

        case 'webcamCaptured':
          if(this.currentState instanceof WebcamVisible){
            this.newPhoto = event.photo;
            this.currentState = new NewPhotoUploaded();
          }
        break;

        case 'saveProfilePhoto':
          if(this.currentState instanceof NewPhotoUploaded){
            this.currentState = new SavingProfilePhoto();
          }
          break;


          case 'noFaceErr':
            if(this.currentState instanceof SavingProfilePhoto){
              this.currentState = new NoFaceError();
            }
          break;

          case 'croppedPhotoSaved':
            if(this.currentState instanceof SavingProfilePhoto){
              this.currentState = new PhotoCropperVisible();
            }
          break;

          case 'closeNoFaceError':
            if(this.currentState instanceof NoFaceError){
              this.currentState = new PhotoCropperVisible();
            }
          break;

          case 'cameraPermissionError':
            if(this.currentState instanceof WebcamVisible){
              this.currentState = new PermissionError();
            }
          break;

          case 'acknowledgePermissionNeed':
            if(this.currentState instanceof PermissionError){
              this.currentState = new PhotoCropperVisible();
            }
          break;

          case 'profileUpdate':
            this.userInfo = event.update;
            if(this.currentState instanceof SavingProfilePhoto
             || this.currentState instanceof SavingMyInfo
             || this.currentState instanceof MajorsFound){
                this.currentState = new PhotoCropperVisible();
            }
          break;

          case 'saveMyInfo':
            if(this.currentState instanceof PhotoCropperVisible){
              this.currentState = new SavingMyInfo();
            }
          break;

          case 'getStudentMajors':
            if(this.currentState instanceof PhotoCropperVisible
            || this.currentState instanceof MajorsFound){
              this.currentState = new SearchingMajors()
            }
          break;
          default:
            // nothing.
       }
       this.pub();
      }
      this.onEvent = this.onEvent.bind(this)

      // adapter.
      /**
      transition over to the more pure flux pattern.
      */
      this.applyAdapter = function(){
        var self = this
       this.dis.reg('showProfileSetter',function(){
         self.onEvent({action:'showProfileSetter'})
       });

      this.dis.reg('hideProfileSetter', function(){
        self.onEvent({action:'hideProfileSetter'});
      });

      this.dis.reg('showWebcam', function(){
        self.onEvent({action:'showWebcam'});
      })

      this.dis.reg('newImgUploaded', function(photo){
        self.onEvent({action:'newImgUploaded', photo:photo});
      });

      this.dis.reg('webcamCaptured', function(photo){
        self.onEvent({action:'webcamCaptured', photo:photo});
      });

      this.dis.reg('profileUpdate', function(userInfo){
        self.onEvent({action:'profileUpdate', update:userInfo});
      });

      this.dis.reg('saveProfilePhoto', function(){
        self.onEvent({action:'saveProfilePhoto'})
      });

      this.dis.reg('saveCroppedPhoto',function(photo){
        self.onEvent({action:'saveCroppedPhoto', photo:photo});
      })

      this.dis.reg('updatePhotoNoFaceError', function(){
        self.onEvent({action:'noFaceErr'});
      });

      this.dis.reg('closeNoFaceError', function(){
        self.onEvent({action:'closeNoFaceError'});
      });

      this.dis.reg('croppedPhotoSaved', function(){
        self.onEvent({action:'croppedPhotoSaved'});
      });

      this.dis.reg('majors', function(majors){
        self.onEvent({action:'majors', majors:majors});
      });

      this.dis.reg('cameraPermissionError', function(){
        self.onEvent({action:'cameraPermissionError'});
      })

      this.dis.reg('acknowledgePermissionNeed', function(){
        self.onEvent({action:'acknowledgePermissionNeed'});
      })

      this.dis.reg('saveMyInfo', function(){
        self.onEvent({action:'saveMyInfo'})
      })

      this.dis.reg('getStudentMajors', function(){
        self.onEvent({action:'getStudentMajors'})
      })


      }
      this.applyAdapter = this.applyAdapter.bind(this)
      this.applyAdapter();

      this.setCurrentState = function(state){
       if(state instanceof ProfileState){
         this.currentState = state;
       }
       else{
         throw new Error('state must be an instance of ProfileState');
       }
      }

    }

return {
    getInstance:function(){
      if(!instance){
        instance = new ProfileStore()
      }
      return instance
    },
    getNew:function(){
      return new ProfileStore()
    }
}


}); // end define.
;

define('text!banner/template.html',[],function () { return '\n<link rel="stylesheet" href="./styles/components/banner/style.css?v=2.1"></link>\n\n\n  <div id="banner-holder"\n       data-bind=\'visible:isBannerVisible()\'\n       class="row .no-gutters">\n\n   <span id=\'hamberger-button\'\n         class=\'mobile-banner-button hidden-md hidden-lg glyphicon glyphicon-menu-hamburger\'\n         data-bind=\'click:openHambergerMenu\'>\n    </span>\n\n    <span id=\'mobile-search-button\'\n          class=\'mobile-banner-button hidden-md hidden-lg glyphicon glyphicon-search\'\n          data-bind=\'click:openSearch\'>\n    </span>\n\n    <span id=\'mobile-search-input-holder\'\n          data-bind=\'visible:isSearchVisible()\'\n          class=\'hidden-md hidden-lg background-dimmer\'>\n      <search id=\'mobile-search-bar\' data-bind=\'complementClick:closeSearch\'></search>\n    </span>\n\n    <span id=\'mobile-menu\' data-bind=\'visible:mobileMenuVisible(), complementClick:closeHambergerMenu\'>\n      <course-groups></course-groups>\n      <pal-list></pal-list>\n    </span>\n\n   <span id="you-button"\n         class=\'hidden-xs hidden-sm\'\n         data-bind="click:openProfileSetter">\n    <img id="profile-photo"\n         data-bind="style:{opacity: smallPhotoUrl().length > 0 ? \'1\' : \'0\'}, attr:{src:smallPhotoUrl()}"\n         src="./assets/no-photo.jpg">\n    </img>\n     <span id="users-name"\n           data-toggle="tooltip"\n           title="Your Reputation"\n           class="disable-select"\n           data-bind="text:usersName">\n     </span>\n   </span>\n\n   <notification></notification>\n\n\n    <img id="banner-logo"\n         class="disable-select"\n         src="./assets/banner_logo_grey.png">\n    </img>\n\n    <div id="banner_menu"\n         data-bind="complementClick: closeMenu">\n         <button id="banner-menu-btn"\n                 class="dropbtn"\n                 data-bind="click:toggleDropDown">\n\n                <i class="caret"></i>\n         </button>\n\n         <ul id="banner_menu_dropdown_content"\n             data-bind="visible:isMenuVisible">\n\n           <li class="banner_list_item"\n               data-bind="click:openCourseAdder, visible:isAdminButtonVisible()">\n               <button class="banner_menu_button">\n                       create group\n               </button>\n           </li>\n\n\n\n           <li class="banner_list_item"\n               data-bind="click:logOut">\n\n             <button id="logout-btn"\n                     class="banner_menu_button">\n                     Logout\n             </button>\n           </li>\n\n         </ul>\n    </div>\n\n\n\n\n\n  </div>\n';});

/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */

define('banner/ViewModel',['ko',
        'text!banner/template.html',
        'jquery',
        'dispatcher/Dispatcher',
        'user/profile-setter/ProfileStore'],
function(ko,
         template,
         $,
         Dispatcher,
         ProfileStore){

  function BannerViewModel(params, componentInfo){

    this.store = ProfileStore.getInstance();

    this.dis = new Dispatcher();
    this.isBannerVisible = ko.observable(false);
    this.usersName = ko.observable('');
    this.smallPhotoUrl = ko.observable('');



    // menu stuff.
    this.isMenuVisible = ko.observable(false);
    this.isAdminButtonVisible = ko.observable(false);
    this.isAdminVisible = ko.observable(false);
    this.mobileMenuVisible = ko.observable(false)
    this.isSearchVisible = ko.observable(false)

    this.openSearch = (function(){
      this.isSearchVisible(true)
    }).bind(this)

    this.closeSearch = (function(c, e){
      this.isSearchVisible(false)
      if(e) e.stopPropagation();
      return false;
    }).bind(this)

    this.openHambergerMenu = (function(){
      this.mobileMenuVisible(true)
    }).bind(this)

    this.closeHambergerMenu = (function(){
      this.mobileMenuVisible(false)
    }).bind(this)


    this.openAdminPanel = function(){
      this.isAdminVisible(true);
      this.isMenuVisible(false);
    }


    this.openCourseAdder = function(){
      this.dis.dispatch('openCourseAdder');
    }



    /**
     * Triggers a broadcast to all subscribers of isImageUploaderVisible.
     */
    this.openProfileSetter = function(c, event){
      this.dis.dispatch('showProfileSetter');
      this.isMenuVisible(false);
      return false;
    }


    this.onAuth = (function(update){
      if(update.state == 'authenticated'){
        this._isAuthenticated = true;
        this.isBannerVisible(true);
      }
      else{
        this._isAuthenticated = false;
        this.isBannerVisible(false);
      }
    }).bind(this)
    this.dis.reg('authState', this.onAuth);


    this.onStore = (function(){
      var info = this.store.getUserInfo();
      if(info){
        this.isAdminButtonVisible(info.role == 'admin');
        this.usersName(info.first + ' ' + info.last + ', rep: ' + info.rep);
        var smallPhotoUrl = info.small_photo_url;
        if(!smallPhotoUrl){
          this.smallPhotoUrl('./assets/no-photo.jpg');
        }
        else{
          this.smallPhotoUrl(smallPhotoUrl + "?" + new Date().getTime()); // cache bust.
        }
      }
    }).bind(this)
    this.store.sub(this.onStore);




    this.onUserInfoError = function(err){
      console.log(err);
      // Not admin.
    }
    this.onUserInfoError = this.onUserInfoError.bind(this);



    this.closeMenu = function(){
      this.isMenuVisible(false);
    }
    this.closeMenu = this.closeMenu.bind(this);


    this.toggleDropDown = function(){
      if(this.isMenuVisible() === true){
        this.isMenuVisible(false);
      }
      else{
      }
      this.isMenuVisible(true);
    }
    this.toggleDropDown = this.toggleDropDown.bind(this);

    this.logOut = function(){
      this.dis.dispatch('logout');
    }





}; // end BannerViewModel constructor.


return {
    viewModel: BannerViewModel,
    template :template
};


}); // end define.
;

define('text!profile-setter/template.html',[],function () { return '\n<link rel="stylesheet" href="./styles/components/profile-setter/profile-setter.css?v=4.1"></link>\n<link rel="stylesheet" href="./styles/components/profile-setter/croppie.css?v=1.1"></link>\n\n  <div data-bind="visible:isVisible()"\n      class="background-dimmer">\n  </div>\n\n\n\n  <div class="window-holder"\n       data-bind="visible:isVisible(), complementClick: hideProfileSetter">\n\n       <div id="invalid-photo-error"\n             data-bind="visible:isFaceErrorVisible()">\n               <div>That photo kinda sucks..</div>\n               <div> How about a <i> good one </i> of you? </div>\n             <div>\n                   <button class="grey-flat-button"\n                           data-bind="click:closeErrorMessage">\n                           Okay\n                   </button>\n\n             </div>\n                  <small> (Preferably no nudes though.) </small>\n       </div>\n  <permission-error></permission-error>\n\n  <form id="profile-setter"\n        runat="server">\n\n    <!-- LEFT SIDE -->\n    <div id="profile-setter-left-side">\n\n      <div  class="profile-setter-spinner"\n            data-bind="visible:isSpinnerVisible()">\n        <div  class="screen-center-outer">\n         <div class="screen-center-inner">\n            <div class="loader"></div>\n         </div>\n       </div>\n      </div>\n\n      <div id="profile-img-holder"\n           data-bind="visible:isPhotoCropperVisible()">\n          <div id="img-uploader-preview-img">\n            <div id="no-photo-img"\n                  class="glyphicon glyphicon-camera"\n                  data-bind="visible:isLargeCameraButtonVisible(),click:webcamCapture">\n            </div>\n            <div id="missing-photo-message"\n                  data-bind="visible:isMissingPhoto()">\n                  <div>\n                      <div>upload your photo</div>\n                      <i id="missing-photo-arrow"\n                         class="glyphicon glyphicon-arrow-down">\n                       </i>\n                  </div>\n            </div>\n          </div>\n\n\n      </div>\n\n      <profile-webcam></profile-webcam>\n      <link rel="stylesheet" href="./styles/components/profile-setter/profile-videos.css?v=1.0"></link>\n      <!-- <iframe class="profile-video"\n              width="560"\n              height="315"\n              src="https://www.youtube.com/embed/x0-UFKFHjU0"\n              frameborder="0"\n              allow="autoplay"\n              ></iframe> -->\n      <photo-controls></photo-controls>\n    </div>\n\n\n    <user-info></user-info>\n  </form>\n</div>\n';});

/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
define('profile-setter/ViewModel',['ko',
        'croppie',
        'dispatcher/Dispatcher',
        'text!profile-setter/template.html',
        'jquery',
         'user/profile-setter/ProfileStore'],
function(ko,
         Croppie,
         Dispatcher,
         template,
         $,
         ProfileStore){

  function ProfileSetterViewModel(params, componentInfo){

    this.store = ProfileStore.getInstance();
    this.dis = new Dispatcher();
    this.isVisible = ko.observable(false);
    this.isFaceErrorVisible = ko.observable(false);
    this.isPhotoCropperVisible = ko.observable(false);
    this.isSpinnerVisible = ko.observable(false);
    this.photoURL = ko.observable('');
    this.isMissingPhoto = ko.observable(false);
    this.isLargeCameraButtonVisible = ko.observable(false);
    this._successHideFeedbackDelay = 2000;
    this._imageData = null;


    this.getCroppieHolder = function(){
      var node =  $('#img-uploader-preview-img')[0];
      if(!node){
        throw new Error('Expected element with id = img-uploader-preview-img to exist in template.');
      }
      return node;
    }
    this.getCroppieHolder = this.getCroppieHolder.bind(this);

    this.injectStore = function(store){
      this.store = store;
    }

    this.makeBox = function(data, event){
      this.replaceElementWithInputBox(event);
    }


    this.webcamCapture = function(){
      this.dis.dispatch('hidePhotoCropper');
    }


    this.closeErrorMessage = function(vm, event){
      this.dis.dispatch('closeNoFaceError');
    }




    this.onStoreChanged = function(){
      var state = this.store.getCurrentState();
      let userInfo = this.store.getUserInfo();
      this.isPhotoCropperVisible(state.isPhotoCropperVisible());
      this.isVisible(state.isVisible());
      this.isFaceErrorVisible(state.isFaceErrorVisible());
      this.isSpinnerVisible(state.isSavingPhoto());

      if(state.isNewPhotoLoaded()){
        this.isPhotoCropperVisible(true);
        this.photoURL(this.store.getNewPhoto());
        this.refreshCroppie();
      }
      else if(state.isSavingPhoto()){
        this.saveCroppedPhoto();
        this.isSpinnerVisible(true);
      }
      else if(userInfo && userInfo.large_photo_url){
          userInfo.large_photo_url += '?' + (new Date()).getTime();
          this.photoURL(userInfo.large_photo_url);
          this.refreshCroppie();
          this.isLargeCameraButtonVisible(false);
      }
      else{
        this.isMissingPhoto(true);
      }
    }
    this.onStoreChanged = this.onStoreChanged.bind(this);
    this.store.sub(this.onStoreChanged);



    /**
        This should ONLY be called when the profle setter is actually
        visible.  Otherwise the scaling will be all messed up.
    */
    this.refreshCroppie = function(){
      var url = this.photoURL();
      if(this.croppie){
        this.croppie.destroy();
      }
      try{
        if(url && typeof url == 'string'){
          var options = {
                viewport: {
                    width: 450,
                    height: 450
                },
                boundary: {
                  width: '100%',
                  height: '100%'
                },
                showZoomer:false
            }
          var profilePhotoDomNode = this.getCroppieHolder();
          this.croppie = new Croppie(profilePhotoDomNode, options);
          this.bindNewPhoto(url);
        }
      }
      catch(err){
        // source image is probably missing.
        console.log(err);
      }

    }

    this.bindNewPhoto = function(url){
      var topLeftX = 0;
      var topLeftY = 0;
      var bottomRightX = 0;
      var bottomRightY = 0;
      var options = {
        url:url,
        points: [topLeftX, topLeftY, bottomRightX, bottomRightY]
      }

      var promise = this.croppie.bind(options);
      promise.then(this.setPhotoZoomToZero);
    }

    this.setPhotoZoomToZero = function(){
      this.croppie.setZoom(0);
    }
    this.setPhotoZoomToZero = this.setPhotoZoomToZero.bind(this);


    this.saveCroppedPhoto = function(){
      if(this.photoURL()){
        var self = this;
        if(this.croppie){
          this.croppie.result({type:'base64',size:'viewport'})
              .then(function(croppedImg){
                  self.dis.dispatch('saveCroppedPhoto',croppedImg);
              })
              .catch(function(err){
                console.log(err);
              });
        }
        else{
          throw new Error('Croppie has not been initialized.');
        }
      }
      else{
        throw new Error('photoUrl observable has not been set!');
      }
    }
    this.saveCroppedPhoto = this.saveCroppedPhoto.bind(this);

    this.hideProfileSetter = function(){
      this.dis.dispatch('hideProfileSetter');
    }
    this.hideProfileSetter = this.hideProfileSetter.bind(this);




}; // end ProfileSetterViewModel constructor.

return {
    viewModel: ProfileSetterViewModel,
    template :template
};


}); // end define.
;

define('text!user-info/template.html',[],function () { return '<div id="profile-setter-info-holder">\n  <div class="student-subject"\n       id="profile-setter-name"\n       data-bind="text:fullName()">\n  </div>\n  <div class="student-subject" id=\'year-and-major\'>\n    <span id="year"\n          data-bind="click:showYearOfStudyInput,\n                     visible:isYearOfStudyTextVisible(),\n                     text:yearOfStudy()">\n          1st\n    </span>\n    <input type=\'number\'\n           value=1\n           min=1\n           max=4\n           class=\'year-of-study\'\n           placeholder=\'Year\'\n           data-bind="visible:isYearOfStudyInputVisible(),\n                      hasFocus: isYearOfStudyInputFocused,\n                      value: yearOfStudyInput"/>\n    <span data-bind="click:showYearOfStudyInput">year,</span>\n\n    <span id="major-holder">\n        <span data-bind="visible:isMajorTextVisible(),\n                         click: showMajorInput,\n                         text:majorText">\n          Student\n        </span>\n        <input type=\'text\'\n               class=\'major\'\n               placeholder=\'Type Your Major\'\n               data-bind="visible:isMajorInputVisible(), hasFocus: isMajorInputFocused, textInput:partialMajor"/>\n\n        <ul class="major-search-results"\n            data-bind="foreach:suggestedMajors, complementClick:clearMajorResults, visible:suggestedMajors().length > 0">\n            <li class="major-search-result"\n                data-bind="text:major_name, click:$parent.selectSuggestedMajor">\n            </li>\n        </ul>\n      </span>\n      <div class="my-attr">\n        <label for="my-gender">Gender:</label>\n        <select class="my-attr-value"\n                data-bind="value:gender">\n                  <option value="0">female</option>\n                  <option value="1">male</option>\n                  <option value="2">other</option>\n        </select>\n      </div>\n      <div class="my-attr">\n\n        <div  data-bind="visible:isSpinnerVisible()"\n              class="screen-center-outer">\n         <div class="screen-center-inner">\n            <div class="small-spinner">\n            </div>\n         </div>\n\n       </div>\n        <label for="my-age">Birthday:</label>\n        <select id="birth-month"\n                data-bind="value:birthMonth"\n                class="my-attr-value" >\n          <option value="1">Jan</option>\n          <option value="2">Feb</option>\n          <option value="3">Mar</option>\n          <option value="4">Apr</option>\n          <option value="5">May</option>\n          <option value="6">Jun</option>\n          <option value="7">Jul</option>\n          <option value="8">Aug</option>\n          <option value="9">Sep</option>\n          <option value="10">Oct</option>\n          <option value="11">Nov</option>\n          <option value="12">Dec</option>\n        </select>\n\n      <input id="birth-day"\n             data-bind="value:birthDay"\n             class="my-attr-value"\n             type="number"\n             value="15"\n             min="1"\n             max="31">\n       </input>\n\n        <input\n           id="birth-year"\n           data-bind="value:birthYear"\n           class="my-attr-value"\n           type="number"\n           value="2004"\n           min="1900"\n           max="2015">\n       </input>\n\n       <div class="my-attr">\n         <label for="my-res">\n           Residence:\n         </label>\n\n        <select  id="my-res"\n                 class="my-attr-value"\n                 data-bind="options:residenceOptions,\n                            optionsText:\'name\',\n                            optionsValue:\'res_id\',\n                            value:selectedRes">\n        </select>\n       </div>\n\n       <div class="my-attr">\n         <label for="my-favourite-music">\n           Music:\n         </label>\n\n         <input type="text"\n                value="Favourite Musical Artist"\n                data-bind="textInput:favMusicArtist">\n          </input>\n       </div>\n\n      </div>\n\n\n  </div>\n\n  <textarea id="profile-about-me" data-bind="textInput:aboutMe">\n    About me.\n  </textarea>\n  <div id="profile-save-button-holder">\n    <button\n            class="profile-photo-button"\n            data-bind="click:saveMyInfo, visible:showSaveButton()">\n            save\n    </button>\n  </div>\n\n  <!-- <div id="detailed-profile-info">\n\n    <div class="profile-info-row">\n        <span class=\'profile-info-label\'> hometown: </span>\n        <div class="profile-indented-input">\n          <input class="" type="text" placeholder="Country"></input>\n        </div>\n        <div class=\'profile-indented-input\'>\n          <input type="text" placeholder="City"></input>\n        </div>\n    </div>\n\n    <div class="profile-info-row">\n      <span class=\'profile-info-label\'> languages </span>\n      <div class=\'profile-indented-input\'>\n        <input type="text" placeholder="First Language"> </input>\n      </div>\n      <div class=\'profile-indented-input\'>\n        <input type="text" placeholder="Second Language"> </input>\n      </div>\n\n    </div>\n\n    <div class="profile-info-row">\n        <span class=\'profile-info-label\'> memberships </span>\n        <ul>\n          <li class="profile-group">MATH1300 M W 2020</li>\n          <li class="profile-group">EECS2030 L W 2020</li>\n        </ul>\n    </div>\n\n\n  </div> -->\n</div>\n';});

/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
define('user-info/Component',['ko',
        'dispatcher/Dispatcher',
        'text!user-info/template.html',
        'jquery',
         'user/profile-setter/ProfileStore'],
function(ko,
         Dispatcher,
         template,
         $,
         ProfileStore){

  function UserInfoViewModel(params, componentInfo){

    this.store = ProfileStore.getInstance();
    this.dis = new Dispatcher();
    this.fullName = ko.observable('');
    this.yearOfStudy = ko.observable('1st');
    this.yearOfStudyInput = ko.observable('1');
    this.isYearOfStudyInputVisible = ko.observable(false);
    this.isYearOfStudyTextVisible = ko.observable(true);
    this.isYearOfStudyInputFocused = ko.observable(false);

    this.majorText = ko.observable('Student');
    this.isMajorInputVisible = ko.observable(false);
    this.isMajorInputFocused = ko.observable(false);
    this.isMajorTextVisible = ko.observable(true);
    this.partialMajor = ko.observable('');
    this.suggestedMajors = ko.observableArray([]);
    this.isSpinnerVisible = ko.observable(false)

    this.gender = ko.observable('female')
    this.birthDay = ko.observable('15')
    this.birthMonth = ko.observable('4')
    this.birthYear = ko.observable('2001')
    this.residenceOptions = ko.observable([])
    this.selectedRes = ko.observable(null)
    this.aboutMe = ko.observable("About me");

    this.showSaveButton = ko.observable(false);

    this.onProfileChange = function(){
      this.showSaveButton(true)
    }
    this.onProfileChange = this.onProfileChange.bind(this)

    this.gender.subscribe(this.onProfileChange);
    this.birthDay.subscribe(this.onProfileChange)
    this.birthMonth.subscribe(this.onProfileChange)
    this.birthYear.subscribe(this.onProfileChange)
    this.aboutMe.subscribe(this.onProfileChange)
    this.selectedRes.subscribe(this.onProfileChange)



    this.favMusicArtist = ko.observable('Favourite Musical Artist');
    this.favMusicArtist.subscribe(this.onProfileChange);





    this.onStoreChange = function(){
      try{
        var state = this.store.getCurrentState();
        if(state.isSavingMyInfo() || state.isSearchingMajors()){
          this.isSpinnerVisible(true)
        }
        else if(state.majorsFound()){
          this.isSpinnerVisible(false)
          this.suggestedMajors(this.store.getMajors())
        }
        else{
          var info = this.store.getUserInfo();
          this.fullName(info.first + " " + info.last);
          var date = new Date(Date.parse(info.birthday));
          this.birthDay(date.getDate())
          this.birthMonth(date.getMonth() + 1)
          this.birthYear(date.getFullYear())
          this.gender(info.sex)
          this.selectedRes(info.res)
          this.residenceOptions(info.res_arr)
          this.setYearOfStudyObservable(info.year_of_study);
          this.hideYearOfStudyInputField();
          this.setMajor(info.major_name);
          this.aboutMe(info.about_me);
          this.favMusicArtist(info.music);
          this.isSpinnerVisible(false)
        }
        this.showSaveButton(false)
      }
      catch(err){
        console.log("## Something went wrong setting profile info ##")
        console.log(err)
      }
    }
    this.onStoreChange = this.onStoreChange.bind(this);
    this.store.sub(this.onStoreChange);



    this.showYearOfStudyInput = function(){
      this.isYearOfStudyInputVisible(true);
      this.isYearOfStudyInputFocused(true);
      this.isYearOfStudyTextVisible(false);
    }

    this.hideYearOfStudyInputField = function(){
      this.isYearOfStudyInputVisible(false);
      this.isYearOfStudyTextVisible(true);
    }

    this.onYearOfStudyLostFocus = function(state){
      if(!state){
        var year = this.yearOfStudyInput();
        this.dis.dispatch('selectYear', year);
      }
    }
    this.isYearOfStudyInputFocused.subscribe(this.onYearOfStudyLostFocus, this);


    this.setYearOfStudyObservable = function(year){
      year = Number(year);
      switch (year) {
        case 1:
          this.yearOfStudy('1st');
          break;

        case 2:
          this.yearOfStudy('2nd');
          break;

        case 3:
          this.yearOfStudy('3rd');
          break;

        case 4:
          this.yearOfStudy('4th');
          break;

        default:
          throw new Error('Bad Year.');
      }
    }


    this.showMajorInput = function(){
      this.isMajorInputVisible(true);
      this.isMajorInputFocused(true);
      this.isMajorTextVisible(false);
      this.partialMajor('');
    }

    this.getMajors = function(query){

      if(query.length > 0){
        this.dis.dispatch('getStudentMajors', query);
      }
      else{
        this.suggestedMajors([]);
      }
    }
    this.partialMajor.subscribe(this.getMajors,this);



    this.selectSuggestedMajor = function(data, event){
      if(!data.major_id || isNaN(data.major_id)){
        throw new Error("major_id is expected to be an attribute of majors.");
      }
      var majorId = data.major_id;
      this.dis.dispatch('selectMajor', majorId);
      this.suggestedMajors([]);
    }
    this.selectSuggestedMajor = this.selectSuggestedMajor.bind(this);


    this.setMajor = function(major){
      this.hideMajorInput();
      this.majorText(major);
    }
    this.setMajor = this.setMajor.bind(this);

    this.hideMajorInput = function(){
      this.suggestedMajors([]);
      this.isMajorInputVisible(false);
      this.isMajorTextVisible(true);
    }


    this.clearMajorResults = function(){
      this.suggestedMajors([]);
    }
    this.clearMajorResults = this.clearMajorResults.bind(this);

    this.saveMyInfo = function(vm, event){
      event.preventDefault()
      event.stopPropagation()
      var profileInfo = this.getProfileInfo()
      this.dis.dispatch('saveMyInfo',profileInfo)
    }
    this.saveMyInfo = this.saveMyInfo.bind(this)


    this.getProfileInfo = function(){
      var a = this.aboutMe()
      var g = this.gender()
      var m = this.birthMonth()
      var d = this.birthDay()
      var y = this.birthYear()
      var r = this.selectedRes()
      var music = this.favMusicArtist()
      return {a:a,g:g,d:d,m:m,y:y,r:r,music:music}
    }
    this.getProfileInfo = this.getProfileInfo.bind(this);

}

return {
    viewModel: UserInfoViewModel,
    template :template
};


}); // end define.
;

define('text!photo-controls/template.html',[],function () { return '\n<link rel="stylesheet"\n      href="./styles/components/profile-setter/profile-control-buttons.css?v=3.0">\n</link>\n\n<div id=\'profile-photo-buttons\'  data-bind="visible:isVisible()">\n\n  <label data-bind="click:webcamCapture"\n         class="profile-photo-button glyphicon glyphicon-camera">\n    <span class="profile-photo-upload-button">camera</span>\n  </label>\n\n\n\n  <label id=\'upload-profile-photo\'\n         class=\'profile-photo-button glyphicon glyphicon-open\'\n         for=\'img-upload-btn\'>\n          <span class="profile-photo-upload-button">upload</span>\n  </label>\n  <input type=\'file\'\n         id="img-upload-btn"\n         data-bind="event:{change:uploadPhoto}"\n         accept="image/*"/>\n\n\n  <label data-bind="click:saveProfilePhoto, visible:isSaveButtonVisible()"\n          class=\'profile-photo-button\'\n          id=\'save-profile-photo\'>\n          save\n  </label>\n</div>\n';});

/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
define('photo-controls/Component',['ko',
        'dispatcher/Dispatcher',
        'text!photo-controls/template.html',
        'jquery',
         'user/profile-setter/ProfileStore'],
function(ko,
         Dispatcher,
         template,
         $,
         ProfileStore){

  function PhotoControlsViewModel(params, componentInfo){

    this.store = ProfileStore.getInstance();
    this.dis = new Dispatcher();
    this.isVisible = ko.observable(false);
    this.isSaveButtonVisible = ko.observable(false);


    this.onStoreChange = function(){
      var state = this.store.getCurrentState();
      this.isVisible(state.isPhotoCropperVisible());
      this.isSaveButtonVisible(state.isNewPhotoLoaded());
    }
    this.onStoreChange = this.onStoreChange.bind(this);
    this.store.sub(this.onStoreChange);

    this.webcamCapture = function(){
      this.dis.dispatch('showWebcam');
    }

    this.uploadPhoto = function(data, event){
      this.readUrl(event.currentTarget);
    }
    this.uploadPhoto = this.uploadPhoto.bind(this);


    this.readUrl = function(input) {

        if (input.files && input.files[0]) {
            var file = input.files[0];
            var reader = new FileReader();
            this.inputElement = input;
            reader.onload = this.onFileLoaded;
            reader.readAsDataURL(file);
        }
    }
    this.readUrl = this.readUrl.bind(this);


    this.onFileLoaded = function(event){
      this.clearFileChooser(this.inputElement);
      var img = event.target.result;
      this.dis.dispatch('newImgUploaded', img);
    }
    this.onFileLoaded = this.onFileLoaded.bind(this);


    this.clearFileChooser = function(inputElement){
      var $el = $(inputElement);
      $el.wrap('<form>').closest('form').get(0).reset();
      $el.unwrap();
    }
    this.clearFileChooser = this.clearFileChooser.bind(this);



    this.saveProfilePhoto = function(){
      this.dis.dispatch('saveProfilePhoto');
    }
    this.saveProfilePhoto = this.saveProfilePhoto.bind(this);


}; // end PhotoControlsViewModel constructor.

return {
    viewModel: PhotoControlsViewModel,
    template :template
};


}); // end define.
;

define('text!profile-setter/view-models/webcam/template.html',[],function () { return '\n<link rel="stylesheet"\n      href="./styles/components/profile-setter/web-capture.css?v=3.1">\n</link>\n<div data-bind="visible:isVisible()" id="web-capture-holder">\n  <video id="profile-photo-player" autoplay></video>\n  <button id="take-photo-button" class="metal radial" data-bind="click:drawToCanvas"></button>\n  <canvas id="profile-photo-canvas" width=640 height=480></canvas>\n</div>\n';});

/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
define('webcam/Component',['ko',
        'dispatcher/Dispatcher',
        'text!profile-setter/view-models/webcam/template.html',
         'user/profile-setter/ProfileStore'],
function(ko,
         Dispatcher,
         template,
         ProfileStore){

  function WebcamCaptureViewModel(params, componentInfo){

    this.store = ProfileStore.getInstance();
    this.dis = new Dispatcher();
    this.isVisible = ko.observable(false);
    const player = document.getElementById('profile-photo-player');
    const canvas = document.getElementById('profile-photo-canvas');


    const constraints = {
      video: true,
    };

    this.getContext = function(){
      return canvas.getContext('2d');
    }

    this.getCanvas = function(){
      return canvas;
    }


    this.onStoreChange = function(){
      var state = this.store.getCurrentState()

      var isVisible = state.isWebcamVisible();
      if(isVisible){
        this.isVisible(true);
        this.attachVideoToVideoElement();
      }
      else{
        this.isVisible(false);
        this.stopCapture();
      }
    }
    this.onStoreChange = this.onStoreChange.bind(this);
    this.store.sub(this.onStoreChange);



    this.drawToCanvas = function(){
      var canvas = this.getCanvas();
      this.getContext().drawImage(player, 0, 0, canvas.width, canvas.height);
      var img = canvas.toDataURL('image/jpeg', 1.0);
      this.dis.dispatch('webcamCaptured', img);
      this.stopCapture();
    }
    this.drawToCanvas = this.drawToCanvas.bind(this);


    this.stopCapture = function() {
      const stream = player.srcObject;
      if(stream){
        const tracks = stream.getTracks();
        tracks.forEach(function(track) {
          track.stop();
        });
        player.srcObject = null;
      }
    }

    this.attachVideoToVideoElement = function(callback){
      var self = this;
      var nav = this.getNavigatorReference();
      nav.mediaDevices.getUserMedia(constraints)
         .then(this.onCameraStarted)
         .catch(this.onCameraError);
    }

    this.getNavigatorReference = function(){
      return navigator;
    }

    this.onCameraStarted = function(stream){
        player.srcObject = stream;
    }
    this.onCameraStarted = this.onCameraStarted.bind(this);

    this.onCameraError = function(err){
      if(/Permission/.test(err.message)){
        this.dis.dispatch('cameraPermissionError');
      }
    }
    this.onCameraError = this.onCameraError.bind(this);


}; // end WebcamCaptureViewModel constructor.

return {
    viewModel: WebcamCaptureViewModel,
    template :template
};


}); // end define.
;

define('text!permission-error/template.html',[],function () { return '<link rel="stylesheet"\n      href="./styles/components/profile-setter/permission-error.css?v=3.0">\n</link>\n\n<div id="permission-error-holder"\n    data-bind="visible:isVisible()">\n      <div>  We need your permission </div>\n      <div>  to turn on the camera </div>\n          <button data-bind="click:onOkay">\n            Okay I will change the settings\n          </button>\n          <button data-bind="click:onMaybeLater">\n                  Maybe later\n          </button>\n        <div>   </div>\n</div>\n';});

/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
define('permission-error/Component',['ko',
        'dispatcher/Dispatcher',
         'text!permission-error/template.html',
         'user/profile-setter/ProfileStore'],
function(ko,
         Dispatcher,
         template,
         ProfileStore){

  function PermissionErrorViewModel(params, componentInfo){
    this.store = ProfileStore.getInstance();
    this.dis = new Dispatcher();
    this.isVisible = ko.observable(false);

    this.onStoreChange = function(){
      var isVisible = this.store.getCurrentState().isPermissionErrorVisible();
      this.isVisible(isVisible);
    }
    this.onStoreChange = this.onStoreChange.bind(this);
    this.store.sub(this.onStoreChange);


    this.onOkay = function(){
      this.dis.dispatch('acknowledgePermissionNeed');
    }

    this.onMaybeLater = function(){
      this.dis.dispatch('hideProfileSetter');
    }

}; // end PermissionErrorViewModel constructor.

return {
    viewModel: PermissionErrorViewModel,
    template :template
};


}); // end define.
;
define('abstract-interfaces/ValidObject',[],
function(){
  var ValidObject = function(data, host){

    this.validateId = function(id){
      if(Number.isInteger(id) == false || id < 0)
        throw new Error('id malformed')
    }

    this.validateStr = function(str){
      if(typeof str != 'string' || str.length < 1){
        throw new Error('must be a non-empty string')
      }
    }

    this.validateBool = function(bool){
      var n = Number(bool)
      if(n !== 1 && n !== 0){
        throw new Error('must be 1 or 0')
      }
    }

  }
  return ValidObject;
});


define('people-models/Person',['ko','abstract-interfaces/ValidObject'],
function(ko, ValidObject){

  var Person = function(literal, host){
    if(Object.getPrototypeOf(literal) !== Object.prototype){
      throw new Error('Expected literal object!')
    }
    Object.setPrototypeOf(this, new ValidObject());
    this.constructor = Person
    this.addable = false

    this.getConstructorName = function(){
      return "Person";
    }

    this.defaultPhotoURL = "./assets/no-photo.jpg";
    this.smallPhotoURL = ko.observable(this.defaultPhotoURL);
    this.largePhotoURL = ko.observable(this.defaultPhotoURL);


    this.equals = function(other){
      return this.getId() === other.getId();
    }

    this.isPresent = function(){
      return false
    }


    this.setId = function(id){
      this.validateId(id)
      this.id = id;
    }
    this.setId(literal.id);

    this.getId = function(){
      return this.id;
    }

    this.setHost = (function(host){
        this.validateStr(host)
        this.host = host;
    }).bind(this)
    this.setHost(host);


    this.getHost = function(){
      return this.host;
    }


    this.setFirst = (function(first){
      this.validateStr(first);
      this.first = first;
    }).bind(this);
    this.setFirst(literal.first)


    this.setLast = (function(last){
      this.validateStr(last);
      this.last = last;
    }).bind(this);
    this.setLast(literal.last)

    this.setDefaultPhotoURL = function(){
      this.smallPhotoURL(this.defaultPhotoURL);
      this.largePhotoURL(this.defaultPhotoURL);
    }

    this.getDefaultPhotoURL = function(){
      return this.defaultPhotoURL;
    }

    this.getLargePhotoURL = function(){
      return this.largePhotoURL();
    }

    this.getRelativeLargePhotoURL = function(){
      return this.relativeLargePhotoURL
    }

    this.setLargePhotoURL = function(url){
      if(url && typeof url == 'string' && url.length > 0){
        this.largePhotoURL(this.host + '/' + url);
        this.relativeLargePhotoURL = url
      }
      else{
        this.largePhotoURL(this.defaultPhotoURL);
        this.relativeLargePhotoURL = this.defaultPhotoURL;
      }
    }
    this.setLargePhotoURL(literal.large_photo_url);


    this.setSmallPhotoURL = (function(url){
      if(typeof url != 'string' || url.length < 1){
        this.smallPhotoURL(this.defaultPhotoURL);
        this.relativeSmallPhotoURL = this.defaultPhotoURL
      }
      else{
        this.smallPhotoURL(this.host + '/' + url);
        this.relativeSmallPhotoURL = url
      }
    }).bind(this);
    this.setSmallPhotoURL(literal.small_photo_url);



    this.getSmallPhotoURL = function(){
      return this.smallPhotoURL();
    }

    this.getRelativeSmallPhotoURL = function(){
      return this.relativeSmallPhotoURL
    }

    this.getFirst = function(){
      return this.first;
    }

    this.getLast = function(){
      return this.last;
    }

    this.getRole = function(){
      return this.role;
    }

    this.setRole = (function(role){
      this.validateStr(role)
      this.role = role;
    }).bind(this)
    this.setRole(literal.role);


    this.isAddable = (function(){
      return this.addable;
    }).bind(this)

    this.setAddable = function(bool){
      this.addable = bool
    }

    this.isReal = function(){
      return true
    }


  }

  // factory method.


  Person.getRaw = function(){
    return {
        id:2,
        first:'First',
        last:'Last',
        small_photo_url:'profile_images/485s.jpg',
        large_photo_url:'profile_images/485l.jpg',
        role:'Student'
    }
  }

  Person.getDefaultPhotoURL = function(){
    return './assets/no-photo.jpg'
  }


  Person.getFake = function(){
    var raw = Person.getRaw();
    return new Person(raw,'https://www.profile.palolo.ca/');
  }

    Person.getCopy = function(p){
      return new Person({
        id:p.getId(),
        first:p.getFirst(),
        last:p.getLast(),
        role:p.getRole()
      }, p.getHost());
    }


  return Person;
})
;
define('people-models/Classmate',['ko',
        'people-models/Person'],
function(ko,
         Person){

  var Classmate = function(data, host){
    Object.setPrototypeOf(this, new Person(data, host));
    this.constructor = Classmate;
    this.present = ko.observable(false);
    this.addable = true

    this.getConstructorName = function(){
      return 'Classmate'
    }

    this.setActive = function(active){
      this.active = active;
    }
    this.setActive(data.is_active)

    this.isActive = function(){
      return this.active;
    }

    this.getLastSeen = function(){
      return this.lastLogin;
    }

    this.setLastSeen = function(lastSeen){
      if(typeof lastSeen != 'string'){
        throw new Error('last_login must be a string.');
      }
      this.lastLogin = lastSeen;
    }
    this.setLastSeen(data.last_login);

    this.setAge = function(age){
      if(Number.isInteger(age) == false || age < 15){
        throw new Error('malformed age.')
      }
      this.age = age;
    }
    this.setAge(data.age)

    this.getAge = function(){
      return this.age;
    }

    this.setRes = function(res){
      if(typeof res != 'string' || res.length < 1){
        throw new Error('malformed residence.')
      }
      this.res = res
    }
    this.setRes(data.res)


    this.getRes = function(){
      return this.res;
    }

    this.getFavouriteMusic = function(){
      return this.music;
    }

    this.setFavouriteMusic = function(music){
      if(!music || typeof music != 'string' || music.length < 1){
        throw new Error('music attribute is missing!');
      }
      this.music = music
    }
    this.setFavouriteMusic(data.music);

    this.setScore = function(score){
      if(score < 0.0 || score > 1.0){
        throw new Error('score must be between 0 and 1')
      }
      this.score = score;
    }
    this.setScore(data.score)

    this.getScore = function(){
      return this.score
    }

    this.isAddable = function(){
      return this.addable;
    }


    this.setPresent = function(p){
      if(typeof p == 'boolean'){
        this.present(p)
      }else{
        this.present(true);
      }
    }
    this.setPresent(data.present);

    this.isPresent = function(){
      return this.present();
    }

    this.setAbsent = function(){
      this.present(false);
    }


    this.setSharedClassCount = function(count){
      if(count == null){
        this.sharedClasses = 0;
      }
      else if(!Number.isInteger(count) || count < 0){
        throw new Error('count must be 0 or more.');
      }
      else{
      this.sharedClasses = count;
      }
    }
    this.setSharedClassCount(data.shared_classes);


    this.getSharedClassCount = function(){
      return this.sharedClasses;
    }

    this.setMajor = function(major){
      if(!major){
        this.major = 'Student';
      }else{
        this.major = major;
      }
    }
    this.setMajor(data.major);

    this.getMajor = function(){
      return this.major
    }

    this.setYearOfStudy = function(year){
      if(!year){
        this.yearOfStudy = 1;
      }
      else{
        this.yearOfStudy = year;
      }
    }
    this.setYearOfStudy(data.year_of_study);


    this.formatSchoolYear = function(year){
      switch (year) {
        case 1:
          return '1st Year, ';

        case 2:
          return '2nd Year, ';

        case 3:
          return '3rd Year, ';

        case 4:
          return '4th Year, ';

        default:
        return '1st Year, ';
      }
    }

    this.getEducationLevel = function(){
      return this.formatSchoolYear(this.yearOfStudy) + this.major;
    }


    this.getYear = function(){
      return this.yearOfStudy
    }




  }

  /**
    Takes the properties of a
    classmate and builds a new classmate.
    (assumes no functions exist on the argument)
  */
  Classmate.getCopy = function(c){

    return new Classmate({
      id:c.id,
      first:c.first,
      last:c.last,
      role:c.role,
      age:c.age,
      res:c.res,
      music:c.music,
      present:c.present,
      small_photo_url:c.smallPhotoURL(),
      large_photo_url:c.largePhotoURL(),
      last_login:c.getLastSeen(),
      shared_classes:c.getSharedClassCount()
    },c.host);
  }

  Classmate.getRaw = function(){
    var raw = Person.getRaw();
    raw.score = 1.0;
    raw.music = "Nirvana";
    raw.present = true;
    raw.last_login = '1w';
    raw.age = 15;
    raw.res = "Vanier";
    raw.is_pending_acceptance = false;
    raw.role = 'Student';
    raw.shared_classes = 0;
    raw.is_active = 1;
    return raw
  }

  Classmate.getFake = function(){
    var raw = Classmate.getRaw();
    return new Classmate(raw, Person.getFake().getHost());
  }

  Classmate.getFake2 = function(){
    var raw = Classmate.getRaw();
    raw.id = raw.id + 1;
    return new Classmate(raw, Person.getFake().getHost());
  }

  return Classmate;

});

define('people-models/Pal',['ko','people-models/Classmate'],
function(ko, Classmate){

  var Pal = function(raw, host){
    Object.setPrototypeOf(this, new Classmate(raw, host));
    this.constructor = Pal;
    this.isNew = ko.observable(false);
    this.isInvitedToRoom = ko.observable(false)
    this.roomId = null
    this.is_new = 0;

    this.getConstructorName = function(){
      return 'Pal'
    }

    this.unsetIsInvitedToRoom = function(){
      this.isInvitedToRoom(false)
    }

    this.setIsInvitedToRoom = function(roomId){
      this.validateId(roomId)
      this.isInvitedToRoom(true)
      this.roomId = roomId
    }

    this.getInvitedRoomId = function(){
      return this.roomId
    }


    this.setIsNew = function(isNew){
      if(isNew != 0 && isNew != 1){
        throw new Error('is_new must be 0 or 1.');
      }
      if(isNew == 1){
        this.isNew(true);
        this.is_new = 1;
      }
      else{
        this.isNew(false);
        this.is_new = 0;
      }
    }
    this.setIsNew(raw.is_new);


    this.getRawNew = function(){
      return this.is_new;
    }


    this.setAsNew = function(){
      this.isNew(true);
      this.is_new = 1;
    }

    this.setAsOld = function(){
      this.isNew(false);
    }

    this.isAddable = function(){
      return false
    }
  }

  Pal.getRaw = function(){
      var raw = Classmate.getRaw();
      raw.is_new = 0;
      return raw;
    }

  Pal.getFake = function(){
    var classmate = Classmate.getRaw()
    classmate.is_new = 0;
    var host = 'host';
    return new Pal(classmate, host);
  }


  return Pal;

});

define('people-models/PersonCollection',['people-models/Classmate'],
function(Classmate){
  var PersonCollection = function(data, host){

    this.getConstructorName = function(){
      return 'PersonCollection'
    }

    this.col = []

    this.isCollection = function(){
      return true
    }

    this.clear = function(){
      this.col = []
    }

    this.getOldPals = function(){
      var col = new PersonCollection()
      this.col.forEach(function(p){
        if(!p.isNew || p.isNew() == false){
          col.add(p)
        }
      })
      return col
    }

    this.getNewPals = function(){
      var col = new PersonCollection()
      this.col.forEach(function(p){
        if(p.isNew && p.isNew() == true){
          col.add(p)
        }
      })
      return col
    }

    this.getPersonById = (function(id){
      var match = null
      this.col.forEach(function(p){
        if(p.getId() == id){
          match = p
          return
        }
      })
      return match
    }).bind(this)

    this.add = (function(p){
      if(typeof p !== 'object'){
        throw new Error('Can only add objects to Person collection')
      }
      else if(this.contains(p)){
        throw new Error('Duplicate entry')
      } else {
        this.col.push(p)
        this.sortByPresence()

      }
    }).bind(this)


    this.sortByPresence = function(){
      this.col.sort(function(p1,p2){
         if(p1.isPresent() && !p2.isPresent()){
           return -1
         } else if(!p1.isPresent() && p2.isPresent()){
           return 1
         } else {
           return 0
         }
      })
    }


    this.contains = (function(p){
      for(var i = 0; i < this.col.length; i++){
        if(this.col[i].equals(p)){
          return true
        }
      }
      return false
    }).bind(this)


    this.remove = (function(person){
      var index = -1;
      for(var i = 0; i < this.col.length; i++){
        if(person.id == this.col[i].getId()){
          index = i
          break
        }
      }
      if(index >= 0)
        this.col.splice(i,1);
    }).bind(this)


    this.applyToMatch = function(p, fun){
      if(typeof p != 'object' || !p.getId)
        throw new Error('missing person arg.')
      if(typeof fun != 'function')
        throw new Error('missing function arg.')
      this.col.forEach(function(o){
        if(o.getId() == p.getId()) fun(o)
      })
    }


    this.duplicate = (function(other){
      if(typeof other !== 'object' || !other.getConstructorName || other.getConstructorName() !== 'PersonCollection'){
        throw new Error('Expected a PersonCollection')
      }
      this.col = []
      var arr = other.toArray()
      var self = this
      arr.forEach(function(classmate){
        self.add(classmate)
      })
    }).bind(this)

    this.toArray = function(){
      return this.col
    }

    this.compare = (function(a,b){
        var score = this.byScore(a,b);
        var presence = this.byPresence(a,b);
        return presence == 0 ? score : presence
    }).bind(this)

    this.byScore = (function(a, b){
      if(a.getScore() > b.getScore()){
        return -1;
      } else if(a.getScore() < b.getScore()){
        return 1;
      }else if(a.getId() < b.getId()){
        return -1
      }
      else{
        return 1
      }
    }).bind(this)

    this.byPresence = (function(a,b){
      if(a.isPresent() && !b.isPresent()){
        return -1
      }
      else if(!a.isPresent() && b.isPresent()){
        return 1;
      }
      else{
        return 0;
      }
    }).bind(this)

    this.getSize = function(){
      return this.col.length
    }


    this.get = function(index){
      return this.col[index]
    }

    /**
      returns true iff this collection
      has the same elements in the same order.
    */
    this.equals = function(other){

      if(!other || !other.getConstructorName)
        return false
      else if(this.getSize() !== other.getSize())
        return false

      for(var i = 0; i < this.getSize(); i++){
        if(this.col[i].equals(other.get(i)) == false){
          return false
        }
      }
      return true;
    }

  } // end constructor

  PersonCollection.getFake = function(){
    var c1 = Classmate.getFake()
    var c2 = Classmate.getFake()
    c2.setId(c2.getId() + 1)
    var c = new PersonCollection()
    c.add(c1)
    c.add(c2)
    return c
  }

  return PersonCollection;
});


define('people-store/PeopleRemoteService',['socketio',
        'ActiveRemoteService',
        'dispatcher/Dispatcher',
        'people-models/Person',
        'people-models/Pal',
        'people-models/Classmate',
        'people-models/PersonCollection'],
function(io,
         ActiveRemoteService,
         Dispatcher,
         Person,
         Pal,
         Classmate,
         PersonCollection){

  var instance = null;

  var PeopleRemoteService = function(){

    Object.setPrototypeOf(this,new ActiveRemoteService());
    this.setMicroServer("friends");
    this.constructor = PeopleRemoteService;
    this.dis = new Dispatcher();
    this.REFRESH_RATE = 5000;

    this.getConstructorName = function(){
      return 'PeopleRemoteService';
    }

    this.init = (function(){
      this.setSock(this.onSock);
    }).bind(this)


    this.onSock = (function(){
      this.sock.on('connect',this.getPalList);
      this.sock.on('connect',this.getPalRequestList);
      this.sock.on('palList', this.onPalList);
      this.sock.on('palRequestSent',this.onPalRequestSent);
      this.sock.on('palRequestReceived',this.onPalRequestRecieved);
      this.sock.on('palRequestList',this.onPalRequestList);
      this.sock.on('palRequestAccepted', this.onPalRequestAccepted);
      this.sock.on('classList', this.onClassList);
      this.sock.on('io_error',this.onError);
    }).bind(this)


    this.onAuth = function(auth){
      if(auth && auth.state == 'authenticated'){
        this.init();
      }
    }
    this.onAuth = this.onAuth.bind(this);
    this.dis.reg('authState', this.onAuth);


    this.onError = function(err){
      console.log('Something went wrong on the relationship server.');
      alert(err);
    }
    this.onError = this.onError.bind(this);




    this.getPalList = function(){
      this.sock.emit('getPalList');
      var self = this;
      self.timerId = setTimeout(function(){
        self.getPalList();
      },self.REFRESH_RATE);
    }
    this.getPalList = this.getPalList.bind(this);



    this.onPalList = (function(pals){
      var url = this.getServerURL();
      var collection = new PersonCollection()
      pals.forEach(function(pal){
        collection.add(new Pal(pal, url))
      })
      this.dis.dispatch('palList',collection)
    }).bind(this)



    this.onGroupInfo = function(g){
      this.init();
      this.sock.emit('getClassList',g.getId());
      var self = this;
      if(typeof this.getClassTimerId == 'number'){
        clearTimeout(this.getClassTimerId);
      }
      this.getClassTimerId = setTimeout(function(){
        self.onGroupInfo(g);
      },self.REFRESH_RATE);
    }
    this.onGroupInfo = this.onGroupInfo.bind(this);
    this.onGroupInfoId = this.dis.reg('groupInfo', this.onGroupInfo);


    this.onClassList = (function(classmates){
      var collection = new PersonCollection();
      var url = this.getServerURL();
      classmates.forEach(function(classmate){
        collection.add(new Classmate(classmate, url))
      })
      this.dis.dispatch('classList',collection)
    }).bind(this);




    this.recordFriendClick = (function(p){
      this.sock.emit('recordFriendClick',this.flatten(p));
    }).bind(this)
    this.focusPersonId = this.dis.reg('focusPerson',this.recordFriendClick);


    /**
      p is an instance of Person (not a subclass)
    */
    this.onAddPal = (function(p){
      this.sock.emit('addPal', this.flatten(p));
    }).bind(this)
    this.addPalId = this.dis.reg('addPal',this.onAddPal);


    this.onPalRequestSent = function(p){
      var p = Classmate.getCopy(p)
      this.dis.dispatch('palRequestSent',p);
    }
    this.onPalRequestSent = this.onPalRequestSent.bind(this);

    this.onPalRequestRecieved = function(p){
      var pal = new Classmate(p,this.getServerURL());
      this.dis.dispatch('palRequestReceived', pal);
    }
    this.onPalRequestRecieved = this.onPalRequestRecieved.bind(this);


    this.acceptRequest = function(p){
      this.sock.emit('acceptPalRequest',p);
    }
    this.acceptRequest = this.acceptRequest.bind(this);
    this.acceptRequestId = this.dis.reg('acceptRequest',this.acceptRequest);


    this.onPalRequestAccepted = function(p){
      var host = this.getServerURL();
      var pal = new Pal(p, host);
      pal.setAsNew();
      this.dis.dispatch('palRequestAccepted',pal);
    }
    this.onPalRequestAccepted = this.onPalRequestAccepted.bind(this);



    this.getPalRequestList = function(){
      this.sock.emit('getPalRequestList');
      var self = this;
      self.palRequestTimerId = setTimeout(function(){
        self.getPalRequestList();
      }, self.REFRESH_RATE);
    }
    this.getPalRequestList = this.getPalRequestList.bind(this);


    this.onPalRequestList = function(requests){
      var people = [];
      var url = this.getServerURL();
      requests.forEach(function(person){
        var p = new Person(person,url);
        people.push(p);
      })
      this.dis.dispatch('palRequestList',people);
    }
    this.onPalRequestList = this.onPalRequestList.bind(this);

    this.onDenyRequest = function(p){
      this.sock.emit('denyRequest',p);
    }
    this.onDenyRequest = this.onDenyRequest.bind(this);
    this.denyRequestId = this.dis.reg('denyRequest',this.onDenyRequest)

  }
  return {
    getInstance:function(){
      if(!instance){
        instance = new PeopleRemoteService();
      }
      return instance;
    },
    getNew:function(){
      return new PeopleRemoteService();
    }
  };
})
;

define('people-models/NullPerson',['people-models/Person','ko'],
function(Person, ko){

  var NullPerson = function(info){
    var defaultPerson = Person.getFake();
    Object.setPrototypeOf(Object.getPrototypeOf(this), defaultPerson);
    this.constructor = NullPerson;
    this.getConstructorName = function(){
      return "NullPerson";
    }


    this.getId = function(){
      return -1;
    }

    this.isNew = function(){
      return false;
    }

    this.isReal = function(){
      return false
    }

    this.getLastSeen = function(){
      return ''
    }
  }
  return NullPerson;
})
;
define('people-models/PendingPal',['people-models/Classmate'],
function(Classmate){

  var PendingPal = function(classmate){
    Object.setPrototypeOf(this, classmate);
    this.constructor = PendingPal;

    this.isAddable = function(){
      return false
    }
  }

  PendingPal.build = function(person){
    return new PendingPal(person)
  }
  
  return PendingPal;

});

define('people-store/PeopleStore',['dispatcher/Dispatcher',
        'abstract-interfaces/Store',
        'people-store/PeopleRemoteService',
        'people-models/Pal',
        'people-models/NullPerson',
        'people-models/PendingPal',
        'people-models/PersonCollection'],
function(Dispatcher,
        Store,
        PeopleRemoteService,
        Pal,
        NullPerson,
        PendingPal,
        PersonCollection){

   var instance = null;

   var PeopleStore  = function(){

     Object.setPrototypeOf(this, new Store());
     this.dis = new Dispatcher();
     this.remote = PeopleRemoteService.getInstance();
     this.newPalList = new PersonCollection()
     this.palList = new PersonCollection();
     this.palRequests = [];
     this.classList = new PersonCollection();
     this.classListVisible = false;
     this.focusedPerson = new NullPerson();
     this.isPalRequestSentVisible = false;
     this.lastPalRequested = null;
     this.spinnerOn = true




     this.onAddPal = (function(){
       this.focusedPerson = PendingPal.build(this.focusedPerson)
       this.showPalRequestSent()
       this.pub()
     }).bind(this)
     this.addPalId = this.dis.reg('addPal',this.onAddPal)


     this.getFocusedPerson = function(){
       return this.focusedPerson
     }

     this.getPalCount = function(){
       return this.palList.getSize()
     }

     this.getDis = function(){
       return this.dis;
     }

     this.getPalList = function(){
       return this.palList.getOldPals()
     }

     this.getClassList = function(){
       return this.classList;
     }

     this.getPalRequests = function(){
       return this.palRequests;
     }

     this.onPalList = (function(list){
       if(!list || !list.isCollection || !list.isCollection())
        throw new Error('Expected a collection instance.')
       this.palList = list
       this.updateFocusedPerson()
       this.spinnerOn = false
       this.pub();
     }).bind(this)
     this.onPalsId = this.dis.reg('palList',this.onPalList);


     this.isSpinnerVisible = function(){
       return this.spinnerOn
     }


     this.getNewPals = function(){
       return this.palList.getNewPals()
     }

     // if the state of the focused person has changed
     // then it is updated.
     this.updateFocusedPerson = (function(){
       var old = this.getFocusedPerson()
       var fresh = this.palList.getPersonById(old.getId())
       if(fresh && old.isPresent() != fresh.isPresent()){
            this.focusedPerson = fresh
            this.dis.dispatch('updateFocusPerson', this.focusedPerson)
       }
     }).bind(this)


     this.onClassList = (function(collection){
       this.palList.toArray().forEach(function(pal){
         collection.applyToMatch(pal,function(match){
           match.setAddable(false)  // already a friend.
         })
       })
       this.classList.duplicate(collection);
       this.pub();
     }).bind(this);
     this.onClassListId = this.dis.reg('classList', this.onClassList);

     this.isClassListVisible = (function(){
       return this.classListVisible;
     }).bind(this)

     this.setFocusedPerson = function(p){
       this.focusedPerson = p
     }

     this.onFocusPerson = (function(p){
       this.focusedPerson = p;
       this.onAcknowledgeNewPal(p);
       this.pub();
     }).bind(this)
     this.onFocusPersonId = this.dis.reg('focusPerson', this.onFocusPerson);



     this.onAcknowledgeNewPal = (function(p){
       if(p.constructor.name == 'Pal'){
         this.palList.applyToMatch(p, function(match){
           match.setAsOld();
         })
       }
     }).bind(this)


     this.getFocusedPerson = function(){
       return this.focusedPerson;
     }

     this.onShowClassList = (function(featureName){
       featureName == 'classList' ? this.classListVisible = true : this.classListVisible = false;
       this.pub();
     }).bind(this)
     this.showClassListId = this.dis.reg('courseFeatureSelection',this.onShowClassList);

     this.onHideClassList = (function(){
       this.classListVisible = false;
       this.pub();
     }).bind(this)
    this.hideClassListId = this.dis.reg('hideClassList',this.onHideClassList);


    this.onGrpInfo = (function(grp){
      if(grp.getId() != this.currentGrpId) this.setNoPerson()
    }).bind(this)
    this.onGrpInfoId = this.dis.reg('groupInfo',this.onGrpInfo);


    this.setNoPerson = (function(){
      this.focusedPerson = new NullPerson();
      this.pub();
    }).bind(this)
    this.dis.reg('openNews',this.setNoPerson)


    this.onShowGroupView = (function(){
      this.focusedPerson = new NullPerson();
      this.pub();
    }).bind(this)
    this.showGroupId = this.dis.reg('showGroupView', this.onShowGroupView);


    this.isPalRequestSent = (function(){
      return this.isPalRequestSentVisible;
    }).bind(this)


    this.lastPalRequestPal = (function(){
      return this.lastPalRequested;
    }).bind(this)

    /**

    */
    this.onPalRequestSent = (function(pal){
      this.lastPalRequested = pal;
      this.classList.remove(pal);
      if(this.focusedPerson.getId() == pal.getId())
        this.focusedPerson = PendingPal.build(this.focusedPerson)
      this.showPalRequestSent()
      this.pub();
    }).bind(this)
    this.palRequestSentId = this.dis.reg('palRequestSent',this.onPalRequestSent);

    this.showPalRequestSent = (function(){
      var self = this;
      this.isPalRequestSentVisible = true;
      this.timerId = setTimeout(function(){
        self.isPalRequestSentVisible = false;
        self.pub();
      },3000);
    }).bind(this)

    this.onPalRequestReceived = (function(p){
      this.palRequests.push(p);
      this.pub();
    }).bind(this)
    this.palRequestReceivedId = this.dis.reg('palRequestReceived', this.onPalRequestReceived);


    this.onPalRequestAccepted = (function(p){
      this.palList.add(p);
      this.pub();
    }).bind(this)
    this.onRequestAcceptedId = this.dis.reg('palRequestAccepted', this.onPalRequestAccepted);

    this.getPalRequestList = function(){
      return this.palRequests;
    }

    this.addPal = function(p){
      if(p instanceof Pal)
        this.palList.push(p);
    }
    this.addPal = this.addPal;

    this.onPalRequestList = function(palRequests){
      this.palRequests = palRequests;
      this.pub();
    }
    this.onPalRequestList = this.onPalRequestList.bind(this);
    this.dis.reg('palRequestList', this.onPalRequestList);

    this.onAcceptRequest = function(p){
      var index = this.findPalRequest(p);
      if(index >= 0){
        var removedPerson = this.palRequests.splice(index,1);
        this.palList.add(removedPerson);
        this.pub();
      }
    }
    this.onAcceptRequest = this.onAcceptRequest.bind(this);
    this.acceptRequestId = this.dis.reg('acceptRequest',this.onAcceptRequest);


    /**
      removes person p from the palRequests list
      (if they are in the list.)
    */
    this.onDenyRequest = function(p){
      var index = this.findPalRequest(p)
      if(index >= 0){
        this.palRequests.splice(index, 1)
        this.pub()
      }
    }
    this.onDenyRequest = this.onDenyRequest.bind(this);
    this.denyRequestId = this.dis.reg('denyRequest',this.onDenyRequest)


    this.findPalRequest = function(p){
      var r = this.palRequests
      var index = -1
      for(var i = 0; i < r.length; i++){
        if(r[i].getId() == p.getId()){
          index = i
          break
        }
      }
      return index;
    }
    this.findPalRequest = this.findPalRequest.bind(this);




  } // end





   // this.onCourseGroupInfoCallbackId = this.dis.reg('groupInfo', this.onCourseGroupInfo);



    return {
      getInstance:function(){
        if(!instance){
          instance = new PeopleStore();
        }
        return instance;
      },
      getNew:function(){
        return new PeopleStore();
      }
    }
  })
;

define('text!notification/template.html',[],function () { return '\n<link rel="stylesheet"\n      href="./styles/components/notification/style.css?v=2.0"></link>\n\n  <div id="notification-holder" data-bind="visible:isVisible()">\n\n    <span class="glyphicon glyphicon-bell"\n          data-bind="click:openNotifications">\n\n      <span id="notification-bell-count"\n            class="notification-number-background"\n            data-bind="visible:computeUnseenCount() > 0">\n            <span  class="notification-number"\n                    data-bind="text:computeUnseenCount()">\n            </span>\n      </span>\n    </span>\n\n\n    <span data-bind="visible:isNotifcationsOpen()">\n      <span class="arrow-up notifications-arrow-up"></span>\n\n      <ul id="notification-list"\n          data-bind="foreach:notifications,\n                     complementClick: closeNotifications">\n\n            <li class="notification-row"\n                data-bind="css:{\'notification-seen\':getHasBeenSeen()}, click:$parent.onNotificationClicked">\n              <img  class="notification-profile-image"\n                    data-toggle="tooltip"\n                    data-bind="attr:{ src : getPhotoURL(), title : getFirstName() + \' \' + getLastName() }">\n              </img>\n              <span class="notification-content-holder">\n                <div class=\'notification-content\'\n                      data-bind="text:messageSnippet()">\n                </div>\n                <div class="notification-date">\n                    <span>Sent </span>\n                    <span data-bind="text:getMessageTimestamp()"></span>\n                    <span data-bind="visible:getConstructorName() === \'ForumNotification\'">\n                      <!-- <span data-bind="text:getForumName()"></span> -->\n                    </span>\n                </div>\n\n              </span>\n            </li>\n      </ul>\n\n\n    </span>\n\n  </div>\n';});

define('notification/models/Notification',['ko','people-models/Person'],
function(ko, Person){

  function Notification(raw, host){

    this._hasBeenSeen = ko.observable(false);
    this.messageSnippet = ko.observable('');
    this.person = new Person(raw, host);


    this.getPerson = function(){
      return this.person;
    }

    this.getFirstName = function(){
      return this.person.getFirst();
    }

    this.getLastName = function(){
      return this.person.getLast();
    }

    this.getPhotoURL = function(){
      return this.person.getSmallPhotoURL() + "?=" + Date.now();
    }
    this.getPhotoURL = this.getPhotoURL.bind(this);

    this._isValidString = function(attr){
      if(!attr || typeof attr != 'string' || attr.length < 1){
        throw new Error('attribute must be a non-empty string.');
      }
    }

    this.getMessageId = function(){
      return this.id;
    }


    this.setMessageId = function(id){
      if(!id || Number.isInteger(id) == false || id < 1){
        throw new Error('message_id must be a positive integer.');
      }
      this.id = id;
    }
    this.setMessageId(raw.message_id);



    this.setHost = function(host){
      this._isValidString(host);
      this._host = host;
    }
    this.setHost(host);

    this.getHost = function(){
      return this._host;
    }


    this.setMessageSnippet = function(snippet){
      this._isValidString(snippet);
      this.messageSnippet(snippet);
    }
    this.setMessageSnippet = this.setMessageSnippet.bind(this);
    this.setMessageSnippet(raw.text);


    this.setMessageTimetamp = function(timestamp){
      this._isValidString(timestamp);
      this._timestamp = timestamp;
    }
    this.setMessageTimetamp(raw.timestamp);


    this.getMessageTimestamp = function(){
      return this._timestamp;
    }

    this.setHasBeenSeen = function(){
      this._hasBeenSeen(true);
    }

    this.setSeenTo = function(bool){
      if(typeof bool != 'number' || (bool != 0 && bool != 1)){
        throw new Error('seen must be 0 or 1.');
      }
      if(bool == 1){
        this._hasBeenSeen(true);
      }
      else{
        this._hasBeenSeen(false);
      }
    }
    this.setSeenTo(raw.seen);




    this.getHasBeenSeen = function(){
      return this._hasBeenSeen();
    }





}; // end consturctor


return Notification;

}); // end define.
;

define('notification/NotificationRemoteService',['ActiveRemoteService',
        'socketio',
        'dispatcher/Dispatcher',
        'notification/models/Notification'],
function(ActiveRemoteService,
         io,
         Dispatcher,
         Notification){

  var NotificationRemoteService = function(){
      Object.setPrototypeOf(this,new ActiveRemoteService());
      this.setMicroServer("notifications");
      this._io = io;
      this.dis = new Dispatcher();


      this.initialize = function(){
        this.setSock();
      }


      this.connect = function(){
        if(this.sock){
            this.sock.connect();
        }
      }

      this.registerOnNotificationsUpdate = function(callback){
        this._checkType(callback);
        this.sock.on('notifications', callback);
      }


      this.setChatMsgNotifSeen = function(notif){
        if(notif instanceof Notification == false){
          throw new Error('notif must be a Notification.');
        }

        this.sock.emit('chatNotifSeen',{senderId:notif.getPerson().getId()});
      }


      this._checkType = function(cb){
        if(typeof cb != 'function'){
          throw new Error('callback needs to be a function.');
        }
      }
  }

  return NotificationRemoteService;
})
;
define('notification/models/ViewedChatNotification',['ko',
        'notification/models/Notification',
        'people-models/Person'],
function(ko,
        AbstractNotification,
        Person){

  function ViewedChatNotification(rawNotification, host){

    Object.setPrototypeOf(this, new AbstractNotification(rawNotification, host));

    this._hasBeenSeen = ko.observable(true);

    this.getConstructorName = function(){
      return 'ViewedChatNotification';
    }

}; // end constructor.


  ViewedChatNotification.getFake =  function(senderId){
      var raw = ViewedChatNotification.getRaw();
      return new ViewedChatNotification(raw, 'http://host.com');
    }


  ViewedChatNotification.getRaw  = function(){
    var o1 = {
     message_id:100,
     text: "message snippet.",
     timestamp: "Dec 12 2019",
     seen:1,
     type:'seen-chat'
   }
   var o2 = Person.getRaw();
   return Object.assign(o1,o2);
  }


  return ViewedChatNotification;


}); // end define.
;
define('notification/models/UnseenChatNotification',['ko',
        'notification/models/Notification',
        'people-models/Person'],
function(ko,
        Notification,
        Person){

  function UnseenChatNotification(raw, host){

    Object.setPrototypeOf(this, new Notification(raw, host));
    this.getConstructorName = function(){
      return 'UnseenChatNotification';
    }
};


    UnseenChatNotification.getFake = function(){
      var raw = UnseenChatNotification.getRaw();
      return new UnseenChatNotification(raw, 'https://host');
    }

    UnseenChatNotification.getRaw = function(){
      var o1 = {
        message_id:1,
        text: "message snippet.",
        timestamp: "Dec 12 2019",
        seen:0,
        type:'chat'
      }
      var o2 = Person.getRaw();
      return Object.assign(o1,o2);
    }



  return UnseenChatNotification;


}); // end define.
;
define('notification/models/ForumNotification',['ko',
        'notification/models/Notification',
        'people-models/Person'],
function(ko,
         Notification,
         Person){

  var ForumNotification = function(raw, host){

    Object.setPrototypeOf(this, new Notification(raw, host));

    this.getConstructorName = function(){
      return 'ForumNotification';
    }

    this.getForumName = function(){
      return this.forumName;
    }

    this.setForumName = function(forum){
      this._isValidString(forum,'forum_name must be a attribute.');
      this.forumName = forum;
    }
    // this.setForumName(raw.forum_name);


    this.getGroupId = function(){
      return this.grpId;
    }

    this.setGroupId = function(id){
      if(id && Number.isInteger(id) && id > 0){
        this.grpId = id;
      }
      else{
        throw new Error('group_id must be a positive integer.');
      }
    }
    this.setGroupId(raw.group_id);


  };


    ForumNotification.getFake = function(){
      var raw = ForumNotification.getRaw();
      return new ForumNotification(raw, 'https://host');
    }

    ForumNotification.getRaw = function(){
      var o1 = {
        message_id:2,
        group_id:55,
        text: "message snippet.",
        timestamp: "Dec 12 2019",
        forum_name:"MATH1300 M",
        seen:0,
        type:'forum'
      }
      var o2 = Person.getRaw();
      return Object.assign(o1,o2);
    }



  return ForumNotification;


}); // end define.
;
define('notification/Component',['ko',
        'dispatcher/Dispatcher',
        'text!notification/template.html',
        'notification/NotificationRemoteService',
        'notification/models/ViewedChatNotification',
        'notification/models/UnseenChatNotification',
        'notification/models/ForumNotification',
        'jquery'],
function(ko,
         Dispatcher,
         template,
         NotificationRemoteService,
         ViewedChatNotification,
         UnseenChatNotification,
         ForumNotification,
         $){

  function NotificationViewModel(params, componentInfo){

  this._remoteService = new NotificationRemoteService();
  this.dis = new Dispatcher();
  this.isVisible = ko.observable(false);
  this.notifications = ko.observableArray([]);
  this.isNotifcationsOpen = ko.observable(false);


  this.onAuth = function(auth){
    if(auth.state == 'authenticated'){
      this._remoteService.initialize();
      this._remoteService.registerOnNotificationsUpdate(this.onNotifications);
      this._remoteService.connect();
    }
  }
  this.onAuth = this.onAuth.bind(this);
  this.dis.reg('authState', this.onAuth);


  this.onNotificationClicked = function(notification){
      notification.setHasBeenSeen();
      if(notification.getConstructorName() == 'ForumNotification'){
        this.dis.dispatch('selectedGroupId', notification.getGroupId());
      }
      else{
        var p = notification.getPerson();
        console.log(p);
        console.log(p);
        this.dis.dispatch('focusPerson', p);
        this._remoteService.setChatMsgNotifSeen(notification);
      }
    this.closeNotifications();
  }
  this.onNotificationClicked = this.onNotificationClicked.bind(this);

  this.oldUnseenCount = 0;
  this.computeUnseenCount = function(){
    var unseenCount = 0;
    for(var i = 0; i < this.notifications().length; i++){
      var notif = this.notifications()[i];
      if(notif.getHasBeenSeen() == false){
        unseenCount++;
      }
      if(unseenCount > this.oldUnseenCount && unseenCount > 0){
        this.ding();
      }
    }
    this.oldUnseenCount = unseenCount;
    return unseenCount;
  }
  this.computeUnseenCount = this.computeUnseenCount.bind(this);
  this.unseenCount = ko.computed(this.computeUnseenCount);


  this.dingDone = true;
  this.ding = function(callback){
    var self = this;
    if(self.dingDone){
      var audio = new Audio('./assets/audio/play-ding.mp3');
      self.dingDone = false;
      audio.play().catch(function(err){
        console.log(err);
      }).finally(function(){
        self.dingDone = true;
      });
      if(callback)
        callback(true);
    }
    else if(callback){
      callback(false);
    }
  }
  this.ding = this.ding.bind(this);


  this.onNotifications = function(notifs){
    try{
      this.notifications([]);
      if(!notifs){
        // console.log('no new notifications.');
      }
      for(var i = 0; i < notifs.length; i++){
        this.binNotification(notifs[i]);
      }
      this.isVisible(this.notifications().length > 0);
    }
    catch(err){
      console.log(err);
      console.error('Something went wrong receiving the notifications.');
    }
  }
  this.onNotifications = this.onNotifications.bind(this);


  this.binNotification = function(rawNotif){
    var type = rawNotif.type;
    var wrappedNotif = null;
    var host = this._remoteService.getServerURL();

    switch(type){

        case 'chat':
          wrappedNotif = new UnseenChatNotification(rawNotif, host);
          this.notifications.unshift(wrappedNotif);
          break;

        case 'seen-chat':
          wrappedNotif = new ViewedChatNotification(rawNotif, host);
          this.notifications.push(wrappedNotif);
          break;

        case 'forum':
          wrappedNotif = new ForumNotification(rawNotif, host);
          this.notifications.push(wrappedNotif);
          break;

        default:
            throw new Error(type + ' is an unknown notification type.');
        }
  }



  this.openNotifications = function(){
    this.isNotifcationsOpen(true);
  }


  this.closeNotifications = function(){
    this.isNotifcationsOpen(false);
  }
  this.closeNotifications = this.closeNotifications.bind(this);




}; // end NotificationViewModel constructor.


return {
    viewModel: NotificationViewModel,
    template :template
};

}); // end define.
;

define('text!york-forum/poster/template.html',[],function () { return '<link rel="stylesheet"\n      href="./styles/components/york-forum/jquery.cleditor.css?v=2.0">\n</link>\n\n<div class=\'background-dimmer\' data-bind=\'visible:isVisible()\'>\n\n  <div data-bind=\'visible:isPostSuccessful()\'> Success </div>\n  <div id=\'york-forum-poster\' data-bind=\'complementClick:hide\' >\n    <textarea id=\'forum-poster-title-holder\'\n              placeholder="What\'s new at YU?"\n              maxlength="300"\n              data-bind=\'textInput:title, hasFocus:titleHasFocus\'>\n    </textarea>\n    <textarea id=\'forum-input\'\n              name="input"\n              placeholder="Text (Optional)">\n\n    </textarea>\n    <button id=\'york-forum-post-button\'\n            data-bind=\'click:post, enable:isPostable() && isValidBodyLength()\'>\n      <span data-bind=\'visible:!isSpinnerOn()\'>POST</span>\n      <span id=\'post-spinner\'\n           class=\'nano-spinner\'\n           data-bind=\'visible:isSpinnerOn()\'>\n      </span>\n    </button>\n    <div data-bind=\'text:bodyErrorMessage()\'></div>\n  </div>\n\n</div>\n';});


define('york-forum/models/ForumPost',['abstract-interfaces/ValidObject',
        'ko'],
function(ValidObject, ko){

  var ForumPost = function(raw){

    Object.setPrototypeOf(this, new ValidObject())
    this.expanded = ko.observable(false)
    this.comment = ko.observable('')
    this.replies = ko.observableArray([])
    this.replyCount = ko.observable(0)
    this.voteCount = ko.observable(0)
    this.alreadyVoted = ko.observable(false)
    this.rep = 0

    this.setAlreadyVoted = function(already){
      if(already == null){
        this.alreadyVoted(false)
      } else {
        this.validateId(already)
        this.alreadyVoted(true)
      }
    }
    this.setAlreadyVoted(raw.already_voted)

    this.isAlreadyVoted = function(){
      return this.alreadyVoted()
    }

    this.getRootReplyCount = function(){
      return this.replies().length
    }


    this.setVoteCount = function(votes){
      if(votes == null){
        this.voteCount(0)
      } else{
        this.validateId(votes + 1)
        this.voteCount(votes)
      }
    }
    this.setVoteCount(raw.votes)


    this.getVoteCount = function(){
      return this.voteCount()
    }


    this.setReplyCount = function(count){
      if(count == null) this.replyCount(0)
      else {
        this.validateId(count)
        this.replyCount(count)
      }
    }
    this.setReplyCount(raw.reply_count)

    this.incrementReplyCount = function(){
      this.replyCount(this.replyCount() + 1)
    }


    this.deleteReplies = function(){
      this.replies([])
    }

    this.resetReplyCount = function(){
      this.replyCount(0)
    }


    this.deleteReply = function(replyId){
      var replies = this.replies()
      this.recursiveDelete(replyId, replies)
    }

    this.recursiveDelete = function(replyId, replies){
      if(replies.length < 1){
        return
      }

      for(var i = 0; i < replies.length; i++){
        var r = replies[i]
        if(r.getId() == replyId){
          replies.splice(i, 1)
          return true
        } else {
          var subReplies = r.getReplies()
          this.recursiveDelete(replyId, subReplies)
        }
      }
    }

    // pre1: You can assume that the index of a child is always
    //       greater than the parent.
    //
    // pre2: All root replies have null as their parentId
    // post1: behvaiour is undefined if the parentId or root replies is not null.
    this.setReplies = function(replies){
      this.deleteReplies()
      this.resetReplyCount()
      for(var r = 0; r < replies.length; r++){
        var root = replies[r]
        if(!root.isReply) throw new Error('must be a reply.')
        this.recurse(root, replies, r + 1)
        if(root.getParentId() == null){
            this.replies().push(root)
            this.incrementReplyCount()
        }
      }
    }


    this.recurse = function(parent, replies, index){
      for(var i = index; i < replies.length; i++){
        var next = replies[i]
        if(!next.isReply) throw new Error('must be a reply')
        if(next.getParentId() == parent.getId()){
          parent.addChild(next)
          this.incrementReplyCount()
          this.recurse(next, replies, i + 1)
        }
      }
    }

    this.isDuplicate = function(replyId){
      var found = false
      this.replies().forEach(function(r){
        if(r.getId() == replyId){
          found = true
          return
        }
      })
      return found
    }

    this.clearComment = function(){
      this.comment('')
    }

    this.getComment = function(){
      return this.comment()
    }

    this.getCommentHTML = function(){
        return this.getComment().replace(/\n/gi,'<br />');
    }


    this.setComment = function(text){
      if(typeof text != 'string' || text.length < 1)
        throw new Error('comment cannot be set to empty')
      this.comment(text)
    }

    this.getReplyCount = function(){
      return this.replyCount()
    }




    this.setExpanded = function(bool){
      this.expanded(bool)
    }

    this.isExpanded = function(){
      return this.expanded()
    }

    this.setId = (function(id){
      this.validateId(id)
      this.id = id
    }).bind(this)
    this.setId(raw.post_id)

    this.getId = function(){
      return this.id
    }

    this.getAuthor = function(){
      return this.author
    }

    this.setAuthor = function(author){
      this.validateStr(author)
      this.author = author
    }
    this.setAuthor(raw.first + ' ' + raw.last)

    this.setRep = function(rep){
      if(typeof rep != 'number' || rep < 0) return
      this.rep = 'Reputation: ' + rep
    }
    this.setRep(raw.author_rep)

    this.getRep = function(){
      return this.rep
    }

    this.isPoster = function(){
      return this.poster
    }

    this.setPoster = function(poster){
      if(poster == 1) this.poster = true
      else this.poster = false
    }
    this.setPoster(raw.is_owner)


    this.getUserId = function(){
      return this.userId
    }

    this.setUserId = function(id){
      this.validateId(id)
      this.userId = id
    }
    this.setUserId(raw.user_id)

    this.setTimestamp = function(time){
      try{
        this.validateStr(time)
        this.timestamp = time
      }catch(err){
        this.timestamp = '';
      }
    }
    this.setTimestamp(raw.timestamp)

    this.getTimestamp = function(){
      return this.timestamp
    }

    this.getTitle = function(){
      return this.title
    }

    this.setTitle = function(title){
      this.title = title
    }
    this.setTitle(raw.title)

    this.hasAnchorTag = function(body){
      return /<a/.test(body)
    }

    this.changeTarget = function(body){
      return body.replace('<a','<a target="_blank" rel="noopener noreferrer"')
    }


    this.setBody = function(body){
      this.validateStr(body)
      if(this.hasAnchorTag(body)){
        body = this.changeTarget(body)
      }
      this.body = body
    }
    this.setBody(raw.body)



    this.getBody = function(){
      return this.body
    }




  }

  ForumPost.buildOutgoing = function(obj){
    var o = ForumPost.getFake()
    o.setTitle(obj.title)
    o.setBody(obj.body)
    return o
  }

  ForumPost.getRaw = function(){
    return {
      post_id:1,
      user_id:2,
      title:'title',
      body:'text',
      first:'Chris',
      last:'Kerley',
      author_rep:5,
      timestamp:'nulltime',
      is_owner:1,
      reply_count:2,
      votes:3,
      already_voted:1
    }
  }

  ForumPost.getFake = function(){
    return new ForumPost(ForumPost.getRaw())
  }


  return ForumPost;
})
;

define('york-forum/models/PostReply',['abstract-interfaces/ValidObject',
        'ko'],
function(ValidObject, ko){

  var PostReply = function(raw, host){

    Object.setPrototypeOf(this, new ValidObject())
    this.author = ''
    this.userPhotoURL = ko.observable('./assets/no-photo.jpg')
    this.owner = null
    this.postId = null
    this.message = ''
    this.replies = ko.observableArray([])
    this.commentBoxOpen = ko.observable(false)


    // used for passing along the component tree.
    this.getSelf = (function(){
      return this
    }).bind(this)

    this.openCommentBox = function(){
      // this.commentBoxOpen(true)
    }

    this.isCommentBoxOpen = function(){
      return this.commentBoxOpen()
    }


    this.equals = function(reply){
      return reply.isReply() && this.getId() == reply.getId()
    }

    this.getReplies = function(){
      return this.replies()
    }

    this.isOwner = function(){
      return this.owner
    }

    this.setOwner = function(i){
      this.validateBool(i)
      this.owner = i
    }
    this.setOwner(raw.is_owner)

    this.setHost = function(host){
      this.validateStr(host)
      this.host = host
    }
    this.setHost(host)

    this.getHost = function(){
      return this.host
    }

    this.setUserPhotoURL = function(url){
      if(url != null){
        this.validateStr(url)
        this.userPhotoURL(host + '/' + url)
      }
    }
    this.setUserPhotoURL(raw.small_photo_url)

    this.getUserPhotoURL = function(){
      return this.userPhotoURL()
    }

    this.getKOUserPhotoURL = function(){
      return this.userPhotoURL
    }

    this.setId = (function(id){
      this.validateId(id)
      this.replyId = id
    }).bind(this)
    this.setId(raw.reply_id)

    this.getId = function(){
      return this.replyId
    }

    this.setPostId = function(id){
      this.validateId(id)
      this.postId = id
    }
    this.setPostId(raw.post_id)

    this.getPostId = function(){
      return this.postId
    }


    this.addChild = function(reply){
      if(!this.isDuplicate(reply)){
        this.replies().push(reply)
        this.replies.valueHasMutated()
      }
    }

    this.getChildAt = function(index){
      return this.replies()[index]
    }

    this.getChildCount = function(){
      return this.replies().length
    }

    this.isDuplicate = function(reply){
      for(var i = 0; i < this.replies().length; i++){
        if(this.replies()[i].getId() == reply.getId()){
          return true
        }
      }
      return false
    }



    this.setParentId = function(id){
      if(id == null){
        this.parentId = null
      } else {
        this.validateId(id)
        this.parentId = id
      }
    }
    this.setParentId(raw.parent_id)


    this.getParentId = function(){
      return this.parentId
    }

    this.isReply = function(){
      return true
    }

    this.getAuthor = function(){
      return this.author
    }

    this.setAuthor = function(author){
      this.validateStr(author)
      this.author = author
    }
    this.setAuthor(raw.first + ' ' + raw.last)


    this.getUserId = function(){
      return this.userId
    }

    this.setUserId = function(id){
      this.validateId(id)
      this.userId = id
    }
    this.setUserId(raw.user_id)

    this.setTimestamp = function(time){
      this.validateStr(time)
      this.timestamp = time
    }
    this.setTimestamp(raw.timestamp)

    this.getTimestamp = function(){
      return this.timestamp
    }



    this.setBody = function(body){
      this.validateStr(body)
      this.message = body
    }
    this.setBody(raw.body)


    this.getBody = function(){
      return this.message
    }


  }

  PostReply.buildOutgoing = function(obj){
    var r = PostReply.getFake()
    r.setBody(obj.body)
    r.setParentId(obj.parentId)
    return r
  }

  PostReply.getRaw = function(){
    return {
      reply_id:1,
      post_id:5,
      parent_id:2,
      user_id:3,
      body:'body',
      first:'Chris',
      last:'Kerley',
      small_photo_url:'fakephotourl',
      timestamp:'1 min',
      is_owner:1
    }
  }

  PostReply.getFake = function(){
    var fakeHost = 'fakehost'
    return new PostReply(PostReply.getRaw(),fakeHost)
  }


  return PostReply;
})
;

define('york-forum/YorkForumRemoteService',['ActiveRemoteService',
        'format-converter',
        'dispatcher/Dispatcher',
        'york-forum/models/ForumPost',
        'york-forum/models/PostReply',
        'ko'],
function(ActiveRemoteService,
         FormatConverter,
         Dispatcher,
        ForumPost,
        PostReply,
        ko){

  var YorkForumRemoteService = function(){
      Object.setPrototypeOf(Object.getPrototypeOf(this),new ActiveRemoteService());
      this.setMicroServer("forum");
      this.dis = new Dispatcher();

      this.removeVote = (function(post){
        var url = this.getServerURL() + '/removeVote';
        var json = JSON.stringify(this.flatten(post))
        $.ajax({
          url:url,
          type:"DELETE",
          data:json,
          contentType: "application/json; charset=utf-8",
          dataType: "json",
          beforeSend:this.setAuthorizationHeader,
          success:this.onPostsChanged,
          error:this.onError
        })
      }).bind(this)
      this.dis.reg('removeVote',this.removeVote)


      this.upvotePost = (function(post){
        var url = this.getServerURL() + '/upvotePost';
        var json = JSON.stringify(this.flatten(post))
        $.ajax({
          url:url,
          type:"POST",
          data:json,
          contentType: "application/json; charset=utf-8",
          dataType: "json",
          beforeSend:this.setAuthorizationHeader,
          success:this.onPostsChanged,
          error:this.onError
        })
      }).bind(this)
      this.dis.reg('upvotePost',this.upvotePost)

      this.onPostsChanged = (function(post){
        try{
          var wrapped = new ForumPost(post)
          this.dis.dispatch('postUpdated',wrapped)
        } catch(err){
          alert(err.message)
          this.onError('Malformed post received from server.')
        }
      }).bind(this)


      this.onReplyToReply = (function(reply){
        var url = this.getServerURL() + '/replyToReply';
        var json = JSON.stringify(this.flatten(reply))
        $.ajax({
          url:url,
          type:"POST",
          data:json,
          contentType: "application/json; charset=utf-8",
          dataType: "json",
          beforeSend:this.setAuthorizationHeader,
          success:this.onCommentsChanged,
          error:this.onError
        })
      }).bind(this)
      this.dis.reg('replyToReply',this.onReplyToReply)



      this.onDeleteComment = (function(comment){
        var url = this.getServerURL() + '/comment';
        var json = JSON.stringify(this.flatten(comment))
        $.ajax({
          url:url,
          type:"DELETE",
          data:json,
          contentType: "application/json; charset=utf-8",
          dataType: "json",
          beforeSend:this.setAuthorizationHeader,
          success:this.onCommentsChanged,
          error:this.onError
        })
      }).bind(this)
      this.dis.reg('deleteComment', this.onDeleteComment)



      this.commentPost  = (function(post){
        var url = this.getServerURL() + '/commentForumPost';
        var json = JSON.stringify(this.flatten(post))
        $.ajax({
          url:url,
          type:"POST",
          data:json,
          contentType: "application/json; charset=utf-8",
          dataType: "json",
          beforeSend:this.setAuthorizationHeader,
          success:this.onCommentsChanged,
          error:this.onError
        })
      }).bind(this)
      this.dis.reg('commentPost',this.commentPost)


      this.onCommentsChanged = (function(rawPost){
        var post = new ForumPost(rawPost)
        this.getForumReplies(post)
      }).bind(this)


      this.getForumReplies = (function(post){
        var url = this.getServerURL() + '/postReplies?postId=' + post.getId();
        $.ajax({
          url:url,
          type:"GET",
          beforeSend:this.setAuthorizationHeader,
          success:this.onRepliesReceived,
          error:this.onError
        })
      }).bind(this)
      this.dis.reg('showPost', this.getForumReplies)


      // expected either an array or a raw post object.
      this.onRepliesReceived = (function(response){
        try{
          if(Array.isArray(response)){
            var replies = this.wrapReplies(response)
            this.dis.dispatch('postReplies',replies)
          } else {
            var post = new ForumPost(response)
            this.dis.dispatch('deleteAllPostReplies',post)
          }

        } catch(err){
          this.onError(err.message)
        }
      }).bind(this)


      this.wrapReplies = (function(raws){
        var replies = []
        var host = this.getServerURL()
        for(var k = 0; k < raws.length; k++){
          replies.push(new PostReply(raws[k], host))
        }
        return replies
      }).bind(this)

      this.onDeleteForumPost = (function(post){
        var url = this.getServerURL() + '/deleteForumPost';
        var json = JSON.stringify(this.flatten(post))
        $.ajax({
          url:url,
          type:"POST",
          data:json,
          contentType: "application/json; charset=utf-8",
          dataType: "json",
          beforeSend:this.setAuthorizationHeader,
          success:this.onPostDeleted,
          error:this.onError
        })
      }).bind(this)
      this.dis.reg('deleteForumPost', this.onDeleteForumPost)


      this.onPostDeleted = (function(postId){
        this.dis.dispatch('forumPostDeleted',postId)
      }).bind(this)


      this.onPostForumMessage = (function(post){
        var url = this.getServerURL() + '/postYorkForum';
        var json = JSON.stringify(this.flatten(post))
        $.ajax({
          url:url,
          type:"POST",
          data:json,
          contentType: "application/json; charset=utf-8",
          dataType: "json",
          beforeSend:this.setAuthorizationHeader,
          success:this.onPostSuccess,
          error:this.onError
        })
      }).bind(this)
      this.dis.reg('postForumMessage',this.onPostForumMessage)


      this.onPostSuccess = (function(rawPost){
        try{
          var wrapped = new ForumPost(rawPost)
          this.dis.dispatch('postSuccess',wrapped)
        }catch(err){
          this.onError(err.message)
        }
      }).bind(this)


      this.onError = (function(err){
        if(err.responseText){
          err = err.responseText
        }
        this.dis.dispatch('postError',err)
      }).bind(this)


      this.onAuth = (function(update){
        if(update.state == 'authenticated'){
          this.getYorkForumPosts()
        }
      }).bind(this)
      this.dis.reg('authState',this.onAuth)


      this.getYorkForumPosts = (function(){
        $.ajax({
          url:this.getServerURL() + '/posts',
          type:"GET",
          beforeSend:this.setAuthorizationHeader,
          success:this.onYorkForumPosts,
          error:this.onError
        })
      }).bind(this)


      this.onYorkForumPosts = (function(data){
        try {
          var forumMemberCount = data.count
          var wrapped = []
          var self = this
          data.posts.forEach(function(post){
            var post = new ForumPost(post)
            wrapped.push(post)
          })
          this.dis.dispatch('forumMemberCount', forumMemberCount)
          this.dis.dispatch('forumPosts',wrapped)
        } catch(err){
          console.log(err)
          this.onError('There was a problem loading the news. Please try again later.')
        }
      }).bind(this)


      this.getFakeRepliesComplex = function(){
        return [{
          reply_id:1,
          parent_id:null,
          user_id:1,
          post_id:52,
          body:'body',
          first:'root',
          last:'1',
          timestamp:'1 min ago'
        },
        {
          reply_id:2,
          parent_id:1,
          post_id:52,
          user_id:4,
          body:'I am a child',
          first:'root 1',
          last:'child 1',
          timestamp:'1 min ago'
        },
        {
          reply_id:3,
          parent_id:1,
          post_id:52,
          user_id:8,
          body:'I am a child',
          first:'root 1 -',
          last:'child 2',
          timestamp:'1 min ago',
        },
        {
          reply_id:4,
          parent_id:3,
          post_id:52,
          user_id:8,
          body:'I am a child of root 1 - child 2',
          first:'child 2 -',
          last:'child 3',
          timestamp:'1 min ago'
        }
      ]
    } // end

      this.getSimpleRawReply = function(){

              return [{
                reply_id:1,
                parent_id:null,
                post_id:52,
                user_id:1,
                body:'body',
                first:'root',
                last:'1',
                timestamp:'1 min ago'
              }]
      }

      this.getMedRawReply = function(){

              return [{
                reply_id:1,
                parent_id:null,
                user_id:1,
                body:'body',
                first:'root',
                last:'1',
                timestamp:'1 min ago'
              },{
                reply_id:2,
                parent_id:1,
                user_id:1,
                body:'body',
                first:'child',
                last:'1',
                timestamp:'1 min ago'
              }]
      }



//       {
//         reply_id:1,
//         author:'Cindy',
//         message:`I believe classes are capped due to the amount and difficulty of work that has to be marked, not the physical number of seats required to accommodate all students. I can't imagine the TA for the current 4101 section having to mark 50+ versions of each assignment when the solutions and proofs can be so convoluted.`,
//         replies:ko.observableArray([
//           {
//             reply_id:4,
//               author:'Rayhelm',
//             message:`You only need one prof for a class, not 6+ like York has. That one can hire an army of T.A.s as they are cheap and plentiful.
//
// Except if York did that they would probably keep the crappiest Prof of the bunch.`,
//             replies:ko.observableArray([])
//           }
//         ])
//       },
//       {
//         reply_id:3,
//         author:'Cindy',
//         message:'So fools and liberals',
//         replies:ko.observableArray([
//           {
//             reply_id:4,
//               author:'Linda',
//             message:'Fuck',
//             replies:ko.observableArray([])
//           },
//           {
//             reply_id:4,
//               author:'Linda',
//             message:'Fuck',
//             replies:ko.observableArray([    {
//                   reply_id:4,
//                     author:'Linda',
//                   message:'In the future try asking some upper year people to enroll in your courses when there enrollment window opens and when your enrollment window opens ask them to drop those courses so you will be able to take that spot.',
//                   replies:ko.observableArray([])
//                 }])
//           }
//
//         ])
//       }
//     ]


  }
  return YorkForumRemoteService;
})
;
define('york-forum/YorkForumStore',['dispatcher/Dispatcher',
        'abstract-interfaces/Store',
        'york-forum/YorkForumRemoteService',
        'people-models/Person'],
function(Dispatcher,
         Store,
         RemoteService,
         Person){

   new RemoteService()
   var instance = null;
   var YorkForumStore  = function(){

     Object.setPrototypeOf(this, new Store())
     this.dis = new Dispatcher()
     this.spinnerOn = false
     this.visible = true
     this.forumPosterVisible = false
     this.posts = []
     this.postError = ''
     this.postSuccessful = false
     this.userPhotoURL = null
     this.userName = null
     this.memberCount = 0

     this.getMemberCount = (function(){
       return this.memberCount
     }).bind(this)


     this.onForumMemberCount = (function(count){
       if(typeof count != 'number' || count < 0)
        throw new Error('member count  must be a non-negative integer.')
       this.memberCount = count
       this.pub()
     }).bind(this)
     this.dis.reg('forumMemberCount',this.onForumMemberCount)


     this.updatePost = (function(serverPost){
       var p = this.getPost(serverPost.getId())
       if(!p) return
       if(serverPost.isAlreadyVoted()) p.setAlreadyVoted(1)
       else p.setAlreadyVoted(null)
       p.setVoteCount(serverPost.getVoteCount())
       this.pub()
     }).bind(this)
     this.dis.reg('postUpdated',this.updatePost)

     this.getPost = (function(postId){
       var post = null
       this.posts.forEach(function(p){
         if(p.getId() == postId){
           post = p
         }
         return
       })
       return post
     }).bind(this)


     this.getUserName = function(){
       return this.userName
     }



     this.onCommentPost = (function(){
       this.spinnerOn = true
       this.pub()
     }).bind(this)

     this.onDeleteAllPostReplies = (function(post){
       var postId = post.getId()
       var post = this.getPost(postId)
       if(post){
         post.deleteReplies()
         post.resetReplyCount()
         this.pub()
       }
     }).bind(this)
     this.dis.reg('deleteAllPostReplies', this.onDeleteAllPostReplies)


     /**
      Assumes that
     */
     this.onPostReplies = (function(replies){
       if(replies.length > 0){
         var targetPostId = replies[0].getPostId()
         for(var i = 0; i < this.posts.length; i++){
           if(this.posts[i].getId() == targetPostId){
             this.posts[i].setReplies(replies)
             break
           }
         }
         this.pub()
       }
     }).bind(this)
     this.dis.reg('postReplies',this.onPostReplies)


     this.onShowPost = (function(post){
       for(var i = 0; i < this.posts.length; i++){
          var current = this.posts[i]
          if(current.getId() == post.getId()){
            current.setExpanded(true)
            current.clearComment()
          } else {
            current.setExpanded(false)
          }
        }
        this.pub()
     }).bind(this)
     this.dis.reg('showPost',this.onShowPost)

     this.getUserPhoto = function(){
       return this.userPhotoURL
     }

     this.onProfileInfo = (function(user){
       this.userPhotoURL = user.small_photo_url
       this.userName = user.first + ' ' + user.last
       this.pub()
     }).bind(this)
     this.dis.reg('profileUpdate',this.onProfileInfo)


     this.onForumPosts = (function(posts){
       this.posts = posts
       this.pub()
     }).bind(this)
     this.dis.reg('forumPosts', this.onForumPosts)


     this.onOpenForumPoster = (function(){
       this.forumPosterVisible = true
       this.pub()
     }).bind(this)
     this.dis.reg('openForumPoster', this.onOpenForumPoster)

     this.isVisible = (function(){
       return this.visible;
     }).bind(this)

     this.onOpenNews = (function(){
       this.visible = true
       this.pub()
     }).bind(this)
     this.dis.reg('openNews',this.onOpenNews)



     this.hideNews = (function(person){
       this.visible = false
       this.pub()
     }).bind(this)
     this.dis.reg('focusPerson', this.hideNews)
     this.selGrpId = this.dis.reg('selectedGroupId',this.hideNews)

     this.isForumPosterVisible = (function(){
       return this.forumPosterVisible
     }).bind(this)


     this.hide = (function(){
       this.forumPosterVisible = false
       this.pub()
     }).bind(this)
     this.dis.reg('hideYorkForumPoster',this.hide)

     this.onForumPostDeleted = (function(postId){
       for(var i = 0; i < this.posts.length; i++){
         if(this.posts[i].getId() == postId){
           this.posts.splice(i,1)
         }
       }
       this.spinnerOn = false
       this.pub()
     }).bind(this)
     this.dis.reg('forumPostDeleted',this.onForumPostDeleted)

     this.onServerCall = (function(){
       this.spinnerOn = true
       this.pub()
     }).bind(this)
     this.dis.reg('postForumMessage',this.onServerCall)
     this.dis.reg('deleteForumPost',this.onServerCall)


     this.isSpinnerOn = function(){
       return this.spinnerOn
     }

     this.isPostSuccessful = function(){
       return this.postSuccessful
     }

     this.getPosts = function(){
       return this.posts
     }

     this.getPostError = function(){
       return this.postError
     }

     this.onClearPosterError = (function(){
       this.spinnerOn = false
       this.postError = ''
       this.pub()
     }).bind(this)
     this.dis.reg('clearPosterError',this.onClearPosterError)

     this.onPostError = (function(err){
       this.postError = err
       this.forumPosterVisible = false
       this.pub()
     }).bind(this)
     this.dis.reg('postError',this.onPostError)

     this.onPostSuccess = (function(post){
       this.posts.unshift(post)
       this.postSuccessful = true
       this.spinnerOn = false
       this.forumPosterVisible = false
       this.pub()
       var self = this
       setTimeout(this.hideSuccess,1500)
     }).bind(this)
     this.dis.reg('postSuccess',this.onPostSuccess)

     this.hideSuccess = (function(){
       this.postSuccessful = false
       this.pub()
     }).bind(this)


  } // end


    return {
      getInstance:function(){
        if(!instance){
          instance = new YorkForumStore();
        }
        return instance;
      },
      getNew:function(){
        return new YorkForumStore();
      }
    }
  })
;
/*!
 CLEditor WYSIWYG HTML Editor v1.4.5
 http://premiumsoftware.net/CLEditor
 requires jQuery v1.4.2 or later
 Copyright 2010, Chris Landowski, Premium Software, LLC
 Dual licensed under the MIT or GPL Version 2 licenses.
*/
(function(n){function vi(t){var i=this,e=t.target,y=n.data(e,a),p=s[y],w=p.popupName,k=f[w],v,b;if(!i.disabled&&n(e).attr(r)!==r){if(v={editor:i,button:e,buttonName:y,popup:k,popupName:w,command:p.command,useCSS:i.options.useCSS},p.buttonClick&&p.buttonClick(t,v)===!1)return!1;if(y==="source")l(i)?(delete i.range,i.$area.hide(),i.$frame.show(),e.title=p.title):(i.$frame.hide(),i.$area.show(),e.title="Show Rich Text");else if(!l(i)){if(w){if(b=n(k),w==="url"){if(y==="link"&&ri(i)==="")return ut(i,"A selection is required when inserting a link.",e),!1;b.children(":button").unbind(u).bind(u,function(){var t=b.find(":text"),r=n.trim(t.val());r!==""&&h(i,v.command,r,null,v.button);t.val("http://");o();c(i)})}else w==="pastetext"&&b.children(":button").unbind(u).bind(u,function(){var n=b.find("textarea"),t=n.val().replace(/\n/g,"<br />");t!==""&&h(i,v.command,t,null,v.button);n.val("");o();c(i)});return e!==n.data(k,d)?(ui(i,k,e),!1):void 0}if(y==="print")i.$frame[0].contentWindow.print();else if(!h(i,v.command,v.value,v.useCSS,e))return!1}c(i)}}function kt(t){var i=n(t.target).closest("div");i.css(et,i.data(a)?"#FFF":"#FFC")}function dt(t){n(t.target).closest("div").css(et,"transparent")}function yi(i){var v=this,y=i.data.popup,r=i.target,l;if(y!==f.msg&&!n(y).hasClass(tt)){var w=n.data(y,d),u=n.data(w,a),p=s[u],b=p.command,e,k=v.options.useCSS;if(u==="font"?e=r.style.fontFamily.replace(/"/g,""):u==="size"?(r.tagName.toUpperCase()==="DIV"&&(r=r.children[0]),e=r.innerHTML):u==="style"?e="<"+r.tagName+">":u==="color"?e=ti(r.style.backgroundColor):u==="highlight"&&(e=ti(r.style.backgroundColor),t?b="backcolor":k=!0),l={editor:v,button:w,buttonName:u,popup:y,popupName:p.popupName,command:b,value:e,useCSS:k},!p.popupClick||p.popupClick(i,l)!==!1){if(l.command&&!h(v,l.command,l.value,l.useCSS,w))return!1;o();c(v)}}}function it(n){for(var t=1,i=0,r=0;r<n.length;++r)t=(t+n.charCodeAt(r))%65521,i=(i+t)%65521;return i<<16|t}function pi(n){n.$area.val("");ft(n)}function gt(r,u,e,o,s){var h,c;return f[r]?f[r]:(h=n(i).hide().addClass(si).appendTo("body"),o?h.html(o):r==="color"?(c=u.colors.split(" "),c.length<10&&h.width("auto"),n.each(c,function(t,r){n(i).appendTo(h).css(et,"#"+r)}),e=hi):r==="font"?n.each(u.fonts.split(","),function(t,r){n(i).appendTo(h).css("fontFamily",r).html(r)}):r==="size"?n.each(u.sizes.split(","),function(t,r){n(i).appendTo(h).html('<font size="'+r+'">'+r+"<\/font>")}):r==="style"?n.each(u.styles,function(t,r){n(i).appendTo(h).html(r[1]+r[0]+r[1].replace("<","<\/"))}):r==="url"?(h.html('<label>Enter URL:<br /><input type="text" value="http://" style="width:200px" /><\/label><br /><input type="button" value="Submit" />'),e=tt):r==="pastetext"&&(h.html('<label>Paste your content here:<br /><textarea rows="3" style="width:200px"><\/textarea><\/label><br /><input type="button" value="Submit" />'),e=tt),e||o||(e=pt),h.addClass(e),t&&h.attr(ot,"on").find("div,font,p,h1,h2,h3,h4,h5,h6").attr(ot,"on"),(h.hasClass(pt)||s===!0)&&h.children().hover(kt,dt),f[r]=h[0],h[0])}function ni(n,i){i?(n.$area.attr(r,r),n.disabled=!0):(n.$area.removeAttr(r),delete n.disabled);try{t?n.doc.body.contentEditable=!i:n.doc.designMode=i?"off":"on"}catch(u){}b(n)}function h(n,i,r,u,f){var c,h,o,s,l;if(rt(n),t||((u===undefined||u===null)&&(u=n.options.useCSS),n.doc.execCommand("styleWithCSS",0,u.toString())),c=i.toLowerCase()==="inserthtml",t&&c)w(n).pasteHTML(r);else if(y&&c)h=e(n),o=h.getRangeAt(0),o.deleteContents(),o.insertNode(o.createContextualFragment(r)),h.removeAllRanges(),h.addRange(o);else{s=!0;try{s=n.doc.execCommand(i,0,r||null)}catch(a){l=a.message;s=!1}s||("cutcopypaste".indexOf(i)>-1?ut(n,"For security reasons, your browser does not support the "+i+" command. Try using the keyboard shortcut or context menu instead.",f):ut(n,l?l:"Error executing the "+i+" command.",f))}return b(n),ct(n,!0),s}function c(n){setTimeout(function(){l(n)?n.$area.focus():n.$frame[0].contentWindow.focus();b(n)},0)}function w(n){return t?e(n).createRange():e(n).getRangeAt(0)}function e(n){return t?n.doc.selection:n.$frame[0].contentWindow.getSelection()}function ti(n){var i=/rgba?\((\d+), (\d+), (\d+)/.exec(n),t;if(i){for(n=(i[1]<<16|i[2]<<8|i[3]).toString(16);n.length<6;)n="0"+n;return"#"+n}return(t=n.split(""),n.length===4)?"#"+t[1]+t[1]+t[2]+t[2]+t[3]+t[3]:n}function o(){n.each(f,function(t,i){n(i).hide().unbind(u).removeData(d)})}function ii(){var t=n("link[href*=cleditor]").attr("href");return t.replace(/^(.*\/)[^\/]+$/,"$1")+"images/"}function wi(n){return"url("+ii()+n+")"}function ht(i){var s=i.$main,r=i.options;i.$frame&&i.$frame.remove();var u=i.$frame=n('<iframe frameborder="0" src="javascript:true;" />').hide().appendTo(s),l=u[0].contentWindow,f=i.doc=l.document,h=n(f);f.open();f.write(r.docType+"<html>"+(r.docCSSFile===""?"":'<head><link rel="stylesheet" type="text/css" href="'+r.docCSSFile+'" /><\/head>')+'<body style="'+r.bodyStyle+'"><\/body><\/html>');f.close();(t||y)&&h.click(function(){c(i)});ft(i);t||y?(h.bind("beforedeactivate beforeactivate selectionchange keypress keyup",function(n){if(n.type==="beforedeactivate")i.inactive=!0;else if(n.type==="beforeactivate")!i.inactive&&i.range&&i.range.length>1&&i.range.shift(),delete i.inactive;else if(!i.inactive)for(i.range||(i.range=[]),i.range.unshift(w(i));i.range.length>2;)i.range.pop()}),u.focus(function(){rt(i);n(i).triggerHandler(nt)}),u.blur(function(){n(i).triggerHandler(k)})):n(u[0].contentWindow).focus(function(){n(i).triggerHandler(nt)}).blur(function(){n(i).triggerHandler(k)});h.click(o).keydown(function(n){t&&e(i).type=="Control"&&n.keyCode==8&&(e(i).clear(),n.preventDefault())}).bind("keyup mouseup",function(){b(i);ct(i,!0)});st?i.$area.show():u.show();n(function(){var t=i.$toolbar,f=t.children("div:last"),e=s.width(),n=f.offset().top+f.outerHeight()-t.offset().top+1;t.height(n);n=(/%/.test(""+r.height)?s.height():parseInt(r.height,10))-n;u.width(e).height(n);i.$area.width(e).height(li?n-2:n);ni(i,i.disabled);b(i)})}function b(i){var u,e;st||!ai||i.focused||(i.$frame[0].contentWindow.focus(),window.focus(),i.focused=!0);u=i.doc;t&&(u=w(i));e=l(i);n.each(i.$toolbar.find("."+vt),function(o,s){var v=n(s),h=n.cleditor.buttons[n.data(s,a)],c=h.command,l=!0,p;if(i.disabled)l=!1;else if(h.getEnabled)p={editor:i,button:s,buttonName:h.name,popup:f[h.popupName],popupName:h.popupName,command:h.command,useCSS:i.options.useCSS},l=h.getEnabled(p),l===undefined&&(l=!0);else if((e||st)&&h.name!=="source"||t&&(c==="undo"||c==="redo"))l=!1;else if(c&&c!=="print"&&(t&&c==="hilitecolor"&&(c="backcolor"),!t&&!y||c!=="inserthtml"))try{l=u.queryCommandEnabled(c)}catch(w){l=!1}l?(v.removeClass(yt),v.removeAttr(r)):(v.addClass(yt),v.attr(r,r))})}function rt(n){n.range&&(t?n.range[0].select():y&&e(n).addRange(n.range[0]))}function bi(n){setTimeout(function(){l(n)?n.$area.select():h(n,"selectall")},0)}function ki(i){var u,r,f;return(rt(i),u=w(i),t)?u.htmlText:(r=n("<layer>")[0],r.appendChild(u.cloneContents()),f=r.innerHTML,r=null,f)}function ri(n){return(rt(n),t)?w(n).text:e(n).toString()}function ut(n,t,i){var r=gt("msg",n.options,ci);r.innerHTML=t;ui(n,r,i)}function ui(t,i,r){var f,h,c,e=n(i),l,s;r?(l=n(r),f=l.offset(),h=--f.left,c=f.top+l.height()):(s=t.$toolbar,f=s.offset(),h=Math.floor((s.width()-e.width())/2)+f.left,c=f.top+s.height()-2);o();e.css({left:h,top:c}).show();r&&(n.data(i,d,r),e.bind(u,{popup:i},n.proxy(yi,t)));setTimeout(function(){e.find(":text,textarea").eq(0).focus().select()},100)}function l(n){return n.$area.is(":visible")}function ft(t,i){var u=t.$area.val(),o=t.options,f=o.updateFrame,s=n(t.doc.body),e,r;if(f){if(e=it(u),i&&t.areaChecksum===e)return;t.areaChecksum=e}r=f?f(u):u;r=r.replace(/<(?=\/?script)/ig,"&lt;");o.updateTextArea&&(t.frameChecksum=it(r));r!==s.html()&&(s.html(r),n(t).triggerHandler(g))}function ct(t,i){var u=n(t.doc.body).html(),o=t.options,f=o.updateTextArea,s=t.$area,e,r;if(f){if(e=it(u),i&&t.frameChecksum===e)return;t.frameChecksum=e}r=f?f(u):u;o.updateFrame&&(t.areaChecksum=it(r));r!==s.val()&&(s.val(r),n(t).triggerHandler(g))}var p,bt;n.cleditor={defaultOptions:{width:"auto",height:250,controls:"image link unlink | alignleft center alignright justify | undo redo",sizes:"1,2,3,4,5,6,7",useCSS:!0,docType:'<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">',docCSSFile:"",bodyStyle:"margin:4px; font:14pt Arial,Verdana; cursor:text"},buttons:{init:"bold,,|italic,,|underline,,|strikethrough,,|subscript,,|superscript,,|font,,fontname,|size,Font Size,fontsize,|style,,formatblock,|color,Font Color,forecolor,|highlight,Text Highlight Color,hilitecolor,color|removeformat,Remove Formatting,|bullets,,insertunorderedlist|numbering,,insertorderedlist|outdent,,|indent,,|alignleft,Align Text Left,justifyleft|center,,justifycenter|alignright,Align Text Right,justifyright|justify,,justifyfull|undo,,|redo,,|rule,Insert Horizontal Rule,inserthorizontalrule|image,Insert Image,insertimage,url|link,Insert Hyperlink,createlink,url|unlink,Remove Hyperlink,|cut,,|copy,,|paste,,|pastetext,Paste as Text,inserthtml,|print,,|source,Show Source"},imagesPath:function(){return ii()}};n.fn.cleditor=function(t){var i=n([]);return this.each(function(r,u){if(u.tagName.toUpperCase()==="TEXTAREA"){var f=n.data(u,lt);f||(f=new cleditor(u,t));i=i.add(f)}}),i};var et="backgroundColor",k="blurred",d="button",a="buttonName",g="change",lt="cleditor",u="click",r="disabled",i="<div>",nt="focused",ot="unselectable",fi="cleditorMain",ei="cleditorToolbar",at="cleditorGroup",vt="cleditorButton",yt="cleditorDisabled",oi="cleditorDivider",si="cleditorPopup",pt="cleditorList",hi="cleditorColor",tt="cleditorPrompt",ci="cleditorMsg",v=navigator.userAgent.toLowerCase(),t=/msie/.test(v),li=/msie\s6/.test(v),y=/(trident)(?:.*rv:([\w.]+))?/.test(v),ai=/webkit/.test(v),st=/iPhone|iPad|iPod/i.test(v),f={},wt,s=n.cleditor.buttons;n.each(s.init.split("|"),function(n,t){var i=t.split(","),r=i[0];s[r]={stripIndex:n,name:r,title:i[1]===""?r.charAt(0).toUpperCase()+r.substr(1):i[1],command:i[2]===""?r:i[2],popupName:i[3]===""?r:i[3]}});delete s.init;cleditor=function(r,f){var e=this;e.options=f=n.extend({},n.cleditor.defaultOptions,f);var l=e.$area=n(r).css({border:"none",margin:0,padding:0}).hide().data(lt,e).blur(function(){ft(e,!0)}),v=e.$main=n(i).addClass(fi).width(f.width).height(f.height),y=e.$toolbar=n(i).addClass(ei).appendTo(v),h=n(i).addClass(at).appendTo(y),c=0;n.each(f.controls.split(" "),function(r,o){var w,l,p,v;if(o==="")return!0;o==="|"?(w=n(i).addClass(oi).appendTo(h),h.width(c+1),c=0,h=n(i).addClass(at).appendTo(y)):(l=s[o],p=n(i).data(a,l.name).addClass(vt).attr("title",l.title).bind(u,n.proxy(vi,e)).appendTo(h).hover(kt,dt),c+=24,h.width(c+1),v={},l.css?v=l.css:l.image&&(v.backgroundImage=wi(l.image)),l.stripIndex&&(v.backgroundPosition=l.stripIndex*-24),p.css(v),t&&p.attr(ot,"on"),l.popupName&&gt(l.popupName,f,l.popupClass,l.popupContent,l.popupHover))});v.insertBefore(l).append(l);wt||(n(document).click(function(t){var i=n(t.target);i.add(i.parents()).is("."+tt)||o()}),wt=!0);/auto|%/.test(""+f.width+f.height)&&n(window).bind("resize.cleditor",function(){ht(e)});ht(e)};p=cleditor.prototype;bt=[["clear",pi],["disable",ni],["execCommand",h],["focus",c],["hidePopups",o],["sourceMode",l,!0],["refresh",ht],["select",bi],["selectedHTML",ki,!0],["selectedText",ri,!0],["showMessage",ut],["updateFrame",ft],["updateTextArea",ct]];n.each(bt,function(n,t){p[t[0]]=function(){for(var u,n=this,r=[n],i=0;i<arguments.length;i++)r.push(arguments[i]);return(u=t[1].apply(n,r),t[2])?u:n}});p.blurred=function(t){var i=n(this);return t?i.bind(k,t):i.trigger(k)};p.change=function(t){var i=n(this);return t?i.bind(g,t):i.trigger(g)};p.focused=function(t){var i=n(this);return t?i.bind(nt,t):i.trigger(nt)}})(jQuery);
/*
//# sourceMappingURL=jquery.cleditor.min.js.map
*/
;
define("cleditor", function(){});

/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2020-07-14
 * @Copyright: Palolo Education Inc. 2020
 */
define('forum-poster/Component',['ko',
        'text!york-forum/poster/template.html',
        'dispatcher/Dispatcher',
        'york-forum/YorkForumStore',
        'cleditor',
        'york-forum/models/ForumPost'],

function(ko, template, Dis,  Store, cleditor, ForumPost){

  function ViewModel(params,componentInfo){
    this.dis = new Dis()
    this.isVisible = ko.observable(false)
    this.isSpinnerOn = ko.observable(false)
    this.isPostSuccessful = ko.observable(false)
    this.store = Store.getInstance()
    this.title = ko.observable('')
    this.titleHasFocus = ko.observable(false)
    this.isPostable = ko.observable(false)
    this.isValidBodyLength = ko.observable(false)
    this.bodyErrorMessage = ko.observable('')
    var MAX_POST_LENGTH = 10096 // encoding is like twice as long.
    var MIN_POST_LENGTH = 3


    this.onStore = (function(){
      var err = this.store.getPostError()
      if(err.length > 0){
        alert(err)
        this.dis.dispatch('clearPosterError')
        return
      }
      this.isVisible(this.store.isForumPosterVisible())
      if(this.isVisible() && !this.store.isSpinnerOn()){
        this.refreshPoster()
        this.titleHasFocus(true)

      }
      this.isSpinnerOn(this.store.isSpinnerOn())
      this.isPostSuccessful(this.store.isPostSuccessful())
    }).bind(this)
    this.store.sub(this.onStore)





    this.onTitle = (function(text){
      if(text.length < 3)
          this.isPostable(false)
      else
          this.isPostable(true)
    }).bind(this)
    this.title.subscribe(this.onTitle)




    this.hide = (function(){
      this.dis.dispatch('hideYorkForumPoster')
    }).bind(this)


    this.options = {
            width: 500, // width not including margins, borders or padding
            height: 250, // height not including margins, borders or padding
            controls: // controls to add to the toolbar
                "bold italic underline strikethrough subscript superscript | font size " +
                "style | color highlight removeformat | bullets numbering | outdent " +
                "indent | alignleft center alignright justify | undo redo | " +
                "rule image link unlink | cut copy paste pastetext | print source",
            colors: // colors in the color popup
                "FFF FCC FC9 FF9 FFC 9F9 9FF CFF CCF FCF ",
            sizes: // sizes in the font size popup
                "1,2,3,4,5,6,7",
            styles: // styles in the style popup
                [["Paragraph", "<p>"]],
            useCSS: true, // use CSS to style HTML when possible (not supported in ie)
            docType: // Document type contained within the editor
                '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">',
            docCSSFile: // CSS file used to style the document contained within the editor
                "",
            bodyStyle: // style to assign to document body contained within the editor
                "margin:4px; font:32pt Arial,Verdana; cursor:text"
        }
        this.getMaxLength = function(){
          return MAX_POST_LENGTH
        }

      this.onBodyChange = (function(){
        var text = this.getEditorText()
        if(text.length < MIN_POST_LENGTH){
          this.isValidBodyLength(false)
          this.bodyErrorMessage('Your message is too short.')
        } else if(text.length > this.getMaxLength()) {
            this.isValidBodyLength(false)
            this.bodyErrorMessage('Your message is too long.')
        } else{
          this.isValidBodyLength(true)
          this.bodyErrorMessage('')
        }
      }).bind(this)

        var self = this
        this.initEditor = function() {
          try{
            self.editor = $("#forum-input").cleditor(this.options)
            self.editor[0].change(self.onBodyChange)
          } catch(err){
            console.log(err.message)
          }
        }
       $(document).ready(this.initEditor);

     this.refreshPoster = function(){
       this.editor[0].refresh()
     }

      this.getEditorText = function(){
        return this.editor[0].$area.val()
      }

      this.getTitle = function(){
        return this.title()
      }

      this.clear = function(){
        this.title('')
        this.editor[0].clear()
      }


      this.post = (function(){
        try{

          var post = ForumPost.buildOutgoing({
            title:this.getTitle(),
            body:this.getEditorText()
          })

          this.dis.dispatch('postForumMessage',post)
          this.clear()
        }catch(err){
          console.log(err)
        }
      }).bind(this)


  };

  return {
    viewModel: ViewModel,
    template : template
  }

});


define('text!forum-feed/template.html',[],function () { return '<link rel="stylesheet"\n      href="./styles/components/york-forum/forum-feed.css?v=2.7">\n</link>\n\n<div id=\'forum-feed\' class=\'hide-scroll\' data-bind=\'visible:isVisible()\'>\n  <div id=\'post-message-holder\'>\n    <span id=\'poster-icon-holder\'>\n\n      <!-- ko if: userPhotoURL() != null -->\n          <img alt="User Photo" id="poster-photo" data-bind=\'attr:{src:userPhotoURL()}\'>\n       <!-- /ko -->\n    <!-- ko if: userPhotoURL() == null -->\n      <i id=\'poster-replacement-photo\'\n         class="fa fa-smile-o"\n         ></i>\n     <!-- /ko -->\n\n    </span>\n      <input id=\'poster-input\'\n              placeholder="What\'s new at YorkU?"\n              data-bind=\'click:openPoster\'>\n      </input>\n  </div>\n\n  <div data-bind=\'foreach:posts\'>\n    <div class=\'forum-post-card\' data-bind=\'click:$parent.showPost, css:{"normal-cursor" : expanded()}\'>\n\n        <span class=\'upvote-holder disable-select\'\n              data-bind=\'click:$parent.toggleVote\'\n              data-toggle="tooltip"\n              title="Upvote">\n          <a class=\'glyphicon glyphicon-arrow-up feedback-arrow\' data-bind=\'css:{ voted : alreadyVoted()}\'></a>\n          <span class=\'upvote-count\' data-bind=\'text:getVoteCount()\'>0</span>\n        </span>\n\n\n\n        <div class=\'post-author-container\'>\n            <span> Posted by </span>\n            &nbsp;\n            <span class=\'post-author\' data-bind=\'click:$parent.gotoPerson\'>\n              <span data-bind=\'text:getAuthor()\'></span>\n\n              <span class=\'auth-info\' data-bind=\'text:getRep()\'>102</span>\n            </span>\n\n            &nbsp;\n            <span data-bind=\'text:getTimestamp()\'></span>\n            &nbsp;\n            <span> ago </span>\n        </div>\n        <div class=\'post-title-container\'>\n          <div class=\'post-title\'>\n            <h3 class=\'post-title-text\' data-bind=\'text:getTitle()\'><h3>\n          </div>\n        </div>\n        <div class=\'post-message-container\' data-bind=\'css:{ "expanded-post-message-container" : expanded()}\'>\n          <div class=\'post-message\' data-bind="html:getBody(), css:{ \'expanded-post-message\' : expanded()}"></div>\n        </div>\n        <div class=\'post-card-buttons-container\'>\n          <div class=\'post-card-buttons\'>\n            <a rel="nofollow"\n               class=\'post-comment-anchor\'>\n             <i class="glyphicon glyphicon-comment post-comment-icon">\n            </i>\n            <span class="post-comments-text" data-bind=\'text:replyCount()\'>0</span> Comments\n          </a>\n          <a rel="nofollow"\n             class=\'post-comment-anchor\'\n             data-bind=\'visible:isPoster(), click:$parent.deletePost\'>\n           <i class="glyphicon glyphicon-trash post-comment-icon">\n          </i>\n          <span class="post-comments-text">delete</span>\n        </a>\n          </div>\n        </div>\n\n        <div class="post-comment" data-bind=\'visible:expanded()\'>\n            <div class=\'comment-as-header\'>Comment as <span data-bind=\'text:$parent.userFullName()\'> First Last </span></div>\n            <textarea class=\'post-comment-message\'\n                      data-bind=\'textInput:comment\'\n                      placeholder="What are your thoughts?">\n\n            </textarea>\n            <button class=\'blue-square-button\' data-bind=\'click:$parent.commentPost\'>COMMENT</button>\n        </div>\n\n        <!-- recursive component -->\n        <forum-reply class=\'root-reply\'\n                     data-bind=\'visible:expanded()\'\n                     params="replies: {isRoot:true, replies:replies, self:null}">\n        </forum-reply>\n\n    </div>\n  </div>\n</div>\n';});

/**
 * @license Proprietary - Please do not steal our hard work. Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2020-07-14
 * @Copyright: Palolo Education Inc. 2020
 */
define('forum-feed/Component',['ko',
        'text!forum-feed/template.html',
        'dispatcher/Dispatcher',
        'york-forum/YorkForumStore'],

function(ko, template, Dis,  Store){

  function View(){
    this.dis = new Dis()
    this.isVisible = ko.observable(false)
    this.store = Store.getInstance()
    this.posts = ko.observableArray([])
    this.userPhotoURL = ko.observable('')
    this.userFullName = ko.observable('')

    this.onStore = (function(){
      this.isVisible(this.store.isVisible())
      var p = this.store.getPosts()
      p.forEach(function(post){
        post.replies.valueHasMutated()
      })
      this.posts(p)
      this.userPhotoURL(this.store.getUserPhoto())
      this.userFullName(this.store.getUserName())
    }).bind(this)
    this.store.sub(this.onStore)


    this.gotoPerson = (function(vm, e){
      if(e){
        e.stopPropagation()
        return false
      }
    }).bind(this)

    this.openPoster = (function(){
      this.dis.dispatch('openForumPoster')
    }).bind(this)


    this.toggleVote = (function(post,e){
      if(post.isAlreadyVoted()){
        this.dis.dispatch('removeVote',post)
      } else {
        this.dis.dispatch('upvotePost',post)
      }
      e.stopPropagation()
      return false
    }).bind(this)


    this.deletePost = (function(post,e){
      if (confirm('Are you sure you want to delete?')) {
        this.dis.dispatch('deleteForumPost',post)
      }
      e.stopPropagation()
      return false
    }).bind(this)

    this.showPost = (function(post){
      if(!post.isExpanded()){
          this.dis.dispatch('showPost',post)
      } else {
        return false
      }
    }).bind(this)

    this.commentPost = (function(post){
      var postId = post.getId()
      var message = post.getCommentHTML()
      post.clearComment()
      this.dis.dispatch('commentPost',{postId:postId, message:message})
    }).bind(this)
  };

  return {
    viewModel: View,
    template : template
  }

});


define('text!york-forum/reply/template.html',[],function () { return '<link rel="stylesheet"\n      href="./styles/components/york-forum/reply.css?v=2.3">\n</link>\n\n\n<!-- ko if: !isRoot() -->\n    <div class=\'reply-box\'>\n      <i class=\'reply-seperator\'></i>\n      <div class=\'replier-info-row\'>\n        <img class=\'reply-author-img\' data-bind=\'attr:{ src : userPhotoURL()}\'></img>\n        <span  class=\'reply-author\' data-bind=\'text: author\'></span>\n        <span class=\'reply-timestamp\'>\n          - <span  data-bind=\'text: timestamp\'></span> ago\n        </span>\n\n      </div>\n      <div  class=\'reply-message\' data-bind=\'html: message\'></div>\n      <div class=\'reply-response-row\'>\n\n        <span data-toggle="tooltip" title="Reply" data-bind=\'click:openCommentBox\'>\n          <i class="glyphicon glyphicon-comment post-comment-icon">\n         </i>\n        </span>\n\n        <span data-toggle="tooltip" title="Delete" data-bind=\'visible:isOwner, click:deleteComment\'>\n          <i class="glyphicon glyphicon-trash post-comment-icon"></i>\n        </span>\n\n        <div class=\'post-comment\' data-bind=\'visible:isCommentBoxOpen()\'>\n          <textarea class=\'post-comment-message\'\n                    data-bind=\'textInput:replyToReplyMessage, hasFocus:commentCommentHasFocus\'\n                    placeholder="What do you think?">\n          </textarea>\n          <button class=\'blue-square-button\' data-bind=\'click:replyToReply\'>COMMENT</button>\n        </div>\n\n\n      </div>\n    </div>\n<!-- /ko -->\n\n\n <!-- ko foreach: replies -->\n <!-- note that what is available here is a reference to the reply object -->\n   <forum-reply params=\'replies: {isRoot:false, replies:replies, self:getSelf}\'></forum-reply>\n <!-- /ko -->\n';});

/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2020-07-14
 * @Copyright: Palolo Education Inc. 2020
 */
define('forum-reply/Component',['ko',
        'text!york-forum/reply/template.html',
        'dispatcher/Dispatcher',
        'york-forum/YorkForumStore'],

function(ko, template, Dis,  Store){

    function ReplyComponent(params) {

      this.dis = new Dis()
      this.isRoot = ko.observable(params.replies.isRoot)
      this.replies = params.replies.replies   // so sub-replies can be drawn.

      if(params.replies.self){
        this.reply = params.replies.self()
        this.replyId = this.reply.getId()
        this.message = this.reply.getBody()
        this.author = this.reply.getAuthor()
        this.timestamp = this.reply.getTimestamp()
        this.userPhotoURL = this.reply.getKOUserPhotoURL()
        this.isOwner = this.reply.isOwner()
        this.replyToReplyMessage = ko.observable('')
        this.isCommentBoxOpen = this.reply.commentBoxOpen
        this.commentCommentHasFocus = ko.observable(false)


        this.deleteComment = (function(){
          if(confirm('Are you sure you want to delete this?')){
              this.dis.dispatch('deleteComment',this.reply)
          }
        }).bind(this)

        this.openCommentBox = (function(){
          this.isCommentBoxOpen(true)
          this.commentCommentHasFocus(true)
        }).bind(this)

        this.replyToReply = (function(){
          var o = {
            parentReply:this.reply,
            message:this.replyToReplyMessage().replace(/\n/gi,'<br />')
          }
          this.replyToReplyMessage('')
          this.dis.dispatch('replyToReply',o)
        }).bind(this)

      }



      var child
      if(this.replies.length > 0){
        params.replies.shift()
        child = new ReplyComponent(params);
      }
      return child
}


  return {
    template: template,
    viewModel: {
        createViewModel: function(params, componentInfo) {
            return new ReplyComponent(params);
        }
    }
  }

});


define('text!york-forum/forum-stats/template.html',[],function () { return '\n<link rel="stylesheet"\n      href="./styles/components/york-forum/stats.css?v=1">\n<div id=\'forum-stats-holder\' data-bind=\'visible:isVisible()\'>\n  <img id=\'yorku-img\' src=\'./assets/yorku.jpg\'></img>\n  <div id=\'yorku-stats\'>\n    <div id=\'school-name-title\'>York University</div>\n    <div id=\'school-members\'><span data-bind=\'text:memberCount()\'></span> classmates registered</div>\n  </div>\n</div>\n';});

define('forum-stats/Component',[
'ko',
'text!york-forum/forum-stats/template.html',
'dispatcher/Dispatcher',
'york-forum/YorkForumStore'],
function(
  ko,
  template,
  Dispatcher,
  Store){

  var ViewModel = function(){

      this.dis = new Dispatcher();
      this.store = Store.getInstance();
      this.isVisible = ko.observable(false);
      this.memberCount = ko.observable(0)

      this.onStore = (function(){
        this.memberCount(this.store.getMemberCount())
        this.isVisible(this.store.isVisible())
      }).bind(this)
      this.store.sub(this.onStore);



}; // end view model.

  return {
    viewModel:ViewModel,
    template: template
  }
});


define('text!class-list/template.html',[],function () { return '<link rel="stylesheet" href="./styles/components/person-panel/class-list.css?v=2.7">\n<div id="people-holder"\n    class="show-vert-scroll"\n    data-bind=\'visible: isVisible() == true\'>\n\n  <div class="person-list-wrapper">\n      <div id="no-members-yet" data-bind="visible:classmateList().length < 1">\n        No one is in this classroom yet.\n      </div>\n      <ul class="person-list"\n          data-bind="foreach:classmateList">\n\n            <li class="person-row"\n                draggable="false"\n                data-bind="click:$parent.classmateClicked,\n                           css:{\'person-row-selected\':$parent.selectedClassmate().getId() == getId(),\n                                \'professor-highlight\':getRole() == \'Professor\',\n                                \'professor-selected\':getRole() == \'Professor\' && $parent.selectedClassmate().getId() == getId()}">\n\n              <div class="person-card">\n                <span class="person-card-info">\n                  <span>\n                      <i class="glyphicon glyphicon-education person-attr-icon"></i>\n                      <span data-bind="text:getEducationLevel()"></span>\n                  </span>\n                  <span>\n                    <i class="glyphicon glyphicon-home person-attr-icon"></i>\n                    <span data-bind="text:getRes()"></span>\n                  </span>\n                  <span>\n                    <i class="glyphicon glyphicon-music person-attr-icon"></i>\n                    <span data-bind="text:getFavouriteMusic()"></span>\n                  </span>\n                </span>\n              </div>\n              <span class="name person-name disable-select"\n                    data-bind="text:getFirst() + \' \' + getLast() + \', \' + getAge()">\n                    first, last, 24\n              </span>\n              <span class="shared-classes disable-select" data-bind="visible:getSharedClassCount() > 1">\n                In <span data-bind="text:getSharedClassCount()"></span> of your classes.\n              </span>\n\n              <div class="dot presence-dot person-panel-dot-position"\n                   data-bind="visible:isPresent()">\n              </div>\n\n              <div class="last-seen"\n                   data-bind="visible:isPresent() == false, text:getLastSeen()"></div>\n\n\n              <div class="person-banner">\n                <div class="person-pic-holder">\n                  <img class="person-pic disable-select"\n                       draggable="false"\n                       data-bind="attr:{src:getSmallPhotoURL()}"/>\n\n                </div>\n              </div>\n              <div class="bevel"\n                   data-bind="css:{\'side-bevel\':$parent.selectedClassmate().getId() == getId()}">\n              </div>\n              <div id="hover-show-bevel"\n                  class="bevel side-bevel">\n              </div>\n              <span class="add-pal-btn-holder" data-bind=\'visible:isAddable()\'>\n                      <button class="add-pal add-pal-btn"\n                              data-bind="click:$parent.addPal">\n                              add friend\n                      </button>\n              </span>\n              <span class="already-friend" data-bind=\'visible:!isAddable()\'>\n                Already your friend.\n              </span>\n            </li>\n        </ul>\n\n   </div>  <!-- person panel wrapper.   -->\n</div>\n';});

/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
define('class-list/Component',['ko',
        'dispatcher/Dispatcher',
        'text!class-list/template.html',
        'people-models/NullPerson',
        'people-store/PeopleStore'],

function(ko,
         Dispatcher,
         template,
         NullPerson,
         PeopleStore){

  function ViewModel(params,componentInfo){

    this.dis = new Dispatcher();
    this.store = PeopleStore.getInstance();
    this.isVisible = ko.observable(false);
    this.groupInfo = ko.observable({
      courseCode:'Coursecode'
    });
    this.yourAMember = false;
    this.isCourseJoinedMessageVisible = ko.observable(false);
    this.classmateList = ko.observableArray([]);
    this.classmateList.extend({notify:'always'});
    this.selectedClassmate = ko.observable(new NullPerson());



    this.onStoreUpdated = (function(){
      var visible = this.store.isClassListVisible();
      this.isVisible(visible);
      if(visible){
        var classmates = this.store.getClassList();
        this.classmateList(classmates.toArray());
      }
    }).bind(this)
    this.store.sub(this.onStoreUpdated);



    this.setStore = function(store){
      this.store = store;
    }

    this.getClassmateCount = function(){
      return this.classmateList().length;
    }

    this.classmateClicked  = function(classmate){
      var p = Object.getPrototypeOf(classmate);
      classmateid = p.id;
      this.dis.dispatch('focusPerson', classmate);
      this.selectedClassmate(classmate);
    }
    this.classmateClicked = this.classmateClicked.bind(this);

    this.onCourseViewSelected = function(){
      var nullPerson = new NullPerson();
      this.selectedClassmate(nullPerson);
    }
    this.onCourseViewSelected = this.onCourseViewSelected.bind(this);
    this.dis.reg('showGroupView', this.onCourseViewSelected);


    this.getSelectedFriendId = function(){
      return this.selectedClassmate().getId();
    }


    this.peopleSubscription = null;
    this.registerPeopleListChangeCallback = function(callback){
      this.peopleSubscription = this.people.subscribe(callback, this, "arrayChange");
    }

    this.unregisterPeopleListChangeCallbacks = function(){
      this.peopleSubscription.dispose();
    }


    this.updateView = function(){
      this.people.valueHasMutated();
    }
    this.updateView = this.updateView.bind(this);

    this.addPal = function(classmate, e){
      e.stopPropagation();
      this.dis.dispatch('addPal',classmate);
    }
    this.addPal = this.addPal.bind(this);

  }; // end viewModel.

  return {
    viewModel: ViewModel,
    template : template
  }

});


define('text!course/course-features/template.html',[],function () { return '\n<link rel="stylesheet"\n      href="./styles/components/course/course-features.css?v=1.2">\n\n<div id="course-features" data-bind="visible:isVisible()">\n     <div id=\'course-loading-spinner\' data-bind=\'style: { opacity:isSpinnerVisible() ? 1.0 : 0.0 }\' class=\'small-spinner\'></div>\n     <tab-selector></tab-selector>\n     <in-another-section-prompt></in-another-section-prompt>\n     <forum></forum>\n     <class-list></class-list>\n     <course-reviews></course-reviews>\n     <course-docs></course-docs>\n</div>\n';});

define('course/models/Location',[],
function(
){

  function Location(data){

    if(!data || typeof data != 'object'){
      throw new Error('Location constructor expects an object as an argument.');
    }

    this.getConstructorName = function(){
      return 'Location';
    }

    this._validateNonEmptyString = function(s, errorMessage){
      if(!errorMessage){
        throw new Error('_validateNonEmptyString must be supplied with a errorMessage');
      }
      if(!s|| typeof s != 'string' || s.length < 1){
        throw new Error(errorMessage);
      }
    }


    this.setId = function(id){
      if(!id || isNaN(id) || id < 1){
        throw new Error('id must be a postive integer.');
      }
      this._locationId = id;
    }
    this.setId(data.location_id);

    this.getId = function(){
      return this._locationId;
    }


    this.setLocationName = function(name){
      this._validateNonEmptyString(name, 'location name must be a non-empty string.');
      this._locationName = name;
    }
    this.setLocationName(data.location_name);


    this.getLocationName = function(){
      return this._locationName;
    }




    this.setServerURLPrefix = function(prefix){
      this._validateNonEmptyString(prefix, 'prefix must be a non-empty string.');
      this._serverURLPrefix = prefix;
    }

    this.getServerURLPrefix = function(){
      return this._serverURLPrefix;
    }

    this.setLocationImageURL = function(url){
      this._validateNonEmptyString(url, 'url must be a non-empty string.');
      this._imgURL = url;
    }
    this.setLocationImageURL(data.img_url);


    this.getLocationImageURL = function(){
      var prefix = this.getServerURLPrefix();
      return prefix + '/' + this._imgURL + '?' + (new Date()).getTime();
    }


  } // end class.

  return Location;
});

define('people-models/Prof',['people-models/Person','ko'],
function(Person, ko){

  var Prof = function(data, host, DocConstructor){

    Object.setPrototypeOf(this, new Person(data, host))
    this.years = ko.observableArray([])

    this.getConstructorName = function(){
      return 'Prof'
    }

    this.addDoc = function(rawDoc){
      if(!rawDoc) throw new Error('expected doc')
      var doc = new DocConstructor(rawDoc, host)
      var year = this.getYear(doc)
      if(!year){
        this.years.push({
          year:doc.year,
          docs:ko.observableArray([doc])
        })
      }
      else{
        year.docs.push(doc)
      }
    }

    /**
      returns the year associated with the doc.
      Otherwise returns null if no year matches the
      docs year.
    */
    this.getYear = function(doc){
      for(var i = 0; i < this.getYearCount(); i++){
        var t = this.years()[i]
        if(t.year == doc.year && t.year == doc.year){
            return t
        }
      }
      return null
    }

    this.getYearAt = function(index){
      return this.years()[index]
    }

    this.getYearCount = function(){
      return this.years().length
    }


    this.getYears = function(){
      return this.years
    }


  } // end constructor.


  Prof.getRaw = function(){
    return Person.getRaw();
  }

  Prof.getFake = function(Constructor){
    const raw = Person.getRaw()
    return new Prof(raw, 'host', Constructor)
  }
  return Prof;
});

define('course/models/CourseGroup',['course/models/Location',
        'people-models/Prof',
        'abstract-interfaces/ValidObject'],
function(Location, Prof, ValidObject){

  function CourseGroup(data, host){

    Object.setPrototypeOf(this, new ValidObject())



    if(!data || typeof data != 'object'){
      throw new Error('CourseSection constructor expects an object as an argument.');
    }

    try{
      this.validateStr(host)
    }catch(err){
      throw new Error('host is required')
    }

    this.isGroup = function(){
      return true
    }

    this.getHost = function(){
      return this.host
    }

    this.setHost = function(host){
      this.validateStr(host)
      this.host = host
    }
    this.setHost(host)


    this._validateId = function(id, errorMessage){
      if(!id || isNaN(id) || id < 1){
        throw new Error(errorMessage);
      }
    }

    this._validateNonEmptyString = function(s, errorMessage){
      if(!errorMessage){
        throw new Error('_validateNonEmptyString must be supplied with a errorMessage');
      }
      if(!s|| typeof s != 'string' || s.length < 1){
        throw new Error(errorMessage);
      }
    }


    this.setId = function(grpId){
        this._validateId(grpId, 'groupId must be a postive integer.');
        this.groupId = grpId;
    }
    this.setId(data.group_id);



    this.getId = function(){
      return this.groupId;
    }



    this._validateNonEmptyString(data.section_letter, 'section_letter must a non-empty string.');
    this._sectionLetter = data.section_letter;
    this.getSectionLetter = function(){
      return this._sectionLetter;
    }


    this.setBuilding = function(building){
      if(!building || typeof building != 'string'){
        throw new Error('building cant be empty');
      }
      this.building = building;
    }
    this.setBuilding(data.building_name);


    this.getBuilding = function(){
      return this.building;
    }

    this.inAnotherSection = function(){
      return this.isInAnotherSection;
    }

    this.setInAnotherSection = function(bool){
      if(typeof bool != 'boolean'){
        throw new Error('bool must be a boolean.');
      }
      this.isInAnotherSection = bool;
    }
    this.setInAnotherSection(data.in_another_section);


    this.setImgUrl = function(imgUrl){
      this.imgUrl = imgUrl;
    }
    this.setImgUrl(data.img_url);


    this.getImgUrl = function(){
      return this.getHost() + '/' + this.imgUrl;
    }

    this.setDept = function(dept){
      this._validateNonEmptyString(dept, 'dept must be non-empty.');
      this.dept = dept;
    }
    this.setDept(data.dept);


    this.getDept = function(){
      return this.dept;
    }

    this.getCourseCode = function(){
      return this._courseCode;
    }

    this.setCourseCode = function(code){
      this._validateNonEmptyString(code, 'course_code must be a non-empty string.');
      this._courseCode = code;
    }
    this.setCourseCode(data.course_code);



    this.getCourseDescription = function(){
      return this.description;
    }

    this.setCourseDescription = function(description){
      this._validateNonEmptyString(description, "description must be a non-empty string.");
      this.description = description;
    }
    this.setCourseDescription(data.description);


    this.setMembershipStatus = function(status){
      if(typeof status !== 'boolean'){
        throw new Error('membership status must be a boolean');
      }
      this.isMemberStatus = status;
    }
    this.setMembershipStatus(data.is_member);



    this.isMember  = function(){
      return this.isMemberStatus;
    }

    this.setProf = function(data){
      this.prof = new Prof(data, host)
    }
    this.setProf(data)

    this.getProf = function(){
      return this.prof
    }

    this.getProfsName = function(){
      return  this.prof.getFirst() + ' ' + this.prof.getLast()
    }

    this.getProfsPhoto = function(){
      return this.prof.getSmallPhotoURL()
    }


  } // end class.

  CourseGroup.getRaw = function(){
    return {
      group_id:1,
      dept:'EECS',
      course_code:"FAKE101",
      description:'Fake Course',
      section_letter:'A',
      is_member:true,
      in_another_section: false,
      building_name:'Accolade East',
      room_name:'001',
      id:2,
      first:'Nick',
      last:'Weber',
      small_photo_url:'small',
      large_photo_url:'large',
      role:'prof'
    }
  }

  CourseGroup.getFake = function(){
    var host = 'http://host'
    return new CourseGroup(CourseGroup.getRaw(), host);
  }




  return CourseGroup;
});

define('course/models/ForumMessage',['ko','text-utilities'],
function(
  ko,
  testUtils){

  var ForumMessage = function(message){


      this.getConstructorName = function(){
        return "ForumMessage";
      }

      this.imgTag = ko.observable('');

      this.timestamp = message.timestamp;
      this.first = message.first;
      this.last = message.last;

      this.setFromSelf = function(bool){
        this.isSelf = bool;
      }
      this.setFromSelf(message.from_self);


      this.setFromFriend = function(){
        this.isSelf = false;
      }

      this.setGroupId = function(gId){
        if(!gId || Number.isInteger(gId) == false){
          throw new Error('group_id is missing or malformed.');
        }
        this.groupId = gId;
      }
      this.setGroupId(message.group_id);


      this.getGroupId = function(){
        return this.groupId;
      }


      this.setSenderImgUrl = function(url){
        if(!url || typeof url != 'string' || url.length < 1){
          throw new Error('sender_img_url is malformed.');
        }
        this.sender_img_url = url;
      }
      this.setSenderImgUrl(message.sender_img_url);


      this.setImgUrlPrefix = function(host){
        if(!this.isHostSet){
          this.sender_img_url =  host + "/" + this.sender_img_url;
        }
        else{
          throw new Error('host has already been set on this forum message.');
        }
      }

      this.getImgUrl = function(){
        return this.sender_img_url;
      }


      this.getImgTag = function(){
        return this.imgTag();
      }

      this.hasImage = ko.computed(function(){
          return this.sender_img_url && this.sender_img_url.length > 0;
      },this);

      this.getText = function(){
        return this.text;
      }

      this.setText = function(text){
        if(typeof text == 'string' && text.length > 0){
          this.text = text;
        }
        else{
          throw new Error('text must be non-empty string');
        }
      }
      this.setText(message.text);

      this.isSelfMessage = function(){
        return this.isSelf == true;
      }

      this.setAsFriend = function(){
        this.isSelf = false;
      }

      this.getHTML = function(){
        var text = this.getText();
        if(this.isSelfMessage()){
            return testUtils.wrapLinks(text,'forum-self-msg-link');
        }
        else{
          return testUtils.wrapLinks(text, 'forum-friend-msg-link');
        }
      }



  }; // end view model.


    ForumMessage.getRaw = function(){
      return {
        group_id:1,
        text:'text',
        timestamp:"2 min ago.",
        first:'chris',
        last:'kerley',
        isSelf:true,
        sender_img_url:'123.jpeg'
      };
    }

  ForumMessage.getFake = function(){
    return new ForumMessage(ForumMessage.getRaw(), 'http://forum.localhost');
  }

  ForumMessage.createSelfMessage = function(text, gId){
    return new ForumMessage({
        first: "",
        from_self: true,
        sender_img_url:'http',
        text: text,
        timestamp: "moments ago.",
        group_id:gId
    });
  }

  return ForumMessage;
});

define('course/models/ForumMessageCollection',['course/models/ForumMessage'],
function(ForumMessage){

  var ForumMessageCollection = function(){

    this.msgs = [];

    this.getConstructorName = function(){
      return "ForumMessageCollection";
    }

    this.getSize = function(){
      return this.msgs.length;
    }

    this.add = function(msg){
      if(typeof msg != 'object' || !msg.getConstructorName ||  msg.getConstructorName() != 'ForumMessage'){
        throw new Error('can only add ForumMessages.');
      }
      this.msgs.push(msg);
    }

    this.get = function(i){
      return this.msgs[i];
    }

    /**
    returns an Array<ForumMessage>
    */
    this.toArray = function(){
      return this.msgs;
    }


    this.clear = function(){
      this.msgs = [];
    }

  }; // end view model.

  ForumMessageCollection.getFake = function(){
      return new ForumMessageCollection();
  }


  return ForumMessageCollection;
});

define('course/CourseRemoteService',['ActiveRemoteService',
        'socketio',
        'dispatcher/Dispatcher',
        'people-models/Pal',
        'course/models/CourseGroup',
        'course/models/ForumMessageCollection',
        'course/models/ForumMessage'],
function(ActiveRemoteService,
         io,
         Dispatcher,
         Pal,
         CourseGroup,
         ForumMessageCollection,
         ForumMessage){


var CourseRemoteService = function(){

    this.dis = new Dispatcher();
    this.constructor = CourseRemoteService;
    Object.setPrototypeOf(this,new ActiveRemoteService());
    this.setMicroServer("course");


    this.init = (function(auth){
      this.setSock();
      this.sock.on('io_error',this.somethingBadHappened);
      this.sock.on('error',this.somethingBadHappened);
      this.sock.on('disconnect',this.somethingBadHappened);
      this.sock.on('connect', this.getMyCourseGroups);
      this.sock.on('myCourseGroups', this.onMyCourseGroups)
      this.sock.on('classmateCourses', this.onClassmateCourses);
      this.sock.on('courseLeft', this.onCourseLeft);
      this.sock.on('coursePhotoUpdate',this.onCoursePhotoUpdate);
      this.sock.on('forumMessages', this.onForumMessageCollectionReceived);
      this.sock.on('forumMessageReceived',this.onForumMessageReceived);
      this.sock.on('groupInfo', this.onGroupReceived);
      this.sock.on('groupJoined', this.onGroupJoined);

    }).bind(this)


    this.onAuth = function(auth){
      if(auth && auth.state == 'authenticated'){
        this.init();
      }
    }
    this.onAuth = this.onAuth.bind(this);
    this.dis.reg('authState', this.onAuth);


    this.getMyCourseGroups = (function(){
      this.sock.emit('getMyCourseGroups')
    }).bind(this)

    this.onMyCourseGroups = (function(groups){
      var wrappedGroups = this.wrapCourseGroups(groups)
      this.dis.dispatch('myCourseGroups', wrappedGroups)
    }).bind(this)

    this.somethingBadHappened = function(err){
      console.log('Something bad happened:');
      console.log(err.message)
    }


    this.onCourseLeft = (function(grpId){
      this.dis.dispatch('courseLeft', grpId);
    }).bind(this)



    this.getClassmatesCourses = (function(person){
      this.sock.emit('getCurrentCoursesFor',this.flatten(person));
    }).bind(this)
    this.onPalFocusId = this.dis.reg('focusPerson', this.getClassmatesCourses);

    /**
      raw: an array of course groups.
    */
    this.onClassmateCourses = (function(raw){
      if(!raw.classmatesId || Number.isInteger(raw.classmatesId) == false || raw.classmatesId < 1){
        throw new Error('classmatesId must be a positive integer.');
      }
      var personId = raw.classmatesId;
      var groups = this.wrapCourseGroups(raw.grps)
     this.dis.dispatch('classmateCourses', {classmatesId:personId, grps:groups});
   }).bind(this)




   this.wrapCourseGroups = function(rawGrps){
     var grps = [];
     var host = this.getServerURL()
     rawGrps.forEach(function(rawGrp){
       grps.push(new CourseGroup(rawGrp, host));
     })
     return grps
   }


    this.onSwitchCourse = function(grp){
      this.sock.emit('switchToCourseGroup', grp);
    }
    this.onSwitchCourse = this.onSwitchCourse.bind(this);
    this.dis.reg('switchToCourseGroup', this.onSwitchCourse);


    this.onGroupReceived = (function(data){
      var group = new CourseGroup(data, this.getServerURL());
      this.dis.dispatch('groupInfo', group);
      this.joinGroupForum(group.getId());
    }).bind(this)


    this.getCourseGroup = (function(groupId){
      this.sock.emit('getCourseGroup', groupId);
    }).bind(this)
    this.getGroupId = this.dis.reg('selectedGroupId',this.getCourseGroup);


    this.registerOnIsProfilePhotoSet = function(callback){
      this._checkType(callback);
      this.onIsProfilePhotoSet = callback;
    }


    this.joinCourse = (function(grpId){
      this.sock.emit('joinCourse', grpId);
    }).bind(this)
    this.joinCourseId = this.dis.reg('joinCourse',this.joinCourse);


    this.onGroupJoined = (function(groupId){
      this.dis.dispatch('groupJoined', groupId);
    }).bind(this)


    this.leaveCourseGroup = function(courseId){
      if(isNaN(courseId) || !courseId){
        throw new Error('courseId must be a number');
      }
      this.sock.emit('leaveCourseGroup', courseId);
    }


    this.onForumMessageReceived = (function(rawMessage){
      var msg = new ForumMessage(rawMessage);
      msg.setImgUrlPrefix(this.getServerURL());
      this.dis.dispatch('forumMessageReceived', msg);
    }).bind(this)


    this.sendForumMessage = (function(message){
      this.sock.emit('sendForumMessage',message);
    }).bind(this)
    this.sendForumMessageId = this.dis.reg('sendForumMessage',this.sendForumMessage);


    this.sendImage = function(courseId, base64Image, text){
      if(!courseId || typeof courseId != 'number' || courseId < 1){
        throw new Error("courseId must be a postive integer.");
      }
      var regex = new RegExp('base64');
      if(typeof base64Image != 'string' || regex.test(base64Image) == false){
        throw new Error("base64Image must be a base64 string.");
      }
      var data = {
        courseId: courseId,
        base64:base64Image,
        text:text
      }
      this.sock.emit('imageUpload', data, this.onImageSent);
    }


    this.registerOnImageSent = function(callback){
      this._checkType(callback);
      this.onImageSent = callback;
    }


    this.registerOnMessagesReceived = function(callback){
      this._checkType(callback);
      this.onMessagesReceived = callback;
    }

    this.onGetMessagesError = function(a, b, err){
      console.log(err);
    }


    this.joinGroupForum = function(grpId){
      this.sock.emit('joinGroupForum',grpId);
    }
    this.joinGroupForum = this.joinGroupForum.bind(this);



    this.onForumMessageCollectionReceived = function(raw){
      if(Array.isArray(raw) == false){
        throw new Error('raw is expected to be an array.');
      }
      var col = new ForumMessageCollection();
      for(var i = 0; i < raw.length; i++){
        var msg = new ForumMessage(raw[i]);
        msg.setImgUrlPrefix(this.getServerURL());
        col.add(msg);
      }
      this.dis.dispatch('forumMessages', col);
    }
    this.onForumMessageCollectionReceived = this.onForumMessageCollectionReceived.bind(this);


    this.registerOnCheckedInLocation = function(callback){
      this._checkType(callback);
      this.onCheckInLocation = callback;
    }

    this.emitLocation = function(courseId, position){
      if(typeof location != 'object'){
        throw new Error('location must be an object');
      }
        var tmp = {
          coords:{
            accuracy:position.coords.accuracy,
            latitude:position.coords.latitude,
            longitude:position.coords.longitude
          },
          timestamp:position.timestamp
        }
      this._checkType(this.onCheckInLocation);
      var data = {
        courseId:courseId,
        location:tmp
      }
      var json = JSON.stringify(data);
      this.sock.emit('checkInLocation', json, this.onCheckInLocation);
    }



    this.onSavePhoto = function(coursePhoto){
      this.sock.emit('saveCoursePhotograph', coursePhoto);
    }
    this.onSavePhoto = this.onSavePhoto.bind(this);
    this.onPhotoId = this.dis.reg('saveCoursePhotograph', this.onSavePhoto);


    this.onCoursePhotoUpdate = function(photoUpdate){
      this.dis.dispatch('coursePhotoUpdate',photoUpdate);
    }
    this.onCoursePhotoUpdate = this.onCoursePhotoUpdate.bind(this);



    this._checkType = function(callback){
      if(typeof callback != 'function'){
        throw new Error('callback must be a function.');
      }
    }




}

return CourseRemoteService;
})
;
define('course/models/CourseSection',[],
function(
){

  function CourseSection(data){

    if(!data || typeof data != 'object'){
      throw new Error('CourseSection constructor expects an object as an argument.');
    }

    this.getConstructorName = function(){
      return 'CourseSection';
    }

    this.setSectionId = function(sectionId){
      if(isNaN(sectionId) || sectionId < 1 || Number.isInteger(sectionId) == false){
        throw new Error('sectionId must be a postive integer.');
      }
      this.sectionId = sectionId;
    }
    this.setSectionId(data.section_id);

    this.getId = function(){
      return this.sectionId;
    }

    this.setSectionLetter = function(sectionLetter){
      if(typeof sectionLetter != 'string' || sectionLetter.length < 1){
        throw new Error('sectionLetter must be a non empty string.');
      }
      this.sectionLetter = sectionLetter;
    }
    this.setSectionLetter(data.section_letter);

    this.getLetter = function(){
      return this.sectionLetter;
    }

  } // end class.

  // factory for creating lists of sections.
  CourseSection.makeSectionsArray = function(sections){
        var arr = [];
        if(Array.isArray(sections) == false || sections.length < 1){
          throw new Error('sections must be a non-empty array.');
        }
        for(var i = 0; i < sections.length; i++){
          var section = new CourseSection(sections[i]);
          arr.push(section);
        }
        return arr;
  };


  return CourseSection;
});

define('course/CourseStore',[
'jquery',
'ko',
'course/CourseRemoteService',
'dispatcher/Dispatcher',
'course/models/CourseGroup',
'course/models/CourseSection',
'course/models/ForumMessage',
'course/models/ForumMessageCollection',
'abstract-interfaces/Store'],
function(
  $,
  ko,
  CourseRemoteService,
  Dispatcher,
  CourseGroup,
  CourseSection,
  ForumMessage,
  ForumMessageCollection,
  Store){

      var instance = null;

      var CourseStore = function(){

        Object.setPrototypeOf(this, new Store());
        this.dis = new Dispatcher();
        this.remoteService = new CourseRemoteService();
        this.isWaitingForServer = false;  // used for spinners, (usually waiting for server response.)
        this.waitingToJoin = false;
        this.userHasProfilePhoto = false;
        this.waitingForRequiredPhoto = false;
        this.showThankYouMessage = false;

        this.group = null;
        this.classmatesCourseGroups = [];
        this.classmatesId = null;
        this.isGrpVisible = false;

        this.forumMessages = new ForumMessageCollection();
        this.forumMsgWasFromSelf = false;
        this.isThankYouForUploadingPhotoMessageVisible = ko.observable(false);

        this.selectedFeature = null


          this.getDis = function(){
            return this.dis;
          }


          this.getRemoteService = function(){
            return this.remoteService;
          }

          this.getSelectedFeature = function(){
            return this.selectedFeature
          }

          this.onCourseFeatureSelection = (function(featureName){
            this.selectedFeature = featureName
            this.pub()
          }).bind(this)
          this.dis.reg('courseFeatureSelection',this.onCourseFeatureSelection)


          this.setImageURLPrefix = function(obj){
            var serverPrefix = this.remoteService.getServerURL();
            if(obj. sender_img_url){
              obj.sender_img_url = serverPrefix + '/' + obj. sender_img_url + '?' + (new Date()).getTime();
            }
          }



        this.setExperimentalMode = function(userId){
            var group = userId % 2;
            if(group == 0){   // Don't require photo to join.
              this.isExperimentalGroup = false
            }
            else if(group == 1){ // Require the photo to join.
              this.isExperimentalGroup = true;
            }
        }

      this.setCurrentCourseGroup = function(group){
        if(!group || !group.isGroup || !group.isGroup()){
          throw new Error('group must be an instance of CourseGroup.');
        }
        this.group = group;
      }

      this.onClassmateCourseGroups = (function(grpsAction){
        grpsAction.grps.forEach(function(e){
          if(!e || !e.isGroup || !e.isGroup()){{
            throw new Error('All groups must be a CourseGroup.');
          }}
        })
        this.classmatesCourseGroups = grpsAction.grps;
        this.classmatesId = grpsAction.classmatesId;
        this.pub();
      }).bind(this)
      this.onPalsCoursesId = this.dis.reg('classmateCourses', this.onClassmateCourseGroups);

      this.getClassmatesId = function(){
        return this.classmatesId;
      }


      this.getClassmateCourseGroups = function(){
        return this.classmatesCourseGroups;
      }

      this.isGroupViewVisible = function(){
        return this.isGrpVisible;
      }

      this.setGroupViewVisible = function(){
        this.isGrpVisible = true;
        this.pub();
      }


        this.openGroupView = (function(){
          this.isGrpVisible = true;
          this.pub()
        }).bind(this)
        this.dis.reg('showGroupView', this.openGroupView);



        this.closeGroupView = (function(){
          this.isGrpVisible = false;
          this.pub();
        }).bind(this)
        this.dis.reg('closeGroupView',this.closeGroupView);
        this.dis.reg('openNews',this.closeGroupView)


        this.onFocusPerson = (function(){
          this.isGrpVisible = false;
          this.pub();
        }).bind(this)
        this.dis.reg('focusPerson', this.onFocusPerson);


        this.getGroupId = function(){
          return this.group.getId();
        }


        this.isGroupMember = function(){
          if(this.group && this.group.isMember()){
            return true
          } else {
            return false
          }
        }


        this.onCourseGroupJoined = (function(groupId){
          if(!groupId || isNaN(groupId) || groupId < 1){
            throw new Error('groupId is malformed.');
          }
          if(groupId !== this.group.getId()){
            throw new Error('groupId does not match currently selected groupId');
          }
          this.group.setMembershipStatus(true);
          this.pub();
          this.waitingToJoin = false;
        }).bind(this)
        this.grpJoinedId = this.dis.reg('groupJoined', this.onCourseGroupJoined);


        this.isWaiting = function(){
          return this.isWaitingForServer;
        }

        this.setWaitingForGroup = (function(){
          this.isWaitingForServer = true
          this.pub()
        }).bind(this)
        this.dis.reg('selectedGroupId', this.setWaitingForGroup)


        this.onSaveCoursePhotograph = (function(){
          this.isWaitingForServer = true;
          this.pub();
        }).bind(this)
        this.dis.reg('saveCoursePhotograph', this.onSaveCoursePhotograph);

        this.isWaitingToJoin = function(){
          return this.waitingToJoin;
        }

        this.setWaitingToJoin = function(){
          this.waitingToJoin = true;
        }

        this.onJoinCourse = (function(){
          this.setWaitingToJoin();
          this.pub();
        }).bind(this)
        this.dis.reg('joinCourse', this.onJoinCourse);


        this.onCoursePhotoUpdate = (function(update){
          if(update.groupId == this.group.getId()){
            this.group.setImgUrl(update.imgUrl);
            this.pub();
          }
        }).bind(this)
        this.dis.reg('coursePhotoUpdate',this.onCoursePhotoUpdate);


        this.onLeaveSelectedCourse = (function(){
          var groupId = this.group.getId();
          this.remoteService.leaveCourseGroup(groupId);
        }).bind(this)
        this.dis.reg('leaveSelectedCourse', this.onLeaveSelectedCourse);


        this.onCourseLeft = (function(groupId){
          if(groupId === this.group.getId()){
            this.group.setMembershipStatus(false);
            this.group.setInAnotherSection(false);
            this.pub();
          }
        }).bind(this)
        this.courseLeftId = this.dis.reg('courseLeft',this.onCourseLeft);


        this.getCurrentGroup = function(){
          return this.group;
        }

        this.onCourseGroupReceived = (function(grp){
          this.group = grp;
          this.isWaitingForServer = false
          this.openGroupView();
        }).bind(this)
        this.groupReceivedId = this.dis.reg('groupInfo', this.onCourseGroupReceived);


        this.getGroupInfo = function(){
          return this.group;
        }

        this.onCheckInLocation = (function(location){
          var groupId = this.group.getId();
          this.remoteService.emitLocation(groupId, location);
        }).bind(this)
        this.checkInLocationCallbackId = this.dis.reg('checkInLocation', this.onCheckInLocation);

        /**
          Handles special cases where the user is
          requested to upload a photo to join a group.
        */
        this.onUserInfo = (function(info){

          info.large_photo_url ? this.userHasProfilePhoto = true : this.userHasProfilePhoto = false;
          if(this.userHasProfilePhoto && this.isWaitingForRequiredPhoto()){
            this.setShowThankYouMessage(true);
            this.setWaitingForRequiredPhoto(false);
          }
          this.pub();
        }).bind(this)
        this.dis.reg('profileUpdate', this.onUserInfo);


        this.setUserHasProfilePhoto = function(bool){
          this.userHasProfilePhoto = bool;
        }

        this.isWaitingForRequiredPhoto = function(){
          return this.waitingForRequiredPhoto;
        }

        this.setWaitingForRequiredPhoto = function(bool){
          this.waitingForRequiredPhoto = bool;
        }

        this.setShowThankYouMessage = function(bool){
          this.showThankYouMessage = bool;
        }

        this.showThankyouMessage = function(){
          return this.showThankYouMessage;
        }

        /**
          When the user is prompted to join a grp and
          they do no have a photo yet and they have asked
          to open the profile setter.   we set a special
          flag so that when they do upload it photo it brings
          them back to the join group prompt.
        */
        this.onShowProfileSetter = (function(){
          if(this.userHasProfilePhoto == false){
            this.waitingForRequiredPhoto = true;
          }
        }).bind(this)
        this.dis.reg('showProfileSetter',this.onShowProfileSetter);


        this.userHasProfilePhoto = function(){
          return this.userHasProfilePhoto;
        }


        this.hasJoinedForum = ko.observable(false); // NOT DONE
        this.forumMessagesuccessfullySent = false;


        this.onForumMessageCollectionReceived = (function(msgs){
          if(typeof msgs != 'object' || msgs instanceof ForumMessageCollection == false){
               throw new Error("ForumMessageCollection expected");
          }
          this.forumMessages = msgs;
          this.pub();
        }).bind(this)
        this.forumMessagesId = this.dis.reg('forumMessages', this.onForumMessageCollectionReceived);



        this.setForumMessages = function(msgs){
          if(msgs instanceof ForumMessageCollection){
            this.forumMessages = msgs;
          }
          else{
            throw new Error('msgs is expected to be a ForumMessageCollection!');
          }
        }

        this.getForumMessages = function(){
          return this.forumMessages;
        }

        this.onForumMessageReceived = (function(msg){
          if(typeof msg != 'object' || msg instanceof ForumMessage == false){
            throw new Error("msg must be a ForumMessage");
          }
          if(msg.getGroupId() == this.getCurrentGroup().getId()){
            this.forumMessages.add(msg);
            msg.isSelfMessage() ? this.setWasFromSelf() : this.setWasNotFromSelf();
            this.pub();
          }
        }).bind(this)
        this.forumMessageResId = this.dis.reg('forumMessageReceived', this.onForumMessageReceived);


        this.setWasFromSelf = function(){
          this.forumMsgWasFromSelf = true;
        }

        this.setWasNotFromSelf = function(){
          this.forumMsgWasFromSelf = false;
        }

        this.wasLastMessageFromSelf = function(){
          return this.forumMsgWasFromSelf;
        }
    }


  return {
    getNew:function(){
      return new CourseStore();
    },
    getInstance:function(){
      if(!instance){
        instance = new CourseStore()
      }
      return instance;
    }
  };

});

define('course-features/Component',[
'ko',
'dispatcher/Dispatcher',
'text!course/course-features/template.html',
'course/CourseStore'],
function(
  ko,
  Dispatcher,
  template,
  CourseStore
){


    var CourseHolderViewModel = function(){

      this.store = CourseStore.getInstance();
      this.dis = new Dispatcher();
      this.isVisible = ko.observable(false);
      this.isSpinnerVisible = ko.observable(false)

      this.onStoreChanged = (function(){
        this.isSpinnerVisible(this.store.isWaiting())
        this.isVisible(this.store.isGroupViewVisible())
      }).bind(this)
      this.store.sub(this.onStoreChanged);




    } // end view model.

  return {
    viewModel:CourseHolderViewModel,
    template:template
  }

});


define('text!course/tab-selector/template.html',[],function () { return '<link rel="stylesheet" href="./styles/components/course/tab-selector.css?v=1.4">\n<div id="tab-selector" data-bind=\'visible:isVisible()\'>\n\n  <span class="course-tab-selector disable-select"\n        data-bind="click:selectCourseForum">\n       Forum\n    <span class="course-tab-underline">\n    </span>\n    <span class="visible-tab-underline"\n          data-bind="visible: forumSelected()">\n   </span>\n  </span>\n\n\n\n  <span class="course-tab-selector disable-select"\n        data-bind="click:selectClassList">\n       Classmates\n      <span class="course-tab-underline"\n         data-bind="visible: classListSelected()">\n      </span>\n  </span>\n\n\n  <!-- <span class="course-tab-selector disable-select"\n         data-bind="click:selectCourseReviews">\n         Reviews\n    <span class="course-tab-underline"></span>\n    <span class="visible-tab-underline"\n          data-bind="visible: courseReviewsSelected()">\n   </span>\n  </span> -->\n\n  <span class="course-tab-selector disable-select"\n         data-bind="click:selectNoteShare">\n         Shared Notes\n    <span class="course-tab-underline"></span>\n    <span class="visible-tab-underline"\n          data-bind="visible: noteShareSelected()">\n   </span>\n  </span>\n\n\n\n</div>\n';});

define('course/tab-selector/TabSelectorStore',[
'ko',
'dispatcher/Dispatcher',
'abstract-interfaces/Store'],
function(
  ko,
  Dispatcher,
  Store){

      var instance = null;

      var TabSelectorStore = function(){

        Object.setPrototypeOf(this, new Store());
        this.dis = new Dispatcher();
        this.noteShareVisible = false
        this.classListVisible = false
        this.reviewsVisible = false
        this.forumVisible = false
        this.visible = false

        this.isTabSelectorVisible = function(){
          return this.visible
        }

        this.isNoteShareVisible = function(){
          return this.noteShareVisible
        }

        this.isClassListVisible = function(){
          return this.classListVisible
        }

        this.isCourseReviewsVisible = function(){
          return this.reviewsVisible
        }

        this.isCourseForumVisible = function(){
          return this.forumVisible
        }

        this.setCourseForumInvisible = function(){
          this.forumVisible = false
        }

        this.onShowGroupView = (function(){
          this.visible = true
          this.pub()
        }).bind(this)
        this.dis.reg('selectedGroupId',this.onShowGroupView)

        this.onHideGroupView = (function(){
          this.visible = false
          this.pub()
        }).bind(this)
        this.dis.reg('hideGroupView', this.onHideGroupView)

        this.onShowNoteShare = (function(featureName){
          featureName == 'noteShare' ? this.noteShareVisible = true : this.noteShareVisible = false
          this.pub()
        }).bind(this)
        this.dis.reg('courseFeatureSelection', this.onShowNoteShare)


        this.onShowCourseReviews = (function(featureName){
          featureName == 'courseReviews' ? this.reviewsVisible = true : this.reviewsVisible = false
          this.pub()
        }).bind(this)
        this.dis.reg('courseFeatureSelection', this.onShowCourseReviews)


        this.onShowCourseForum = (function(featureName){
          featureName == 'courseForum' ? this.forumVisible = true : this.forumVisible = false
          this.pub()
        }).bind(this)
        this.dis.reg('courseFeatureSelection', this.onShowCourseForum)


       this.onShowClasslist = (function(featureName){
         featureName == 'classList' ? this.classListVisible = true : this.classListVisible = false
         this.pub()
       }).bind(this)
       this.dis.reg('courseFeatureSelection', this.onShowClasslist)

}


  return {
    getNew:function(){
      return new TabSelectorStore();
    },
    getInstance:function(){
      if(!instance){
        instance = new TabSelectorStore()
      }
      return instance;
    }
  };

});

define('tab-selector/Component',[
'ko',
'text!course/tab-selector/template.html',
'dispatcher/Dispatcher',
'course/tab-selector/TabSelectorStore'],
function(
  ko,
  template,
  Dispatcher,
  CourseStore){

  function TabSelectorViewModel(){

    this.dis = new Dispatcher();
    this.store = CourseStore.getInstance();
    this.isVisible = ko.observable(false)
    this.forumSelected = ko.observable(false)
    this.classListSelected = ko.observable(false)
    this.courseReviewsSelected = ko.observable(false)
    this.noteShareSelected = ko.observable(false)

    this.onStore = (function(){
      var visible = this.store.isTabSelectorVisible()
      this.isVisible(visible)
      if(visible){
        this.forumSelected(this.store.isCourseForumVisible());
        this.classListSelected(this.store.isClassListVisible());
        this.courseReviewsSelected(this.store.isCourseReviewsVisible());
        this.noteShareSelected(this.store.isNoteShareVisible())
      }
    }).bind(this)
    this.store.sub(this.onStore)


    this.selectCourseForum = (function(){
      this.dis.dispatch('courseFeatureSelection','courseForum')
    }).bind(this)

    this.selectClassList = (function(){
      this.dis.dispatch('courseFeatureSelection','classList')
    }).bind(this)

    this.selectCourseReviews = (function(){
      this.dis.dispatch('courseFeatureSelection','courseReviews')
    }).bind(this)

    this.selectNoteShare = (function(){
      this.dis.dispatch('courseFeatureSelection','noteShare')
    }).bind(this)



}; // end view model.

  return {
    viewModel: TabSelectorViewModel,
    template: template
  }
});


define('text!forum/template.html',[],function () { return '<link rel="stylesheet" href="./styles/components/course/forum.css?v=1.4">\n\n<div id="classroom-holder"\n     data-bind="visible:isVisible()">\n\n     <!-- spinner -->\n     <div  class="screen-center-outer">\n      <div class="screen-center-inner">\n         <div class="loader"\n              data-bind="visible:isSpinnerVisible()">\n         </div>\n      </div>\n    </div>\n\n    <!-- question prompt -->\n\n  <div id="empty-forum-prompt"\n       data-bind="visible:messages().length <= 0 && isSpinnerVisible() == false">\n    <div id=\'forum-group-name\' data-bind=\'text:groupName()\'>Not sure who to ask for help?</div>\n      <div id=\'forum-group-prompt\'>Why not join the conversation?</div>\n  </div>\n\n  <ul data-bind="foreach:messages"\n      id="classroom-messages"\n      class="show-vert-scroll">\n\n    <li class="forum-message"\n        data-bind="css:{ \'self-message\': isSelfMessage(), \'youtube-embed\' : /iframe/.test(getHTML()) }">\n\n      <!-- ko if: typeof getImgUrl() == \'string\' -->\n        <img data-bind="attr:{src:getImgUrl()}"\n             class="classroom-chat-img disable-select">\n        </img>\n      <!-- /ko -->\n\n      <!-- ko if: typeof getImgUrl() != \'string\' && isSelf == false -->\n        <img src="./assets/no-photo.jpg"\n             class="classroom-chat-img disable-select">\n        </img>\n      <!-- /ko -->\n\n\n\n      <span class="plain-text-post">\n        <span data-bind="html:getHTML()"\n              class="chat-text">\n        </span>\n        <span data-bind="text:timestamp"\n              class="classroom-timestamp disable-select">\n        </span>\n        <span data-bind="visible:isSelf == false, text:first + \' \' + last"\n              class="users-name">\n        </span>\n      </span>\n    </li>\n  </ul>\n\n\n\n\n  <div class="message-sender">\n\n      <div id="forum-message-sent"\n           data-bind="visible:showSent()">\n           sent!\n      </div>\n      <div id="forum-message-sent"\n           data-bind="visible:isSendingMessageVisible()">\n           sending.\n      </div>\n      <textarea\n                id="forum-chat-textarea"\n                rows="1"\n                class="show-vert-scroll message-input-holder"\n                placeholder="Type your message here."\n                type="text"\n                data-bind="textInput:newMessage,\n                        event:{\'keydown\':onKeyPress} ,\n                        hasFocus: inputHasFocus(),\n                        click: inputClicked">\n      </textarea>\n\n\n      <button\n              class="disable-select send-message-btn"\n              data-bind="enable:isValidInput(), click:sendForumMessage, css:{}">\n              SEND\n      </button>\n    </div>\n\n</div>\n<!--  end of course holder-->\n';});

define('forum/Component',[
'ko',
'text-utilities',
'text!forum/template.html',
'dispatcher/Dispatcher',
'course/models/ForumMessage',
'course/CourseStore'],
function(
  ko,
  TextUtilities,
  template,
  Dispatcher,
  ForumMessage,
  CourseStore){

  function ForumViewModel(){

    this.dis = new Dispatcher();
    this.store = CourseStore.getInstance();
    this.messages = ko.observableArray([]);
    this.newMessage = ko.observable('');
    this.isVisible = ko.observable(false);
    this.isSpinnerVisible = ko.observable(false);
    this.inputHasFocus = ko.observable(false);
    this.isNewFeatureVisible = ko.observable(false);
    this.isSendingMessageVisible = ko.observable(false);
    this.showSent = ko.observable(false);
    this.hasBeenInitialized = false;
    this.groupName = ko.observable('')


    this.onStoreChanged = (function(){
      var group = this.store.getGroupInfo();
      if(!group || !group.isGroup || !group.isGroup()){
        return;
      }
      this.groupName(group.getDept() + ' ' + group.getCourseCode() + ' Section ' + group.getSectionLetter())
      this.isVisible(this.store.getSelectedFeature() == 'courseForum');
      this.populateMessages();
      this.store.wasLastMessageFromSelf() ? this.onMessageSent() : "";
    }).bind(this)
    this.store.sub(this.onStoreChanged, this);

    this.resizeTextArea = (function(){
      var rows = this.newMessage().split(/\r\n|\r|\n/).length
      $('#forum-chat-textarea').attr('rows',rows)
    }).bind(this)


    this.onMessageSent = function(){
      this.isSendingMessageVisible(false);
      this.showSent(true);
      var self = this;
      if(self.sentId){
        clearTimeout(self.sentId);
      }
      self.sentId = setTimeout(function(){
        self.showSent(false);
      },2000);
          this.resizeTextArea()
    }
    this.onMessageSent = this.onMessageSent.bind(this);


    this.populateMessages = (function(){
      var messages = this.store.getForumMessages().toArray();
      this.messages([]);
      for(var i = 0; i < messages.length; i++){
        this.messages.unshift(messages[i]);
      }
      this.isSpinnerVisible(false);
    }).bind(this)

    this.newMessage.subscribe(function(text){
      if(/\S/.test(text)){
        this.isValidInput(true);
      }
      else{
        this.isValidInput(false)
      }
    },this);
    this.isValidInput = ko.observable(false);



    this.onKeyPress = (function(vm, event){
      this.resizeTextArea()
      event.send = this.sendForumMessage;
      return TextUtilities.onKeyPress(event);
    }).bind(this)


    this.sendForumMessage = (function(){
      var text = this.newMessage();
      text = TextUtilities.formatToHTML(text);
      var grpId = this.store.getCurrentGroup().getId();
      var msg = ForumMessage.createSelfMessage(text, grpId);
      this.messages.unshift(msg);
      this.dis.dispatch('sendForumMessage',msg);
      this.newMessage('');
      this.isSendingMessageVisible(true);
    }).bind(this)

    this.appendMessage = function(message){
      if(message instanceof ForumMessage == false){
        throw new Error('expected messaged to be a ForumMessage');
      }
      this.messages.unshift(message);
    }
    this.appendMessage = this.appendMessage.bind(this);



    this.inputClicked = function(){
      this.inputHasFocus(true);
    }
}; // end view model.

  return {
    viewModel: ForumViewModel,
    template: template
  }
});


define('text!non-member-prompt/template.html',[],function () { return '<link rel="stylesheet"\n      href="./styles/components/course/prompts/non-member.css">\n\n  <div\n      id="course-joined-message"\n      data-bind="visible:showCourseJoinedMessage()">\n    <span>You have joined!</span>\n    <span id="ok-sign">\n      &#10003;\n    </span>\n  </div>\n\n\n<div id="membership-prompt-holder"\n      data-bind="visible:isVisible()">\n\n  <!-- spinner -->\n  <div  class="screen-center-outer">\n   <div class="screen-center-inner">\n      <div class="loader"\n           data-bind="visible:isSpinnerVisible()">\n      </div>\n   </div>\n </div>\n\n  <div data-bind="text:joinPromptMessage(),\n                  visible:userHasPhoto() == false">\n  </div>\n\n  <div data-bind="visible:userHasPhoto() == false">\n       <img id=\'empty-photo-button\'\n            data-bind="click:showProfileSetter, attr:{src:profilePhotoURL}"\n            src="#">\n        </img>\n  </div>\n\n\n  <button class="large-blue-button"\n           data-bind="disable: userHasPhoto() == false, click:joinCourse">\n    Join\n  </button>\n\n  <div id="thank-you-message"\n       data-bind="visible: isThankYouMessageVisible()">\n    <div>Thank you!</div>\n    <div>Now you are free</div>\n    <div>to join. &#128513;</div>\n  </div>\n\n</div>\n';});

define('non-member-prompt/Component',['ko',
'text!non-member-prompt/template.html',
'dispatcher/Dispatcher',
'course/CourseStore'],
function(
  ko,
  template,
  Dispatcher,
  CourseStore){

  function MembershipPromptViewModel(){
    this.store = CourseStore.getInstance();
    this.dis = new Dispatcher();
    this.isVisible = ko.observable(false);
    this.isSpinnerVisible = ko.observable(false);
    this.userHasPhoto = ko.observable(true);
    this.profilePhotoURL = './assets/no-photo.jpg';
    this.joinPromptMessage = ko.observable('Upload your photo to join.');
    this.showCourseJoinedMessage = ko.observable(false);
    this.isThankYouMessageVisible = ko.observable(false);
    this.courseCode = ko.observable('');
    this.sectionLetter = ko.observable('');


    this.onStoreChange = (function(){

      var isWaitingToJoin = this.store.isWaitingToJoin();
      if(isWaitingToJoin){
        this.showGroupJoined();
      }
      var grp = this.store.getGroupInfo();
      if(grp && !grp.isMember() && !grp.inAnotherSection()){
        this.isVisible(true);
        this.courseCode(grp.getCourseCode());
        this.sectionLetter(grp.getSectionLetter());
        this.userHasPhoto(this.store.userHasProfilePhoto);
        if(this.store.showThankyouMessage()){
          // console.log('SHOWING THANK YOU!!!!');
          this.isThankYouMessageVisible(true);
          this.dis.dispatch('hideProfileSetter');
        }
      }
      else{
        this.isVisible(false);
      }
    }).bind(this)
    this.store.sub(this.onStoreChange);




    this.joinCourse = function(){
      if(!this.store.getCurrentGroup()){
        throw new Error('groupInfo has not been initialized yet.');
      }
      this.isSpinnerVisible(true);
      var grpId = this.store.getCurrentGroup().getId();
      this.isThankYouMessageVisible(false);
      this.dis.dispatch('joinCourse', grpId);
    }


    this.showGroupJoined = (function(){
      this.isSpinnerVisible(false)
      this.showCourseJoinedMessage(true);
      this.isThankYouMessageVisible(false);
      var self = this;
      window.setTimeout(function(){
        self.showCourseJoinedMessage(false);
        self.isVisible(false);
      },2500);
    }).bind(this)


    this.showProfileSetter = function(){
      this.dis.dispatch('showProfileSetter');
    }



}; // end view model.

  return {
    viewModel: MembershipPromptViewModel,
    template: template
  }
});


define('text!in-another-section-prompt/template.html',[],function () { return '<link rel="stylesheet" href="./styles/components/course/prompts/in-another-section.css">\n\n<div data-bind="visible:isVisible()" id=\'in-another-section-holder\'>\n     <div>\n              You are already in another section for\n          <span data-bind="text:dept() + courseCode()"></span>\n     </div>\n     <div id="another-section-switch">Switch to this section?</div>\n     <div>\n       <button data-bind="click:switchCourse">Yes</button>\n     </div>\n</div>\n';});

define('in-another-section-prompt/Component',['ko',
'text!in-another-section-prompt/template.html',
'dispatcher/Dispatcher',
'course/CourseStore'],
function(
  ko,
  template,
  Dispatcher,
  CourseStore){

  function InAnotherSectionViewModel(){
    this.store = CourseStore.getInstance();
    this.dis = new Dispatcher();
    this.sectionLetter = ko.observable('');
    this.courseCode = ko.observable('');
    this.dept = ko.observable('');
    this.isVisible = ko.observable(false);

    this.onStoreChange = function(){
      var grp = this.store.getCurrentGroup();
      var isVisible = grp && !grp.isMember() && grp.inAnotherSection();
      this.isVisible(isVisible);
      if(isVisible){
        this.sectionLetter(grp.getSectionLetter());
        this.dept(grp.getDept());
        this.courseCode(grp.getCourseCode());
      }
    }
    this.onStoreChange = this.onStoreChange.bind(this);
    this.store.sub(this.onStoreChange);



    this.switchCourse = function(){
      var grp = this.store.getCurrentGroup();
      this.dis.dispatch('switchToCourseGroup', grp);
    }



}; // end view model.

  return {
    viewModel: InAnotherSectionViewModel,
    template: template
  }
});


define('text!course-reviews/template.html',[],function () { return '<link rel="stylesheet" href="./styles/components/course-reviews/style.css">\n\n<div  id=\'course-reviews-holder\' data-bind=\'visible:isVisible()\'>\n<div class=\'post-comment\'>\n  <div class="comment-as-header">Review as <span data-bind="text:\'First Last\'"></span></div>\n  <textarea class=\'post-comment-message\'\n            placeholder="What did you think of this course?">\n\n  </textarea>\n  <button class=\'blue-square-button\'>Submit</button>\n</div>\n\n\n<ul id=\'review-list\' data-bind=\'foreach:reviews\'>\n  <li class=\'course-review\'>\n\n    <span class=\'review-helpfulness-vote\'>\n      <!-- <span class=\'review-votes-holder\'>\n        <span data-bind=\'text:votes\'></span>\n        <span class=\'glyphicon glyphicon-arrow-up\'></span>\n      </span> -->\n    </span>\n    <span class=\'reviewer\'>\n      <span class=\'reviewer-image-holder\'>\n        <img class=\'reviewer-image\' src=\'./assets/no-photo.jpg\'></img>\n        <div class=\'reviewer-name\' data-bind=\'text:name\'></div>\n      </span>\n    </span>\n    <span class=\'review-text\'>\n      <div class=\'review-text-title\' data-bind=\'text:title\'></div>\n      <div class=\'review-text-body\' data-bind=\'text:body\'></div>\n    </span>\n  </li>\n</ul>\n\n</div>\n';});

define('course-reviews/ReviewsStore',['dispatcher/Dispatcher',
        'abstract-interfaces/Store'],
function(Dispatcher,
         Store){


   var instance = null;
   var ReviewsStore  = function(){

     Object.setPrototypeOf(this, new Store())
     this.dis = new Dispatcher()


     this.isReviewsVisible = function(){
       return this.reviewsVisible
     }

     this.onShowCourseReviews = (function(featureName){
       featureName == 'courseReviews' ? this.reviewsVisible = true : this.reviewsVisible = false;
       this.pub()
     }).bind(this)
     this.dis.reg('courseFeatureSelection', this.onShowCourseReviews)



  } // end

    return {
      getInstance:function(){
        if(!instance){
          instance = new ReviewsStore();
        }
        return instance;
      },
      getNew:function(){
        return new ReviewsStore();
      }
    }
  })
;
define('course-reviews/Component',[
'ko',
'text!course-reviews/template.html',
'dispatcher/Dispatcher',
'course-reviews/ReviewsStore'],
function(
  ko,
  template,
  Dispatcher,
  CourseStore){

  function ForumViewModel(){

    this.dis = new Dispatcher();
    this.store = CourseStore.getInstance();
    this.isVisible = ko.observable(false);
    this.reviews = ko.observableArray([
      {
        name:'Chris Kerley',
        image:'./assets/no-img.jpg',
        title:'Summer 2013 with Suprakash Datta',
        body:`Its math so its basically just practice. I personally never found lectures that useful in math related courses. I think you will be okay. PSYC2021 is easy stats math. Grade school level stuff like mean median mode, then t-tests and normal distributions and confidence intervals. When I took it in 2016 it was very enjoyable, Richard Murray is great. The course is very well designed. A bit of formula memorization, but if you do the homework you should be fine. Easy A+`,
        votes:23
      },
      {
        name:'Mike Kerley',
        image:'./assets/no-img.jpg',
        title:'Fall 2002 with Jeffery Edmunds',
        body:`Its math so its basically just practice. I personally never found lectures that useful in math related courses. I think you will be okay. PSYC2021 is easy stats math. Grade school level stuff like mean median mode, then t-tests and normal distributions and confidence intervals. When I took it in 2016 it was very enjoyable, Richard Murray is great. The course is very well designed. A bit of formula memorization, but if you do the homework you should be fine. Easy A+`,
        votes:102
      }
    ])


    this.onStore = (function(){
      this.isVisible(this.store.isReviewsVisible())
    }).bind(this)
    this.store.sub(this.onStore)

}; // end view model.

  return {
    viewModel: ForumViewModel,
    template: template
  }
});

define('course-docs/models/Doc',['abstract-interfaces/ValidObject',
        'people-models/Prof'],
function(ValidObject, Prof){
  var Doc = function(file){

    Object.setPrototypeOf(this, new ValidObject())


    this.setShallowProf = function(prof){
      this.prof = prof;
    }

    this.getProf = function(){
      return this.prof
    }

    this.setTitle = function(title){
      this.validateStr(title)
      this.title = title
    }

    this.getTitle = function(){
      return this.title
    }



    this.setYear = function(year){
      this.validateId(year)
      this.year = year;
    }

    this.getYear = function(){
      return this.year;
    }

    this.setTopics = function(topics){
      this.topics = topics;
    }

    this.getTopics = function(){
      return this.topics
    }
  }

return Doc;
})
;
define('course-docs/models/SavedDoc',['course-docs/models/Doc',
        'people-models/Person'],
function(Doc,
         Person){
  var SavedDoc = function(rawDoc, host){

    Object.setPrototypeOf(this, new Doc(rawDoc))

    this.setId = (function(id){
      this.validateId(id)
      this.docId = id
    }).bind(this)
    this.setId(rawDoc.doc_id)

    this.getId = function(){
      return this.docId
    }

    this.setProfId = function(id){
      this.validateId(id)
      this.id = id
    }
    this.setProfId(rawDoc.id)

    this.getProfId = function(){
      return this.id
    }

    this.getCourseId = function(){
      return this.courseId
    }

    this.setCourseId = function(id){
      this.validateId(id)
      this.courseId = id
    }
    this.setCourseId(rawDoc.course_id)

    this.isLocked = function(){
      return this.locked
    }

    this.setLocked = function(locked){
      this.validateBool(locked);
      this.locked = locked == 1 ? true : false;
    }
    this.setLocked(rawDoc.locked)



    this.getFileURL = function(){
      return this.host + '/' + this.fileURL
    }

    this.setFileURL = function(url){
      if(!this.isLocked()){
        this.validateStr(url)
        this.fileURL = url
      }
    }
    this.setFileURL(rawDoc.file_url)

    this.getHost = function(){
      return this.host
    }

    this.setHost = function(host){
      this.validateStr(host)
      this.host = host
    }
    this.setHost(host)

    this.getLastOpened = function(){
      if(this.lastOpened){
        var format = {month:'long', year:'numeric', day:'numeric'}
        return this.lastOpened.toLocaleString('en-us',format)
      }
      else{
        return 'never'
      }
    }

    this.setLastOpened = function(date){
      if(!date){
        this.lastOpened = null
      }
      else{
      this.lastOpened = new Date(date)
      }
    }
    this.setLastOpened(rawDoc.last_opened)

    this.setTitle(rawDoc.title)
    this.setTopics(rawDoc.topics)
    this.setYear(rawDoc.year)
  }

  SavedDoc.getRaw = function(){
    var o1 = {
      doc_id:1,
      title:'Midterm',
      year:2020,
      course_id:5,
      file_url:'s.pdf',
      last_opened:'2020-04-05T17:35:15.000Z',
      locked:0,
    }
    var o2 = Object.assign(o1, Person.getRaw())
    return o2;
  }

  SavedDoc.getFake = function(){
    var raw = SavedDoc.getRaw()
    return new SavedDoc(raw, 'fakehost')
  }

return SavedDoc;
})
;
define('course-docs/models/UnsavedDoc',['course-docs/models/Doc',
        'people-models/Prof',
         'course/models/CourseGroup'],
function(Doc,
         Prof,
         CourseGroup){
  var UnsavedDoc = function(file, grp){

    Object.setPrototypeOf(this, new Doc())
    this.MAX_FILE_SIZE = 10000000


    this.setTitle = function(title){
      if(typeof title != 'string')
        throw new Error('title must be a string')
      this.title = title
    }

    this.setFile = (function(file){
      if(file instanceof File == false){
        throw new Error('must be a file')
      }
      if(file.size > this.MAX_FILE_SIZE){
        throw new Error('That file is too large. (10mb max)')
      }
      this.file = file
      this.setTitle(this.file.name)
    }).bind(this)
    this.setFile(file)

    this.getFile = function(){
      return this.file
    }

    this.encodeFile = (function(done){
      var reader = new FileReader();
      var self = this;
      reader.onload = function(e){
        self.encodedFile = e.target.result;
        if(done && typeof done == 'function'){
          done()
        }
      }
      reader.readAsDataURL(this.file);
    }).bind(this)


    this.getEncodedFile = function(){
      return this.encodedFile
    }


    this.getFileName = function(){
      return this.file.name
    }

    this.setGrp = function(grp){
      if(!grp.isGroup()){
        throw new Error('Expected a CourseGroup instance')
      }
      this.grp = grp;
    }
    this.setGrp(grp)

    this.getGrp = function(){
      return this.grp;
    }

    this.getGrpId = function(){
      return this.grp.getId()
    }

    this.isSendable = function(){
      return  !this.file == false &&
              !this.title == false &&
              this.profId > 0;
    }

    this.setProfId = function(id){
      this.validateId(id)
      this.profId = id
    }



    this.serialize = (function(){

      if(!this.encodedFile) throw new Error('cannot serialize if the file has not been encoded yet')
      if(!this.year) throw new Error('to serialize, the year must be set')
      if(!this.profId)
        throw new Error('to serialize, the profId must be set')

      return {
        title:this.title,
        file:this.encodedFile,
        year:this.year,
        profId:this.profId,
        grpId:this.grp.getId()
      }
    }).bind(this)

  }

  UnsavedDoc.getFake = function(){
    var grp = CourseGroup.getFake()
    return new UnsavedDoc(new File([],'name'),grp)
  }

  UnsavedDoc.getFakeSerializable = function(){
    var grp = CourseGroup.getFake()
    var doc = new UnsavedDoc(new File([],'name'),grp)
    doc.encodedFile = 'string'
    doc.setYear(2000)
    doc.setProfId(1)
    doc.grp = CourseGroup.getFake()
    return doc
  }

return UnsavedDoc;
})
;
define('course-docs/models/DocumentCollection',['abstract-interfaces/ValidObject',
        'people-models/Prof',
        'course-docs/models/SavedDoc',
        'ko'],
function(ValidObject, Prof, DocConstructor, ko){

  var DocCollection = function(rawDocs, host){

    Object.setPrototypeOf(this, new ValidObject())
    this.validateStr(host)
    this.profs = []

    this.insertDocs = (function(docs){
      if(!Array.isArray(docs))
        throw new Error('expected an array.')
      var self = this
      docs.forEach(function(d){
        self.insertDoc(d)
      })
    }).bind(this)


    /**
      onlyinsert the prof if they are not
      already in the profs array.
    */
    this.insertDoc = (function(doc){
      var prof = this.getProf(doc)
      if(!prof){
        var objProf = new Prof(doc, host, DocConstructor)
        objProf.addDoc(doc)
        var obvProf = ko.observable(objProf)
        this.profs.push(obvProf)
      }
      else{
        this.profs.forEach(function(p){
          if(p().getId() == doc.id){
            p().addDoc(doc)
          }
        })
      }
    }).bind(this)

    /**
      Attempts to get the prof associated
      with the given document.  Returns
      null if no prof exist for that doc.
    */
    this.getProf = function(rawDoc){
      var prof = null
      this.profs.forEach(function(obvProf){
        if(rawDoc.id == obvProf().id){
          prof = obvProf
        }
      })
      return prof
    }



    this.getProfs = function(){
      return this.profs
    }


    this.getSize = function(){
      return this.profs.length
    }


    this.insertDocs(rawDocs)
  } // end constructor

  DocCollection.getFake = function(){
    return new DocCollection([],'fakehost')
  }

return DocCollection;
})
;
define('course-docs/DocRemoteService',['ActiveRemoteService',
        'format-converter',
        'dispatcher/Dispatcher',
        'course-docs/models/SavedDoc',
        'course-docs/models/DocumentCollection',
        'course/models/CourseGroup',
        'people-models/Prof'],
function(ActiveRemoteService,
        FormatConverter,
        Dispatcher,
        SavedDoc,
        DocCollection,
        CourseGroup,
        Prof){


var CourseRemote = function(){

    this.constructor = CourseRemote;
    Object.setPrototypeOf(this,new ActiveRemoteService());
    this.setMicroServer("tests");
    this.dis = new Dispatcher()


    this.getDocs = (function(grp){
      this.isAdmin()
      if(!grp.isGroup || !grp.isGroup()){
        throw new Error('Can only get docs for a group.')
      }
      var url = this.getServerURL() + '/grp/' + grp.getId() + '/course-docs';
      $.ajax({
        url:url,
        type:'get',
        beforeSend:this.setAuthorizationHeader,
        success:this.onDocs,
        error:this.onError
      });
    }).bind(this)
    this.onGrpId = this.dis.reg('groupInfo',this.getDocs)
    this.onGetDocs = this.dis.reg('getDocs',this.getDocs)

    this.isAdmin = (function(){
      var url = this.getServerURL() + '/course-docs/uploader'
      var self = this
      $.ajax({
        url:url,
        type:'get',
        beforeSend:this.setAuthorizationHeader,
        success:function(response){
          var allowed = false
          if(response == 'true')
            allowed = true
          self.dis.dispatch('uploadingAllowed',allowed)
        },
        error:this.onError
      });
    }).bind(this)


    this.onDocs = function(json){
      try{
        var rawDocs = JSON.parse(json)
        var host = this.getServerURL()
        var docs = new DocCollection(rawDocs, host)
        this.dis.dispatch('courseDocs',docs)
      }
      catch(err){
        console.log(err)
        if(/in JSON at position/.test(err.message)){
          throw Error('malformed json string')
        }
      }
    }
    this.onDocs = this.onDocs.bind(this)

    this.addCourseAndUpload = (function(doc){
      var url = this.getServerURL() + '/course-docs/addCourseAndUpload'
      var self = this
      $.ajax({
        url:url,
        type:'post',
        data:{json:JSON.stringify(doc.serialize())},
        beforeSend:self.setAuthorizationHeader,
        success:self.onDocSubmitted,
        error:self.onError
      });
    }).bind(this)

    this.onSubmitDoc = (function(unsavedDoc){
      var url = this.getServerURL() + '/course-docs/upload'
      var self = this
      unsavedDoc.encodeFile(function(){
        $.ajax({
          url:url,
          type:'post',
          data:{json:JSON.stringify(unsavedDoc.serialize())},
          beforeSend:self.setAuthorizationHeader,
          success:self.onDocSubmitted,
          error:self.onError
        });
      })
    }).bind(this)
    this.submitDocId = this.dis.reg('submitDoc',this.onSubmitDoc)




    this.onDocSubmitted = (function(res){
      if(/no record/.test(res))
        this.dis.dispatch('openAddCourse')
      else
         this.dis.dispatch('docSubmitted',res)
    }).bind(this)


    this.onError = (function(err){
      console.log(err)
      alert(err.responseText)
    }).bind(this)

    this.recordDocDownload = (function(doc){
      var url = this.getServerURL() + '/course-docs/docDownloaded';
      $.ajax({
        url:url,
        type:'post',
        data:{docId:doc.getId()},
        beforeSend:this.setAuthorizationHeader,
        success:function(){},
        error:this.onError
      });
    }).bind(this)
    this.recordDownloadId = this.dis.reg('openDoc',this.recordDocDownload)

    this.getMatchingProfs = (function(name){
      var url = this.getServerURL() + '/course-docs/profs?name=' + name
      $.ajax({
        url:url,
        type:'get',
        beforeSend:this.setAuthorizationHeader,
        success:this.onMatchingProfs,
        error:this.onError
      });
    }).bind(this)
    this.getMatchingProfsId = this.dis.reg('getMatchingProfs',this.getMatchingProfs)


    this.onMatchingProfs = (function(matches){
      var profs = []
      var host = this.getServerURL()
      for(var i = 0; i < matches.length; i++){
        var data = matches[i]
        var prof = new Prof(data,host,SavedDoc)
        profs.push(prof)
      }
      this.dis.dispatch('matchingProfs',profs)
    }).bind(this)

    //
    //
    // this.registerOnRole = function(callback){
    //   this._checkType(callback);
    //   this.onRoleReceived = callback;
    // }
    //
    //
    // this.getRole = function(){
    //   var url = this.getServerURL() + '/getRole';
    //   $.ajax({
    //     url:url,
    //     type:'GET',
    //     beforeSend:this.setAuthorizationHeader,
    //     success:this.onRoleReceived,
    //     error:function(a,b,err){
    //       console.log(err);
    //     }
    //   });
    // }
    //
    // this.registerOnPractiseTestsRecieved = function(callback){
    //   this._checkType(callback);
    //   this.onPractiseTestsRecieved = callback;
    // }
    //
    // this.registerOnPractiseRetrievalError = function(callback){
    //   this._checkType(callback);
    //   this.onTestRetrievalError = callback;
    // }
    //
    // this.getPractiseTests = function(groupId){
    //
    //   var url = this.getServerURL() + '/' + groupId + '/practice_tests';
    //   $.ajax({
    //     url:url,
    //     type:'get',
    //     beforeSend:this.setAuthorizationHeader,
    //     success:this.onPractiseTestsRecieved,
    //     error:this.onTestRetrievalError
    //   });
    // }
    //
    // this.registerOnTestCollectionChanged = function(callback){
    //   this._checkType(callback);
    //   this.onTestCollectionChanged = callback;
    // }
    //
    // this.registerOnTestUploadError = function(callback){
    //   this._checkType(callback);
    //   this.onTestUploadError = callback;
    // }
    //
    // this.saveFile = function(base64, courseId, testName, year){
    //   if(!courseId || isNaN(courseId)){
    //     throw new Error('courseId must be a parameter to save a Test File.');
    //   }
    //   if(!testName || typeof testName != 'string' || testName.length < 1){
    //     throw new Error('testName must be a string and included as a parameter.');
    //   }
    //   if(!year || typeof year != 'number' || year < 1900){
    //     throw new Error('year must be a number and included as a parameter.');
    //   }
    //   var url = this.getServerURL() + '/test_upload/' + courseId + '/' + year;
    //   var formData = new FormData();
    //   var blob = FormatConverter.base64ToBlob(base64);
    //   formData.append(testName, blob);
    //   $.ajax({
    //     url:url,
    //     type:'POST',
    //     data:formData,
    //     contentType:false,
    //     processData:false,
    //     beforeSend:this.setAuthorizationHeader,
    //     success:this.onTestCollectionChanged,
    //     error:this.onTestUploadError
    //   });
    // }
    //
    //
    // this.onCoursePhotoUploaded = function(result){
    //   console.log(result)
    // }
    //
    //
    // this.recordTestDownload = function(testId){
    //
    //   var url = this.getServerURL() + '/practice_tests/' + testId + "/recordDownload";
    //   $.ajax({
    //     url:url,
    //     type:'POST',
    //     beforeSend:this.setAuthorizationHeader,
    //     success:function(){
    //
    //     },
    //     error:function(a,b,err){
    //       console.log(err);
    //     }
    //   })
    // }
    //
    //
    // this.deleteTest = function(testId){
    //   var url = this.getServerURL() + '/practice_tests/' + testId;
    //   $.ajax({
    //     url:url,
    //     type:'DELETE',
    //     beforeSend:this.setAuthorizationHeader,
    //     success:this.onTestCollectionChanged,
    //     error:function(a,b,err){
    //       console.log(err);
    //     }
    //   })
    // }
    //
    // this._checkType = function(callback){
    //   if(typeof callback != 'function'){
    //     throw new Error('callback must be a function.');
    //   }
    // }
}

return CourseRemote;
})
;
define('course-docs/DocStore',['abstract-interfaces/Store',
        'dispatcher/Dispatcher',
        'course-docs/models/SavedDoc',
        'course-docs/models/UnsavedDoc',
        'course-docs/DocRemoteService',
        'course-docs/models/DocumentCollection'],
function(AbstractStore,
         Dispatcher,
         SavedDoc,
         UnsavedDoc,
         DocRemoteService,
         DocCollection){

  var instance = null;

var DocStore = function(){
    this.constructor = DocStore;
    new DocRemoteService()
    Object.setPrototypeOf(this,new AbstractStore());
    this.currentGrp = null;
    this.dis = new Dispatcher();
    this.isDocsVisible = false
    this.isUploaderOpen = false
    this.unsavedDoc = null
    this.waiting = false
    this.docChanged = false
    this.lastUnsavedDoc = null
    this.docs = new DocCollection([],'http://localhost/')
    this.matchingProfs = null
    this.isUploadingAllowed = false
    this.courseAdderOpen = false
    this.joinPromptVisible = false


    this.onAddCourseAndUpload = (function(){
      this.waiting = true
      this.pub()
    }).bind(this)
    this.dis.reg('addCourseAndUpload',this.onAddCourseAndUpload)


    this.onOpenCourseAdder = (function(){
      this.courseAdderOpen = true
      this.pub()
    }).bind(this)
    this.dis.reg('openAddCourse',this.onOpenCourseAdder)

    this.isCourseAdderVisible = function(){
      return this.courseAdderOpen
    }


    this.onUploadingAllowed = (function(response){
      this.isUploadingAllowed = true
    }).bind(this)
    this.dis.reg('uploadingAllowed', this.onUploadingAllowed)

    this.isWaiting = function(){
      return this.waiting
    }

    this.docCount = function(){
      return this.docs.getSize()
    }

    this.getUnsavedDoc = function(){
      return this.unsavedDoc
    }

    this.getUnsavedDocTitle = function(){
      if(this.unsavedDoc){
        return this.unsavedDoc.getTitle()
      }
      else{
        return ''
      }
    }

    this.getGroupCourseInfo = function(){
      if(this.currentGrp){
        var dept = this.currentGrp.getDept()
        var code = this.currentGrp.getCourseCode()
        var desc = this.currentGrp.getCourseDescription()
        return dept + code + ' ' + desc
      }
    }

    this.onGrp = (function(grp){
      this.currentGrp = grp;
    }).bind(this)
    this.onGrpId = this.dis.reg('groupInfo', this.onGrp)

    this.isJoinGroupPromptVisible = function(){
      return this.joinPromptVisible
    }

    this.isCourseDocsPermitted = function(){
      return this.courseDocsPermitted
    }

    this.onJoined = (function(){
      this.courseDocsPermitted = true
      this.pub()
    }).bind(this)
    this.dis.reg('groupJoined', this.onJoined)

    this.onGroupLeft = (function(){
      this.courseDocsPermitted = false
      this.pub()
    }).bind(this)
    this.dis.reg('courseLeft', this.onGroupLeft)


    this.onShowCourseDocs = (function(featureName){
      featureName == 'noteShare' ? this.isDocsVisible = true : this.isDocsVisible = false;
      if(this.currentGrp && this.currentGrp.isMember())
        this.courseDocsPermitted = true
      else
        this.courseDocsPermitted = false
      this.pub()
    }).bind(this)
    this.showDocsId = this.dis.reg('courseFeatureSelection',this.onShowCourseDocs)



    this.isCourseDocsVisible = (function(){
      return this.isDocsVisible
    }).bind(this)


    this.onCourseDocs = (function(docs){
      this.docs = docs
      this.pub()
    }).bind(this)
    this.onDocsId = this.dis.reg('courseDocs',this.onCourseDocs)


    this.onTestDocUpload = (function(){
      this.isWaitingToLoad = true
      this.pub()
    }).bind(this)


    this.onOpenDocUploader = (function(){
      this.isUploaderOpen = true
      this.pub()
    }).bind(this)
    this.openUploaderId = this.dis.reg('openDocUploader',this.onOpenDocUploader)


    this.onCloseDocUploader = (function(){
      this.isUploaderOpen = false
      this.unsavedDoc = null
      this.pub()
    }).bind(this)
    this.closeUploaderId = this.dis.reg('closeDocUploader',this.onCloseDocUploader)

    this.onInputReset = (function(){
      this.lastUnsavedDoc = this.unsavedDoc
    }).bind(this)
    this.dis.reg('uploaderHasBeenReset',this.onInputReset)

    /**
      Only stores a reference to the
      unsaved doc if a previous doc has
      already been uploaded.
    */
    this.onDocUpload = (function(file){
      try{
        var grp = this.currentGrp
        this.lastUnsavedDoc = this.unsavedDoc
        this.unsavedDoc = new UnsavedDoc(file, grp);
        if(!this.lastUnsavedDoc)
          this.lastUnsavedDoc = this.unsavedDoc
        this.pub()
      }
      catch(err){
        console.log(err)
        alert(err.message)
      }
    }).bind(this)
    this.docUploadId = this.dis.reg('docUpload',this.onDocUpload)



    this.inputsShouldBeReset = (function(){
      return this.unsavedDoc != this.lastUnsavedDoc
    }).bind(this)



    this.onSetDocTitle = (function(title){
      if(this.unsavedDoc && this.unsavedDoc.setTitle){
        this.unsavedDoc.setTitle(title)
      }
      this.pub()
    }).bind(this)
    this.setTitleId = this.dis.reg('setDocTitle',this.onSetDocTitle)


    this.onSetDocYear = (function(year){
      this.unsavedDoc.setYear(year)
      this.pub()
    }).bind(this)
    this.setYearId = this.dis.reg('setDocYear',this.onSetDocYear)

    this.isReadyToSubmit = function(){
      return this.unsavedDoc && this.unsavedDoc.isSendable()
    }

    this.onSubmitDoc = (function(doc){
      this.waiting = true
      this.pub()
    }).bind(this)
    this.submitDocId = this.dis.reg('submitDoc',this.onSubmitDoc)


    this.onDocSubmitted = (function(){
      this.unsavedDoc = null
      this.waiting = false
      this.showSuccess()
      this.dis.dispatch('getDocs',this.currentGrp)
      this.pub()
    }).bind(this)
    this.onSubmitedId = this.dis.reg('docSubmitted',this.onDocSubmitted)

    this.isSuccessPopupVisible = function(){
      return this.isSuccessVisible
    }

    this.showSuccess = (function(){
      var self = this
      setTimeout(function(){
        self.isSuccessVisible = false
        self.pub()
      },2000)
      this.isSuccessVisible = true
    }).bind(this)

    this.getCurrentDocs = function(){
      return this.docs
    }


    this.onOpenDoc = (function(doc){
      window.open(doc.getFileURL(), '_blank', 'location=yes');
    }).bind(this)
    this.dis.reg('openDoc',this.onOpenDoc)


    this.onMatchingProfs = (function(profs){
      this.matchingProfs = profs
      this.pub()
    }).bind(this)
    this.matchingProfsId = this.dis.reg('matchingProfs',this.onMatchingProfs)


    this.onSelectedProf = (function(p){
      this.unsavedDoc.setProfId(p.getId())
      this.matchingProfs = []
      this.pub()
    }).bind(this)
    this.selectedProfId = this.dis.reg('selectedProf',this.onSelectedProf)

}

return {
  getInstance:function(){
    if(!instance){
      instance = new DocStore()
    }
    return instance;
  },
  getNew:function(){
    return new DocStore();
  }
};
})
;

define('text!course-docs/container/template.html',[],function () { return '<link rel="stylesheet"\n      href="./styles/components/course-docs/course-docs.css?v=1.0">\n\n  <div id=\'join-to-access-prompt\'\n       data-bind="visible:isJoinPromptVisible()">\n       Join to access shared notes  <span class=\'glyphicon glyphicon-arrow-right\'></span>\n    \n   </div>\n  <div id="course-docs-container"\n       data-bind="visible:isVisible()">\n\n      <div id="no-practise-test-message"\n           data-bind="visible:isEmpty()">\n        There are no documents </br>\n        for this class yet.\n      </div>\n\n      <doc-list-current></doc-list-current>\n      <button id="doc-upload-button"\n              class=\'glyphicon glyphicon-plus\'\n              data-bind="visible:uploadingAllowed(), click:openUploader">\n      </button>\n  </div>\n';});

define('course-docs/container/Component',[
'dispatcher/Dispatcher',
'course-docs/DocStore',
'ko',
'text!course-docs/container/template.html',],
function(
  Dis,
  Store,
  ko,
  template){

  function View(params, componentInfo){
    this.dis = new Dis()
    this.store = Store.getInstance()
    this.isVisible = ko.observable(false)
    this.isEmpty = ko.observable(false)
    this.uploadingAllowed = ko.observable(false)
    this.isJoinPromptVisible = ko.observable(false)

    this.onStore = function(){
      this.isJoinPromptVisible(!this.store.isCourseDocsPermitted() && this.store.isCourseDocsVisible())
      this.uploadingAllowed(this.store.isUploadingAllowed)
      this.isVisible(this.store.isCourseDocsPermitted() && this.store.isCourseDocsVisible())
      this.isEmpty(this.store.docCount() < 1);
    }
    this.onStore = this.onStore.bind(this)
    this.store.sub(this.onStore)


    this.openUploader = function(){
      this.dis.dispatch('openDocUploader')
      $('#doc-uploader-input').trigger('click');
    }

    this.selectCurrentDocs = function(){

      this.dis.dispatch('selectCurrentDocs')
    }

    this.selectPreviousDocs = function(){
      this.dis.dispatch('selectPreviousDocs')
    }


}

  return {
    viewModel: View,
    template: template
  }
});


define('text!course-docs/doc-list-current/template.html',[],function () { return '<link rel="stylesheet"\n      href="./styles/components/course-docs/better-doc-list.css">\n\n\n<div id=\'doc-list-holder\'>\n\n  <span id=\'ask-prof-popup\'\n        data-bind=\'visible:askProfMessageVisible(),complementClick:closeAskProf\'>\n    We are asking the professor for permission to share this content.\n  </span>\n  <div class=\'profs\'\n      data-bind="foreach:profs">\n\n    <div class=\'prof-title\'>\n      <img data-bind=\'attr:{src:getSmallPhotoURL()}\'></img>\n      <span class=\'prof-name\' data-bind="text:first + \' \' + last">First Last</span>\n\n    </div>\n\n    <span data-bind="foreach:getYears()">\n\n      <span class=\'profs-doc-list\' data-bind="foreach:docs">\n\n\n        <span class="doc-container" data-bind=\'click:$parents[2].openDoc\'>\n\n          <span class=\'term-title-text\' data-bind="text:year"></span>\n          <div class="locked-prof"\n               data-bind=\'visible:isLocked()\'>\n            <div class=\'locked-icon-holder\'>\n              <i class="glyphicon glyphicon-lock doc-unlock-icon"></i>\n              <!-- <span class=\'unlock-text\'>unlock</span> -->\n            </div>\n          </div>\n\n          <span class=\'doc-preview\'>\n\n            <span class=\'doc-shade\'>\n            </span>\n            <img class=\'doc-img\'\n                 src=\'./assets/practice_test.jpg\'>\n            </img>\n          </span>\n          <span class=\'doc-footer\'>\n\n            <div class=\'title ellipsis\' data-bind=\'text:title\'>No Title</div>\n            <div class=\'last-opened\'>\n              <i class=\'glyphicon glyphicon-align-left doc-icon\'></i>\n              Opened\n              <span data-bind=\'text:" " + getLastOpened()\'>Never opened</span>\n            </div>\n\n          </span>\n          <span class=\'author-approval-status\'\n                data-toggle="tooltip" title="Pending professor\'s permission">\n                pending\n          </span>\n        </span>\n      </span>\n    </span>\n\n  </div>\n</div>\n';});

define('doc-list-current/Component',['text!course-docs/doc-list-current/template.html',
        'course-docs/DocStore',
        'course-docs/models/SavedDoc',
        'ko',
        'dispatcher/Dispatcher'],
function(template,
         Store,
         SavedDoc,
         ko,
         Dis){
  function View(){
    this.dis = new Dis()
    this.store = Store.getInstance()
    this.isVisible = ko.observable(true)
    this.profs = ko.observableArray([])
    this.askProfMessageVisible = ko.observable(false)

    this.onStore = (function(){
      var profs = this.store.getCurrentDocs().getProfs()
      this.profs(profs)
    }).bind(this)
    this.store.sub(this.onStore)

    this.closeAskProf = (function(){
      this.askProfMessageVisible(false)
    }).bind(this)

    this.openDoc = (function(d){
      if(d.isLocked()){
        // this.dis.dispatch('openDocumentPlans')
        this.askProfMessageVisible(true)
      }
      else{
        this.dis.dispatch('openDoc',d)
      }
    }).bind(this)
  }

  return {
    viewModel: View,
    template: template
  }

})
;

define('text!document-plans/template.html',[],function () { return '<link rel="stylesheet" href="./styles/components/payment/document-plans.css?v=1.1">\n\n<div id="document-plans"\n     data-bind="visible:isVisible()">\n\n  <div id=\'document-plans-holder\'>\n       <div class=\'x-close-holder\'>\n         <span class=\'x-close-button\' data-bind=\'click:closePaymentOptions\'>x</span>\n       </div>\n    <div id="plan-title">Choose your plan:</div>\n    <span class=\'payment-option\'>\n      <div class=\'plan-duration\'>12 Months</div>\n      <span class=\'ok-plan glyphicon glyphicon-ok\'></span>\n      <span id=\'best-value\'>BEST VALUE</span>\n      <div class=\'plan-price\'>$9.95 <sup>/mo</sup></div>\n      <div class=\'plan-details\'>12 months of <b class=\'bold\'>unlimited downloads</b></div>\n      <div class=\'plan-details\'>Billed $119.40 for a year.</div>\n\n      <button class=\'plan-button best-value-color\'\n              data-bind=\'click:selectValuePlan\'>Choose 12 Months</button>\n      <div class=\'plan-details\'>Save $360 over the monthly plan</div>\n    </span>\n\n    <span class=\'payment-option\'>\n      <div class=\'plan-duration\'>3 Months</div>\n      <span class=\'ok-plan glyphicon glyphicon-ok\'></span>\n      <div class=\'plan-price\'>$24.95 <sup>/mo</sup></div>\n      <div class=\'plan-details\'>3 months of <b class=\'bold\'>unlimited downloads</b></div>\n      <div class=\'plan-details\'>Billed $74.85 for 3 months</div>\n\n      <button class=\'plan-button\'\n              data-bind="click:selectMediumPlan">\n              Choose 3 Months\n      </button>\n      <div class=\'plan-details\'>Save $40 over the monthly plan</div>\n    </span>\n\n    <span class=\'payment-option\'>\n      <div class=\'plan-duration\'>1 Month</div>\n      <span class=\'ok-plan glyphicon glyphicon-ok\'></span>\n      <div class=\'plan-price\'>$39.95 <sup>/mo</sup></div>\n      <div class=\'plan-details\'>1 month of <b class=\'bold\'>unlimited downloads</b></div>\n      <div class=\'plan-details\'>Billed $39.95 for a month</div>\n      <button class=\'plan-button\'\n              data-bind=\'click:selectExpensivePlan\'>\n              Choose 1 Month\n      </button>\n    </span>\n\n  </div>\n\n</div>\n';});

define('payment/models/TutoringPlan',['abstract-interfaces/ValidObject'],
function(ValidObject){

    var TutoringPlan = function(raw){

      Object.setPrototypeOf(this, new ValidObject())

      this.getId = function(){
        return this.id
      }

      this.setId = function(id){
        this.validateId(id)
        this.id = id
      }
      this.setId(raw.plan_id)

      this.getHours = function(){
        return this.hours
      }

      this.setHours = function(hours){
        this.validateId(hours)
        this.hours = hours
      }
      this.setHours(raw.hours)


      this.setHourlyRate = function(rate){
        if(!rate || Number(rate) <= 0) throw new Error('hourly_rate must be positive.')
        this.hourlyRate = rate / 100.
      }
      this.setHourlyRate(raw.hourly_rate)

      this.getHourlyRate = function(){
        return this.hourlyRate
      }

      this.getDiscountedHours = function(){
        return this.discountedHours
      }

      this.setDiscountedHours = function(hours){
        if(typeof hours != 'number' || Number(hours) < 0) throw new Error('discounted_hours must be a non-negative integer.')
        this.discountedHours = hours
      }
      this.setDiscountedHours(raw.discounted_hours)


      this.setDuration = function(duration){
        if(duration < 1) throw new Error('duration must be at least 1 day.')
        this.duration = duration
      }
      this.setDuration(raw.duration_days)

      this.getDuration = function(){
        return this.duration
      }

      this.getDescription = function(){
        return this.description
      }

      this.setDescription = function(description){
        this.validateStr(description)
        this.description = description
      }
      this.setDescription(raw.description)




    } // end constructor


    TutoringPlan.getRaw = function(user_id){
      return {
        plan_id:43,
        description:'Live online tutoring',
        hours:1,
        hourly_rate:3995,
        discounted_hours:2,
        duration_days:31
      }
    }

    TutoringPlan.getFake = function(){
      return new TutoringPlan(TutoringPlan.getRaw())
    }

    return TutoringPlan;
});

define('payment/PaymentRemoteService',['ActiveRemoteService',
        'dispatcher/Dispatcher',
        'payment/models/TutoringPlan'],
function(ActiveRemoteService,
        Dispatcher,
        TutoringPlan){


var PaymentRemote = function(){

    this.constructor = PaymentRemote;
    Object.setPrototypeOf(this,new ActiveRemoteService());
    this.setMicroServer("payments");
    this.dis = new Dispatcher()

    this.onSelectDocumentPlan = (function(data){
      var url = this.getServerURL() + '/selectDocumentPlan';

      $.ajax({
        url:url,
        type:'post',
        data:data,
        beforeSend:this.setAuthorizationHeader,
        success:this.onDocumentPlanSelected,
        error:this.onError
      })
    }).bind(this)
    this.selDocPlanId = this.dis.reg('selectDocumentPlan',this.onSelectDocumentPlan)


    this.onDocumentPlanSelected = (function(){
      this.dis.dispatch('documentPlanSelected')
    }).bind(this)


    this.onAuth = (function(auth){
      if(auth.state = 'authenticated'){
        this.getTutoringPlans()
        this.dis.dispatch('paymentEnvironment',this.isLive())
      }
    }).bind(this)
    this.dis.reg('authState',this.onAuth)


    this.getTutoringPlans = (function(){
        var url = this.getServerURL() + '/tutoringPlans'
        $.ajax({
          url:url,
          type:'get',
          beforeSend:this.setAuthorizationHeader,
          success:this.onTutoringPlans,
          error:this.onError
        })
    }).bind(this)

    this.onBuyHours = (function(data){
      var url = this.getServerURL() + '/buyHours';
      $.ajax({
        url:url,
        type:'post',
        data:data,
        beforeSend:this.setAuthorizationHeader,
        success:this.onHoursSelected,
        error:this.onError
      })
    }).bind(this)
    this.dis.reg('buyHours',this.onBuyHours)

    this.onHoursSelected = (function(clientSecret){
      this.dis.dispatch('hoursSelected',clientSecret)
    }).bind(this)

    this.onSelectTutoringPlan = (function(plan){
      var url = this.getServerURL() + '/selectTutoringPlan';

      $.ajax({
        url:url,
        type:'post',
        data:plan,
        beforeSend:this.setAuthorizationHeader,
        success:this.onPlanSelected,
        error:this.onError
      })
    }).bind(this)
    this.dis.reg('selectTutoringPlan',this.onSelectTutoringPlan)


    this.onTutoringPlans = (function(rawPlans){
      var wrapped = []
      rawPlans.forEach(function(p){
        wrapped.push(new TutoringPlan(p))
      })
      this.dis.dispatch('tutoringPlans', wrapped)
    }).bind(this)


    this.onPlanSelected = (function(clientSecret){
      this.dis.dispatch('planSelected',clientSecret)
    }).bind(this)


    this.onError = (function(res){
      console.log(res)
      var adminContact = '\n-- Contact Chris at 905-808-8791 for assistance. ---'
      if(res.responseJSON){
        var qbResponse = res.responseJSON.errors[0].moreInfo
        alert(qbResponse + adminContact)
      }else{
        var qbResponse = res.responseText
        alert(qbResponse + adminContact)
      }
    }).bind(this)


}

return PaymentRemote;
})
;
define('payment/PaymentStore',['abstract-interfaces/Store',
        'dispatcher/Dispatcher',
        'payment/PaymentRemoteService'],
function(AbstractStore,
         Dispatcher,
        PaymentRemoteService){

  var instance = null;
  new PaymentRemoteService()

var PaymentStore = function(){
  Object.setPrototypeOf(this,new AbstractStore())
  this.dis = new Dispatcher()
  this.selectedPlan = null
  this.tutorPlansOpen = false
  this.isCreditCardInfoOpen = false
  this.isWaiting = false
  this.showPaymentSuccess = false
  this.isProcessingPayment = false
  this.clientSecret
  this.productDescription = ''
  this.selectedTutor = null
  this.documentPlansOpen = false
  this.orderInfo = null
  this.tutoringPlans = []


  this.getTutoringPlans = function(){
    var normalPlan = null
    var packagedPlans = []
    this.tutoringPlans.forEach(function(p){
      if(p.getHours() == 1){
        normalPlan = p
      } else {
        packagedPlans.push(p)
      }
    })
    return {
      normalPlan:normalPlan,
      packagedPlans:packagedPlans
    }
  }

  this.onTutoringPlans = (function(plans){
    this.tutoringPlans = plans
  }).bind(this)
  this.dis.reg('tutoringPlans',this.onTutoringPlans)


  this.onSelectDocumentPlan =(function(plan){
    if(!plan) throw new Error('invalid document plan')
    this.isWaiting = true
    this.pub()
  }).bind(this)

  this.onOpenDocumentPlans = (function(){
    this.documentPlansOpen = true
    this.pub()
  }).bind(this)
  this.openDocPlansId = this.dis.reg('openDocumentPlans',this.onOpenDocumentPlans)

  this.isDocumentPlansOpen = function(){
    return this.documentPlansOpen
  }

  this.onCloseDocumentPlans = (function(){
    this.documentPlansOpen = false
    this.pub()
  }).bind(this)
  this.dis.reg('closeDocumentPlans',this.onCloseDocumentPlans)

  this.getClientSecret = function(){
    return this.clientSecret
  }

  this.onHoursSelected = (function(clientSecret){
    console.log(clientSecret)
    this.orderInfo = clientSecret.order_info
    this.clientSecret = clientSecret.client_secret
    this.isCreditCardInfoOpen = true
    this.isWaiting = false
    this.tutorPlansOpen = false
    this.pub()
  }).bind(this)
  this.hourseSelectedId = this.dis.reg('hoursSelected',this.onHoursSelected)


  this.getOrderInfo = function(){
    return this.orderInfo
  }


  this.onBuyHours = (function(hours){
    if(!hours) throw new Error('invalid hours')
    this.isWaiting = true
    this.pub()
  }).bind(this)
  this.dis.reg('buyHours', this.onBuyHours)

  this.getHoursToBuy = function(){
    return this.hoursToBuy
  }

  this.isWaitingForServer = function(){
    return this.isWaiting
  }


  this.getProductDescription = (function(){
    return this.productDescription
  }).bind(this)

  this.getSelectedTutorId = function(){
    if(this.selectedTutor){
      return this.selectedTutor.getId()
    } else{
      return null
    }

  }

  this.onOpenTutoringPlans = (function(tutor){
    if(this.tutoringPlans.length > 0){
      this.tutorPlansOpen = true
      this.selectedTutor = tutor
      this.pub()
    } else {
      window.alert('No tutoring service available at this time.')
    }
  }).bind(this)
  this.dis.reg('openTutoringPlans',this.onOpenTutoringPlans)

  this.isTutoringPlansOpen = function(){
    return this.tutorPlansOpen
  }

  this.onCloseTutorPlans = (function(){
    this.tutorPlansOpen = false
    this.pub()
  }).bind(this)
  this.dis.reg('closeTutoringPlans',this.onCloseTutorPlans)

  /**
     When a plan is selected the payment options
    should close and the credit card info
    should open.
  */
  this.onSelectTutoringPlan = (function(plan){
    if(!plan) throw new Error('invalid option')
    this.selectedPlan = plan
    this.isWaiting = true
    this.tutorPlansOpen = false
    this.pub()
  }).bind(this)
  this.dis.reg('selectTutoringPlan',this.onSelectTutoringPlan)

  this.onPlanSelected = (function(response){
    this.clientSecret = response.client_secret
    this.orderInfo = response.order_info
    this.isCreditCardInfoOpen = true
    this.isWaiting = false
    this.pub()
  }).bind(this)
  this.planSelectedId = this.dis.reg('planSelected',this.onPlanSelected)


  this.closeCreditCardInfo = (function(){
    this.isCreditCardInfoOpen = false
    this.showPaymentSuccess = false
    this.pub()
  }).bind(this)
  this.dis.reg('closeCreditCardInfo',this.closeCreditCardInfo)

  this.onConfirmingPayment = (function(){
    this.isProcessingPayment = true
    this.pub()
  }).bind(this)
  this.confirmingPaymentId = this.dis.reg('confirmingPayment',this.onConfirmingPayment)

  this.onPaymentProcessed = (function(success){
    this.isProcessingPayment = false
    this.showPaymentSuccess = success
    this.pub()
  }).bind(this)
  this.paymentProcessedId = this.dis.reg('paymentProcessed',this.onPaymentProcessed)



}

return {
  getInstance:function(){
    if(!instance){
      instance = new PaymentStore()
    }
    return instance;
  },
  getNew:function(){
    return new PaymentStore();
  }
};
})
;
define('document-plans/Component',['ko',
        'text!document-plans/template.html',
        'dispatcher/Dispatcher',
        'payment/PaymentStore'],
function(ko, template, Dis, Store){
  function ViewModel(){

    this.dis = new Dis()
    this.store = Store.getInstance()
    this.isVisible = ko.observable(false)


    this.onStore = (function(){
      this.isVisible(this.store.isDocumentPlansOpen())
    }).bind(this)
    this.store.sub(this.onStore)

    this.selectValuePlan = function(){
      this.dis.dispatch('selectDocumentPlan',{plan:5})
    }

    this.selectMediumPlan = function(){
      this.dis.dispatch('selectDocumentPlan',{plan:6})
    }

    this.selectExpensivePlan = function(){
      this.dis.dispatch('selectDocumentPlan',{plan:7})
    }

    this.closePaymentOptions = (function(){
      this.dis.dispatch('closeDocumentPlans')
    }).bind(this)


}; // end view model.

  return {
    viewModel: ViewModel,
    template: template
  }
});


define('text!tutoring-plans/template.html',[],function () { return '<link rel="stylesheet" href="./styles/components/payment/tutoring-plans.css?v=1.3">\n\n\n<div id="tutoring-plans"\n     class=\'background-dimmer\'\n     data-bind="visible:isVisible()">\n\n     <div class="middelize"\n          data-bind=visible:showSpinner()>\n         <div class="big-loader"></div>\n     </div>\n\n  <div id=\'tutoring-plans-holder\'>\n       <div class=\'x-close-holder\'>\n         <span class=\'x-close-button\' data-bind=\'click:closePaymentOptions\'>x</span>\n       </div>\n       <div id=\'non-package-pricing\'>\n         <div id=\'hours-query\'>How many hours would you like?</div>\n         <div class=\'non-package-row\'>\n           <input id=\'hour-selector\'\n                  type=\'number\'\n                  min=\'1\'\n                  max=\'9\'\n                  required\n                  value="1"\n                  data-bind=\'value:hours\'>\n            </input>\n           <span class=\'non-package-hours\'> Hours @ </span>\n          <span class=\'plan-price\'>\n            $<span data-bind=\'text:hourlyRate\'></span> <sup>/hr</sup>\n          </span>\n         </div>\n\n         <div id=\'total-price-holder\'\n              class=\'non-package-row\'>\n           Total: <span id=non-package-total>$<span data-bind=\'text:total\'></span></span>\n           <button id=\'buy-button\' data-bind=\'click:buy\'>Buy</button>\n         </div>\n\n       </div>\n\n       <ul id=\'tutoring-packages\' data-bind=\'foreach:plans()\'>\n\n         <span class=\'payment-option\'>\n           <div class=\'plan-duration\' data-bind=\'text:getDescription()\'></div>\n           <span class=\'ok-plan glyphicon glyphicon-ok\'></span>\n           <div class=\'plan-price\'>\n              <span data-bind=\'text:getHourlyRate()\'> $39.95 </span>\n              <sup>/hr</sup>\n           </div>\n           <div class=\'plan-details\'>\n             <span data-bind=\'text:getDiscountedHours()\'>1</span> of the hours is <span class=\'green\'>FREE</span>.\n           </div>\n           <div class=\'plan-details\'>\n             <span data-bind=\'text:getHours()\'> </span> hours of tutoring\n           </div>\n           <div class=\'plan-details\'>You save\n              <span data-bind=\'text:($parent.hourlyRate() * getHours() - (getHourlyRate() * (getHours() - getDiscountedHours()))).toFixed(2)\'>  </span>\n           </div>\n           <button class=\'plan-button\'\n                   data-bind=\'click:$parent.choosePackage\'>\n                   Choose <span data-bind=\'text:getHours()\'></span> Hours\n           </button>\n         </span>\n\n       </ul>\n\n       <div id=\'tutoring-doc-details\'>\n          Payment for online tutoring must be made\n          before tutoring sessions start.\n         </div>\n       <div id=\'tutoring-doc-details\'>\n          Hours bought must be used within 6-months\n          from the date of purchase.\n         </div>\n  </div>\n\n</div>\n';});

define('tutoring-plans/Component',['ko',
        'text!tutoring-plans/template.html',
        'dispatcher/Dispatcher',
        'payment/PaymentStore'],
function(ko, template, Dis, Store){
  function ViewModel(){

    this.dis = new Dis()
    this.store = Store.getInstance()
    this.isVisible = ko.observable(false)
    this.showSpinner = ko.observable(false)

    this.hourlyRate = ko.observable(0)
    this.hours = ko.observable(1)
    this.total = ko.computed(function(){
      return (this.hourlyRate() * this.hours()).toFixed(2);
    },this)
    this.plans = ko.observableArray([])


    this.onHoursChanged = function(value){
      if (value == '' || value < 1) this.hours(1)
      if (value > 5) this.hours(5)
    }
    this.hours.subscribe(this.onHoursChanged,this)

    this.onStore = (function(){
      var isOpen = this.store.isTutoringPlansOpen()
      this.isVisible(isOpen)
      this.showSpinner(this.store.isWaitingForServer())
      if(isOpen){
        var plans = this.store.getTutoringPlans()
        var packagedPlans = plans.packagedPlans
        var normalPlan = plans.normalPlan
        this.plans(packagedPlans)
        this.hourlyRate(normalPlan.getHourlyRate())
      }
    }).bind(this)
    this.store.sub(this.onStore)


    this.closePaymentOptions = function(){
      this.dis.dispatch('closeTutoringPlans')
    }

    this.buy = (function(){
      var id = this.store.getSelectedTutorId()
      var hours = Number(this.hours())
      if(!hours || typeof hours != 'number' || hours < 1) throw new Error('hours must be a non-negative integer.')
      this.dis.dispatch('buyHours',{tutor:id,hours:hours})
    }).bind(this)

    this.choosePackage = (function(plan){
      var id = this.store.getSelectedTutorId()
      var planId = plan.getId()
      this.dis.dispatch('selectTutoringPlan',{plan:planId, tutor:id})
    }).bind(this)




}; // end view model.

  return {
    viewModel: ViewModel,
    template: template
  }
});


define('text!credit-card-info/template.html',[],function () { return '<link rel="stylesheet" href="./styles/components/payment/credit-card-info.css?v=1.3">\n\n<div id=\'credit-card-info\' class=\'background-dimmer\' data-bind=\'visible:isVisible()\'>\n\n  <div class="middelize"\n       data-bind=visible:isSpinnerVisible()>\n      <div class="big-loader"></div>\n  </div>\n\n\n\n  <form action="/charge" method="post" id="payment-form">\n    <span id=\'payment-title\'>\n      Palolo checkout\n      <i id=\'checkout-lock\' class=\'glyphicon glyphicon-lock\'></i>\n    </span>\n    <span class=\'x-close-button\' data-bind=\'click:close\'>x</span>\n\n    <div class="form-row">\n      <div id=\'payment-method\' class=\'payment-col\'>\n\n              <label id=\'card-label\' class=\'payment-col-title\' for="card-element">\n                CREDIT CARD OR DEBIT CARD\n              </label>\n              <div id="cardholder-name">\n                <input id=\'cardholder-name-input\'\n                       type=\'text\'\n                       placeholder="Cardholder name"\n                       data-bind=\'textInput:cardholderName, css:{"invalid-name":!isNameValid()}\'>\n                </input>\n              </div>\n              <div id="card-element">\n                <!-- A Stripe Element will be inserted here. -->\n              </div>\n              <!-- Used to display form errors. -->\n              <div id="card-errors" role="alert"></div>\n\n              <button class=\'payment-button\' data-bind="attr:{disabled:isPaymentComplete() || isProcessingPayment()}">\n                <div class="small-spinner hidden-element" id="spinner"\n                      data-bind=\'visible:isProcessingPayment()\'></div>\n                <span id="button-text" class=""\n                      data-bind="visible:!isProcessingPayment() && !isPaymentComplete()">Pay Now</span>\n                <span id="button-text" class=""\n                      data-bind="visible:isPaymentComplete()">\n                      <span>Payment Successful</span>\n                      <span class=\'glyphicon glyphicon-ok credit-card-payment-success\'>\n                      </span>\n                </span>\n              </button>\n\n              <div id=\'payment-success-info\'\n                   data-bind=\'css:{"slide-down":isPaymentComplete()}\'>\n                <div> Purchase Successful </div>\n                <div css=\'grey\'>A confirmation email will be sent.</div>\n              </div>\n      </div>\n\n      <div id=\'order-summary\' class=\'payment-col\'>\n        <div class=\'order-part\'>\n          <div class=\'order-summary-title\'>ORDER SUMMARY</div>\n          <div class=\'order-summary-row\'>\n              <span data-bind=\'text:productQuantity()\'></span> unit(s)\n              <span class=\'order-cost\' data-bind=\'text:productPrice()\'> </span>\n          </div>\n          <div id=\'order-tax-title\'>\n            Taxes\n          </div>\n          <div class=\'order-summary-row\'>\n            HST(13%) <span class=\'order-cost\' data-bind=\'text:salesTax()\'> $0.00 </span>\n          </div>\n          <div class=\'order-summary-row\'>\n            Order Total <span class=\'order-cost\' data-bind=\'text:orderTotal()\'>  </span>\n          </div>\n        </div>\n\n        <div id=\'bottom-order-part\'>\n          <div class=\'order-summary-title\'>SERVICES IN YOUR ORDER</div>\n          <div class=\'product-name-row\'>\n            <span data-bind=\'text:productDescription()\'></span>\n          </div>\n          <div class=\'order-summary-row\'>\n            <span data-bind=\'text:productQuantity()\'></span> X\n            <span data-bind=\'text:productPrice()\'></span>\n          </div>\n        </div>\n\n\n\n      </div>\n      <div style="text-align:left; margin:5pt;">\n        <img src=\'./assets/powered_by_stripe.svg\'></img>\n        <span>256-bit secure encryption</span>\n      </div>\n    </div>\n\n\n\n  </form>\n\n\n</div>\n';});

define('credit-card-info/Component',['ko',
        'text!credit-card-info/template.html',
        'dispatcher/Dispatcher',
        'payment/PaymentStore',
        'stripe'], // ensure Stripe is available first.
function(ko, template, Dis, Store){
  function ViewModel(){


    this.dis = new Dis()
    this.store = Store.getInstance()
    this.isVisible = ko.observable(false)
    this.isSpinnerVisible = ko.observable(false)

    this.cardholderName = ko.observable('')
    this.isNameValid = ko.observable(false)
    this.orderTotal = ko.observable(0)
    this.productDescription = ko.observable('')
    this.productQuantity = ko.observable(0)
    this.productPrice = ko.observable('')
    this.salesTax = ko.observable('')

    this.isProcessingPayment = ko.observable(false)
    this.isPaymentComplete = ko.observable(false)


    this.onStore = (function(){
      var show = this.store.isCreditCardInfoOpen
      if((!show || this.store.showPaymentSuccess) && this.stripe){
        this.card.clear()
        this.cardholderName('')
      }
      this.isVisible(this.store.isCreditCardInfoOpen)
      this.isSpinnerVisible(this.store.isWaiting)
      this.isProcessingPayment(this.store.isProcessingPayment)
      this.isPaymentComplete(this.store.showPaymentSuccess)
      this.setOrderInfo()
    }).bind(this)
    this.store.sub(this.onStore)


    this.setOrderInfo = function(){
      var order = this.store.getOrderInfo()
      if(order){
        this.productDescription(order.product_description)
        this.productPrice('$' + Number(order.product_price).toFixed(2))
        this.productQuantity(order.product_qty)
        this.salesTax('$' + Number(order.product_qty * order.product_price * order.sales_tax_rate).toFixed(2))
        this.orderTotal('$' + Number(order.product_qty * order.product_price * (1 + order.sales_tax_rate)).toFixed(2))
      }
    }


    this.onCardholderName = (function(name){
      var displayError = document.getElementById('card-errors');
      if(/^[A-Za-z]{1,}\s+[A-Za-z]{1,}$/.test(name)){
        this.isNameValid(true)
          displayError.textContent = '';
      } else {
        this.isNameValid(false)
          displayError.textContent = 'Cardholder name invalid.';
      }
    }).bind(this)
    this.cardholderName.subscribe(this.onCardholderName)





    this.close = (function(){
      this.dis.dispatch('closeCreditCardInfo')
    }).bind(this)


    // Custom styling can be passed to options when creating an Element.
    // (Note that this demo uses a wider set of styles than the guide below.)
    var style = {
      base: {
        color: '#32325d',
        fontFamily: '"Helvetica Neue", Helvetica, sans-serif',
        fontSmoothing: 'antialiased',
        fontSize: '18px',
        '::placeholder': {
          color: '#aab7c4'
        }
      },
      invalid: {
        color: '#fa755a',
        iconColor: '#fa755a'
      }
    };

    this.livePublicKey = 'pk_live_fJ6an24u7T7ziXp4oD4tLGFM00N9TudeYY'
    this.testPublicKey = 'pk_test_AkTJD4FnhRQeB9G9wfCifOzH00PPHxrLAN'

    // from https://stripe.com/docs/stripe-js#html-js
    this.setupCard = (function(isLive){
        // Create a Stripe client.
        if(isLive){
          this.stripe = Stripe(this.livePublicKey);
          //console.log('stripe - live mode.')
        }
        else{
          this.stripe = Stripe(this.testPublicKey);
          //console.log('stripe - dev mode.')
        }
        // Create an instance of Elements.
        var elements = this.stripe.elements();
        // Create an instance of the card Element.
        this.card = elements.create('card', {style: style});
        // Add an instance of the card Element into the `card-element` <div>.
        this.card.mount('#card-element');
        this.card.addEventListener('change', function(event) {
          var displayError = document.getElementById('card-errors');
          if (event.error) {
            displayError.textContent = event.error.message;
          } else {
            displayError.textContent = '';
          }
        });
    }).bind(this)
    this.dis.reg('paymentEnvironment',this.setupCard)

    // Handle form submission.
    this.confirmPayment = (function(ev) {
        ev.preventDefault();
        if(!this.stripe) throw new Error('expected stripe to be initialized.')
        var clientSecret = this.store.clientSecret
        if(!clientSecret)
          throw new Error('clientSecret has not been set')
        var paymentMethod
        if(this.cardholderName().length > 0){
          paymentMethod = {
            payment_method: {
              card: this.card, // automatically includes postal code.
              billing_details: {
                name: this.cardholderName(),
              }
            }
          }
        } else {
          paymentMethod = {
            payment_method: {
              card: this.card, // automatically includes postal code.
            }
          }
        }
        this.stripe.confirmCardPayment(clientSecret, paymentMethod)
                  .then(this.onConfirmPaymentComplete);
        this.dis.dispatch('confirmingPayment')
      }).bind(this)

      var form = document.getElementById('payment-form');
      form.addEventListener('submit', this.confirmPayment);



      this.onConfirmPaymentComplete = (function(result) {
        if (result.error) {
          // Show error to your customer (e.g., insufficient funds)
          var errorElement = document.getElementById('card-errors');
          errorElement.textContent = result.error.message;
          console.log(result.error.message);
          this.dis.dispatch('paymentProcessed',false)
        } else {
          // The payment has been processed!
          if (result.paymentIntent.status === 'succeeded') {
            this.dis.dispatch('paymentProcessed',true)
            // Show a success message to your customer
            // There's a risk of the customer closing the window before callback
            // execution. Set up a webhook or plugin to listen for the
            // payment_intent.succeeded event that handles any business critical
            // post-payment actions.
          }
          else{
            console.log('failure')
            this.dis.dispatch('paymentProcessed',false)
          }
        }
      }).bind(this)


};

  return {
    viewModel: ViewModel,
    template: template
  }
});


define('text!session-tracker/template.html',[],function () { return '<link rel="stylesheet" href="./styles/components/session-tracker/style.css?v=1.1">\n\n  <div id=\'session-tracker\'\n       data-bind=\'visible:isVisible()\'>\n\n      <account-info></account-info>\n      <div class=\'session-tracker-spacer\'></div>\n      <punch-clock></punch-clock>\n\n   <span id=\'close-session-tracker-button\'\n         class=\'glyphicon glyphicon-chevron-left\'\n         data-bind=\'click:close\'>\n    </span>\n\n</div>\n';});

/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
define('session-tracker/AccountState',['abstract-interfaces/ValidObject'],
function(ValidObject){

  var AccountState = function(data){

    Object.setPrototypeOf(this,new ValidObject())

    this.setTimeRemaining = function(remaining){
      if(typeof remaining != 'number' || remaining < 0)
        throw new Error('remaining time must be a non-negative number.')
      this.remaining = remaining
    }
    this.setTimeRemaining(data.remaining)


    this.getTimeRemaining = function(){
      return this.remaining
    }


    this.setTimeFulfilled = function(time){
      if(typeof time != 'number' || time < 0)
        throw new Error('remaining time must be a non-negative number.')
        this.fulfilled = time;
    }
    this.setTimeFulfilled(data.fulfilled)

    this.getTimeFulfilled = function(){
      return this.fulfilled
    }

    this.setCustomerId = function(id){
      this.validateId(id)
      this.customerId = id
    }
    this.setCustomerId(data.customer_id)

    this.getCustomerId = function(){
      return this.customerId
    }

  };

  AccountState.getRaw = function(){
    return {
      customer_id:1,
      remaining:2,
      fulfilled:3
    }
  }

  AccountState.getFake = function(){
    var raw = AccountState.getRaw()
    return new AccountState(raw)
  }
  return AccountState

});

define('session-tracker/SessionRemoteService',['ActiveRemoteService',
        'dispatcher/Dispatcher',
        'session-tracker/AccountState'],
function(ActiveRemoteService,
         Dispatcher,
         AccountState){

var SessionRemoteService = function(){

    Object.setPrototypeOf(this,new ActiveRemoteService());
    this.setMicroServer("payments");
    this.dis = new Dispatcher()


    this.getAccountInfo = (function(customerId){
      var url = this.getServerURL() + '/getAccountInfo?customer=' + customerId;
      $.ajax({
        url:url,
        type:'get',
        beforeSend:this.setAuthorizationHeader,
        success:this.onAccountInfoReceived,
        error:this.onError
      })
    }).bind(this)
    this.dis.reg('getAccountInfo',this.getAccountInfo)


    this.onSaveSession = (function(data){
      var url = this.getServerURL() + '/saveSessionTime';
      $.ajax({
        url:url,
        type:'post',
        data:data,
        beforeSend:this.setAuthorizationHeader,
        success:this.onAccountInfoReceived,
        error:this.onError
      })
    }).bind(this)
    this.dis.reg('saveSessionTime',this.onSaveSession)

    this.onAccountInfoReceived = (function(data){
      try{
        this.dis.dispatch('accountInfoReceived', new AccountState(data))
      }catch(err){
        this.dis.dispatch('sessionTrackerError',err.message)
      }
    }).bind(this)


    this.onError = (function(err){
      this.dis.dispatch('sessionTrackerError',err.responseText)
    }).bind(this)


}

return SessionRemoteService;
})
;
define('session-tracker/SessionStore',['dispatcher/Dispatcher',
        'abstract-interfaces/Store',
        'session-tracker/SessionRemoteService'],
function(Dispatcher,
         Store,
         RemoteService){

   new RemoteService()
   var instance = null;
   var SessionStore  = function(){

     Object.setPrototypeOf(this, new Store())
     this.dis = new Dispatcher()
     this.visible = false
     this.focusedPersonId = null
     this.savingSession = false
     this.errorMessage = null
     this.recordSavedShowing = false


     this.isRecordSavedShowing = (function(){
       return this.recordSavedShowing
     }).bind(this)


     this.onError = (function(m){
       this.savingSession = false
       this.errorMessage = m
       this.pub()
     }).bind(this)
     this.dis.reg('sessionTrackerError', this.onError)

     this.getErrorMessage = function(){
       return this.errorMessage
     }

     this.isRefreshingInfo = function(){
       return this.refreshing;
     }

     this.isVisible = function(){
       return this.visible
     }

     this.closeSessionTracker = (function(){
       this.visible = false
       this.pub()
     }).bind(this)
     this.dis.reg('closeSessionTracker',this.closeSessionTracker)


     this.openSessionTracker = (function(isTutor){
       if(typeof isTutor != 'boolean') throw new Error('isTutor must be boolean.')
       this.tutor = isTutor
       this.visible = true
       this.pub()
     }).bind(this)
     this.openerId = this.dis.reg('openSessionTracker',this.openSessionTracker)


     this.isTutor = function(){
       return this.tutor
     }

     this.getCustomersName = function(){
       return this.customersName
     }

     this.setFocusedPersonId = (function(person){
       this.focusedPersonId = person.getId()
       this.dis.dispatch('getAccountInfo',this.focusedPersonId)
     }).bind(this)
     this.dis.reg('focusPerson',this.setFocusedPersonId)

     this.getFocusedPersonId = function(){
       return this.focusedPersonId
     }

     this.onSaveSession = (function(){
       this.savingSession = true
       this.pub()
     }).bind(this)
     this.dis.reg('saveSessionTime', this.onSaveSession)

     this.isSavingSession = function(){
       return this.savingSession;
     }

     this.getTimeFulfilled = function(){
       return this.timeFulfilled
     }

     this.getTimeRemaining = function(){
       return this.timeRemaining
     }

     this.showRecordSavedMessage = function(){
       this.recordSavedShowing = true
       var self = this
       setTimeout(function(){
         self.recordSavedShowing = false
         self.pub()
       },2500)
     }

     this.onGetAcccountInfo = (function(){
       this.refreshing = true
       this.pub()
     }).bind(this)
     this.dis.reg('getAccountInfo', this.onGetAcccountInfo)

     this.onAccountInfoReceived = (function(data){
       this.timeRemaining = data.remaining
       this.timeFulfilled = data.fulfilled
       if(this.savingSession) this.showRecordSavedMessage()
       this.savingSession = false
       this.refreshing = false
       this.pub()
     }).bind(this)
     this.dis.reg('accountInfoReceived', this.onAccountInfoReceived)


  } // end

    return {
      getInstance:function(){
        if(!instance){
          instance = new SessionStore();
        }
        return instance;
      },
      getNew:function(){
        return new SessionStore();
      }
    }
  })
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
define('session-tracker/Component',['ko',
        'text!session-tracker/template.html',
        'dispatcher/Dispatcher',
        'session-tracker/SessionStore'],
function(ko,
         template,
         Dispatcher,
         Store){

  function View(){

    this.store = Store.getInstance()
    this.dis = new Dispatcher()
    this.isVisible = ko.observable(false)

    this.close = (function(){
      this.dis.dispatch('closeSessionTracker')
    }).bind(this)


    this.onStore = (function(){
      this.isVisible(this.store.isVisible())
      var m = this.store.getErrorMessage()
      if(m) alert(m)
    }).bind(this)
    this.store.sub(this.onStore)

  };

  return {
    viewModel: View,
    template : template
  }


});


define('text!punch-clock/template.html',[],function () { return '\n    <table id=\'punch-clock-table\' data-bind="visible:isVisible()">\n      <tbody>\n        <tr>\n          <th>SESSION DATE</th>\n        </tr>\n        <tr>\n          <td>\n            <input id=\'session-date\'\n                   type=\'date\'\n                   data-bind=\'value:sessionDate, attr:{max:maxDate()}\'>\n            </input>\n          </td>\n        </tr>\n        <tr>\n          <th>DURATION</th>\n        </tr>\n        <tr>\n          <td>\n            <input type=\'number\'\n                  step="0.5"\n                  min="1"\n                  data-bind="value:sessionDuration, attr:{max:maxDuration()}, disable:maxDuration() < 1">\n            </input> hrs\n          </td>\n        </tr>\n\n        <tr>\n          <td>\n            <button id=\'record-session-button\'\n                    class=\'purple-button\'\n                    data-bind=\'click:saveTime, disable:!isDateValid() && !showSessionRecordSaved() || maxDuration() < 1\'>\n                    <span data-bind=\'visible:!isSavingSession() && !showSessionRecordSaved()\'>\n                      Save\n                    </span>\n                    <i data-bind=\'visible:isSavingSession() && !showSessionRecordSaved()\'\n                       class=\'micro-spinner\'>\n                    </i>\n                    <span\n                          data-bind=\'visible:showSessionRecordSaved()\'>\n                      Record saved\n                      <i id=\'session-record-saved\'\n                         class=\'glyphicon glyphicon-ok green\'>\n                      </i>\n                    </span>\n            </button>\n          </td>\n        </tr>\n      </tbody>\n    </table>\n\n</div>\n';});

/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
define('punch-clock/Component',['ko',
        'text!punch-clock/template.html',
        'dispatcher/Dispatcher',
        'session-tracker/SessionStore'],
function(ko,
         template,
         Dispatcher,
         Store){

  function View(){

    this.store = Store.getInstance()
    this.dis = new Dispatcher()
    this.isVisible = ko.observable(false)
    this.showSessionRecordSaved = ko.observable(false)
    this.sessionDate = ko.observable('')
    this.sessionDuration = ko.observable('1')
    this.isSavingSession = ko.observable(false)
    this.isDateValid = ko.observable(false)
    this.maxDate = ko.observable('')
    this.maxDuration = ko.observable('')




    this.setMaxDuration = (function(remaining){
      if(remaining >= 10) this.maxDuration(9.5)
      else if(remaining >= 1.0) this.maxDuration(remaining)
      else if(remaining < 1) this.maxDuration(0)
    }).bind(this)



    this.getToday = function(){
      var today = new Date();
      var dd = String(today.getDate()).padStart(2, '0');
      var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!
      var yyyy = today.getFullYear();
      return yyyy + '-' +  mm + '-' + dd;
    }
    this.maxDate(this.getToday())

    var e = document.getElementById('session-tracker')
    if(e)
    e.addEventListener('mousedown', function(event){
      event.stopPropagation() // so that the drag event does not occur.
    })

    this.close = (function(){
      this.dis.dispatch('closeSessionTracker')
    }).bind(this)

    this.checkDate = (function(date){
      if(date.length > 0)
        this.isDateValid(true)
      else
        this.isDateValid(false)
    }).bind(this)
    this.sessionDate.subscribe(this.checkDate,this)

    this.onStore = (function(){
      this.showSessionRecordSaved(this.store.isRecordSavedShowing())
      this.isVisible(this.store.isTutor() && this.store.isVisible())
      this.isSavingSession(this.store.isSavingSession())
      this.setMaxDuration(this.store.getTimeRemaining())
      this.sessionDate('')
      if(this.store.getTimeRemaining() >= 1)
        this.sessionDuration(1)
      else
        this.sessionDuration(0)

    }).bind(this)
    this.store.sub(this.onStore)

    this.saveTime = (function(){
      if(this.isDateValid())
        this.dis.dispatch('saveSessionTime',{
          customerId:this.store.getFocusedPersonId(),
          date:this.sessionDate(),
          duration:this.sessionDuration(),
        })
    }).bind(this)





  };

  return {
    viewModel: View,
    template : template
  }


});


define('text!account-info/template.html',[],function () { return '  <div id=\'account-info\'>\n\n    <table id=\'session-table-top\'>\n        <tr>\n          <th>FULFILLED</th>\n        </tr>\n      <tr>\n        <td data-bind=\'text:timeFulfilled()\'>10</td>\n      </tr>\n      <tr>\n        <th>REMAINING</th>\n      </tr>\n      <tr>\n        <td data-bind=\'text:timeRemaining()\'>2</td>\n      </tr>\n      <tr>\n        <td colspan="2">\n          <button id=\'session-tracker-refresh-btn\' data-bind=\'click:refreshAccountInfo\'>\n            <span data-bind="visible:!isSpinnerVisible()">refresh</span>\n            <i data-bind=\'visible:isSpinnerVisible()\'\n               class=\'micro-spinner\'>\n            </i>\n          </button>\n        </td>\n      </tr>\n    </table>\n\n</div>\n';});

/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
define('account-info/Component',['ko',
        'text!account-info/template.html',
        'dispatcher/Dispatcher',
        'session-tracker/SessionStore'],
function(ko,
         template,
         Dispatcher,
         Store){

  function View(){

    this.store = Store.getInstance()
    this.dis = new Dispatcher()
    this.timeRemaining = ko.observable('0')
    this.timeFulfilled = ko.observable('0')
    this.isSpinnerVisible = ko.observable(false)


    this.refreshAccountInfo = (function(){
      var customerId = this.store.getFocusedPersonId()
      this.dis.dispatch('getAccountInfo',customerId)
    }).bind(this)

    this.onStore = (function(){
      this.isSpinnerVisible(this.store.isRefreshingInfo())
      this.timeRemaining(this.store.getTimeRemaining())
      this.timeFulfilled(this.store.getTimeFulfilled())
    }).bind(this)
    this.store.sub(this.onStore)

  };

  return {
    viewModel: View,
    template : template
  }


});


define('text!doc-uploader/template.html',[],function () { return '<link rel="stylesheet"\n      href="./styles/components/course-docs/doc-uploader.css?v=1.0">\n\n<div class=\'dark-background\' data-bind=\'visible:isVisible()\'>\n\n  <span id="upload-success-message"\n        data-bind="visible:showUploadSuccess()">\n        <div>Upload successful!</div>\n           <div>Great Job!</div>\n  </span>\n\n    <div id=\'doc-uploader\' >\n          <span id=\'uploader-course-reminder\' data-bind=\'text:courseDescription()\'></span>\n          <span class=\'x-close-button\' data-bind=\'click:close\'>x</span>\n          <div id=\'doc-input\'\n              data-bind="visible:unsavedDocLoaded()">\n            <span id=\'uploader-title\'>\n              <label id="doc-reupload-btn"\n                     class="glyphicon glyphicon-upload doc-upload-btn"\n                     for="doc-uploader-input">\n              </label>\n              <span>Upload another document</span>\n            </span>\n\n            <input contenteditable="true"\n                   class=\'unsaved-doc-attr\'\n                   data-bind="textInput:unsavedDocName">\n            </input>\n            <span id=\'matching-profs-holder\'>\n              <input contenteditable="true"\n                     class=\'unsaved-doc-attr\'\n                     placeholder="Professor"\n                     data-bind="textInput:profName">\n\n              </input>\n              <ul id=\'matching-profs\'\n                      data-bind="foreach:matchingProfs, visible:matchingProfs().length > 0">\n                <div class=\'matching-prof\'\n                      data-bind="text:getFirst() + \' \' + getLast(), click:$parent.selectProf">\n                </div>\n              </ul>\n            </span>\n\n            <select contenteditable="true"\n                   class=\'unsaved-doc-attr\'\n                   data-bind="options:years,\n                              value:selectedYear,\n                              valueAllowUnset: true">\n                   <option > </option>\n\n            </select>\n\n          </div>\n          <div>\n            <label id="doc-reupload-btn"\n                   data-bind="visible:!unsavedDocLoaded()"\n                   class="glyphicon glyphicon-upload doc-upload-btn"\n                   for="doc-uploader-input">\n            </label>\n            <input id=\'doc-uploader-input\'\n                   type=\'file\'\n                   accept="application/pdf"\n                   data-bind="event:{change:uploadDoc}">\n            </input>\n          </div>\n\n          <button id=\'doc-submit\'\n                  data-bind="enable:submittable(), click:submitDoc"\n                  disabled>\n                  Submit\n                  <span class=\'spinner\'></span>\n          </button>\n\n          <div id=\'doc-course-adder\' data-bind=\'visible:courseAdderVisible()\'>\n            <div>No record of that prof teaching that course</div>\n                <div>Would you like to add the record?</div>\n                <div>\n                   <button data-bind=\'click:addCourse\'\n                           class=\'doc-course-adder-button\'>Yes</button>\n                   <button data-bind="click:closeAdder"\n                           class=\'doc-course-adder-button\'>No</button>\n                </div>\n          </div>\n\n          <div id=\'doc-uploader-terms\'>\n            By uploading you are agreeing that the content does not violate copyright\n            and you agree to the\n            <a target="_blank"  href="https://www.legal.palolo.ca/terms_and_conditions">\n              Terms and Conditions\n            </a>\n          </div>\n\n    </div>\n</div>\n';});

define('doc-uploader/Component',['ko',
        'text!doc-uploader/template.html',
        'dispatcher/Dispatcher',
        'course-docs/DocStore',
        'people-models/Prof'],
function(ko, template, Dis, Store, Prof){
  function ViewModel(){

    this.dis = new Dis()
    this.store = Store.getInstance()
    this.isVisible = ko.observable(false)
    this.courseDescription = ko.observable('')
    this.unsavedDocLoaded = ko.observable(false)
    this.unsavedDocName = ko.observable('')
    var y = [
      2000,2001,2002,2003,2004,
      2005,2006,2007,2008,2009,
      2010,2011,2012,2013,2014,
      2015,2016,2017,2018,2019,2020
    ]
    this.years = ko.observableArray(y.sort().reverse())
    this.selectedYear = ko.observable('year')
    this.profName = ko.observable('')
    this.matchingProfs = ko.observableArray([])
    this.showUploadSuccess = ko.observable(false)
    this.submittable = ko.observable(false);
    this.courseAdderVisible = ko.observable(false)



    this.onStore = (function(){
      this.courseDescription(this.store.getGroupCourseInfo())
      this.isVisible(this.store.isUploaderOpen)
      this.courseAdderVisible(this.store.isCourseAdderVisible())
      this.submittable(this.store.isReadyToSubmit())
      this.matchingProfs(this.store.matchingProfs)
      if(this.store.inputsShouldBeReset())
        this.clearInputFields()
      var unsavedDoc = this.store.getUnsavedDoc()
      if(unsavedDoc){
        this.unsavedDocLoaded(true)
        this.unsavedDocName(this.store.getUnsavedDocTitle())
      }
      else{
        this.unsavedDocLoaded(false)
        this.unsavedDocName('')
      }
      this.showUploadSuccess(this.store.isSuccessPopupVisible())
    }).bind(this)
    this.store.sub(this.onStore)


    this.closeAdder = function(){
      this.dis.dispatch('closeCourseAdder')
    }

    this.addCourse = function(){
      var d = this.store.getUnsavedDoc()
      this.dis.dispatch('addCourseAndUpload',d)
    }


    this.close = (function(e){
      this.dis.dispatch('closeDocUploader')
    }).bind(this)


    this.getMatchingProfs = (function(name){
      if(name.length > 0){
          this.dis.dispatch('getMatchingProfs',name)
      }
      else{
        this.matchingProfs([])
      }
    }).bind(this)
    this.profNameId = this.profName.subscribe(this.getMatchingProfs)


    this.selectProf = (function(e, evt){
      evt.preventDefault()
      evt.stopPropagation()
      this.profName(e.getFirst() + ' ' + e.getLast())
      this.dis.dispatch('selectedProf',e)
    }).bind(this)


    this.setTitle = (function(title){
      if(title.length > 0)
        this.dis.dispatch('setDocTitle',title)
    }).bind(this)
    this.subTit = this.unsavedDocName.subscribe(this.setTitle)

    this.setYear = (function(year){
      if(String(year).length > 0)
        this.dis.dispatch('setDocYear',year)
    }).bind(this)
    this.subYearId = this.selectedYear.subscribe(this.setYear)

    this.clearInputFields = (function(){
      this.profName('')
      this.selectedYear('')
      this.dis.dispatch('uploaderHasBeenReset')
    }).bind(this)

    this.uploadDoc = (function(vm,event){
      var file = event.currentTarget.files[0]
      $("#doc-uploader-input").val('')
      this.dis.dispatch('docUpload',file)
    }).bind(this)


    this.submitDoc = function(){
      if(this.store.isReadyToSubmit()){
        this.dis.dispatch('submitDoc',this.store.getUnsavedDoc())
      }
    }

}; // end view model.

  return {
    viewModel: ViewModel,
    template: template
  }
});


define('text!chat/template.html',[],function () { return '<link rel="stylesheet" href="./styles/components/chat/style.css?v=2.6"></link>\n\n<div id="chat-holder"\n     data-bind="visible:isVisible()">\n\n     <!-- spinner -->\n     <div  class="screen-center-outer">\n      <div class="screen-center-inner">\n         <div class="loader"\n              data-bind="visible:isSpinnerVisible()">\n         </div>\n      </div>\n    </div>\n\n  <ul class="show-vert-scroll"\n      data-bind="foreach: messages"\n      id="chat">\n\n      <li class="chat-message"\n          draggable="false"\n          data-bind="css:{ \'chat-message-self\': owner == true}">\n\n        <!-- ko if: typeof img_url == \'string\' -->\n          <img data-bind="attr:{src:img_url}"\n               class="one-on-one-chat-img disable-select">\n          </img>\n        <!-- /ko -->\n\n        <span data-bind="html:getHTML()"\n              class="chat-text">\n        </span>\n\n        <!-- ko if: owner -->\n        <i data-toggle="tooltip" title="sending">\n          <i class="dot acknowledgement-dot empty-dot sent-dot"\n           data-bind="visible:!sent()">\n         </i>\n        </i>\n        <i data-toggle="tooltip" title="sent">\n          <i class="dot acknowledgement-dot filled-dot sent-dot"\n             data-bind="visible:sent()">\n          </i>\n        </i>\n        <i data-toggle="tooltip" title="seen">\n          <i class="dot acknowledgement-dot filled-dot seen-dot"\n             data-bind="visible:seen()">\n          </i>\n        </i>\n        <i class="dot acknowledgement-dot empty-dot seen-dot"\n           data-bind="visible:!seen()">\n        </i>\n        <!-- /ko -->\n\n        <span data-bind="text:timestamp, css: { \'chat-timestamp-other-person\': owner != true }"\n              class="chat-timestamp disable-select">\n        </span>\n\n        <i class="sender-img-holder"\n          data-bind="visible: owner == true">\n          <img class="sender-img"\n              data-bind="attr:{src:getSenderImageURL()}">\n        </img>\n        </i>\n\n        <i class="sender-img-holder-other"\n          data-bind="visible: owner == false">\n          <img class="sender-img"\n              data-bind="attr:{src:getSenderImageURL()}">\n        </img>\n        </i>\n\n      </li>\n  </ul>\n\n\n\n\n  <div class="message-sender">\n\n    <div data-bind="visible:friendTyping()"\n          id="typing-message-pos">\n      <div class="horz-loader">Loading...</div>\n      <i id="typing-message">Typing..</i>\n    </div>\n\n<!-- New friend message prompt. -->\n    <div id="send-msg-prompt"\n         data-bind="visible:showSendMsgPrompt()">\n\n        <span id="send-message-prompt-text"\n              class="disable-select">\n\n            Say hello!\n                <i class="down"\n                   id="send-message-prompt-down-arrow">\n                </i>\n          </span>\n    </div>\n    <textarea\n               id="chat-text-area"\n               rows="1"\n               class="message-input-holder show-vert-scroll"\n               placeholder="What would you like to say to them?"\n               type="text"\n               data-bind="textInput:newMessage,\n                          event:{keydown: onKeyPress}\n                          attr: {placeholder:placeholder()},\n                          hasFocus: inputHasFocus(),\n                          click: inputClicked">\n    </textarea>\n\n    <button\n            class="disable-select send-message-btn"\n            data-bind="enable:isValidInput(), click:send, css:{}">\n            SEND\n    </button>\n  </div>\n</div>\n';});

define('chat/models/ChatMessage',['ko'],
function(ko){
    var ChatMessage = function(data, host){

      this.sent = ko.observable(false);
      this.seen = ko.observable(false);


      this.getConstructorName = function(){
        return "ChatMessage";
      }

      this.setHost = function(host){
        if(typeof host != 'string' || host.lenth < 1)
          throw new Error('host must be set')
        this.host = host
      }
      this.setHost(host)

      this.setId = function(message_id){
        if(!message_id || typeof message_id != 'number'){
          throw new Error('message_id must be specified.');
        }
        this.message_id = message_id;
      }

      this.getId = function(){
        return this.message_id;
      }

      this.setText = function(text){
        if(!text || typeof text != 'string'){
          throw new Error('text property must exist in the message.');
        }
        this.text = text;
      }
      this.setText(data.text);

      this.setSenderImgURL = function(url){
        if(typeof url != 'string' || url.length < 1){
          this.imgURL = "./assets/no-photo.jpg"
        }
        else{
            this.imgURL = url
        }
      }
      this.setSenderImgURL(data.small_photo_url)

      this.getSenderImageURL = function(){
        return this.host + '/' + this.imgURL
      }

      this.getSenderId = function(){

      }

      this.isOwner = function(){

      }

    } // end constructor


    ChatMessage.getRaw = function(user_id){
      var raw = {
        timestamp: "2019-04-09T05:42:56.000Z",
        message_id: 3,
        recipient_id: 2,
        user_id:1,
        text:'default text',
        small_photo_url:'img.jpg'
      };

      if(user_id){
        raw.user_id = user_id;
        return raw
      }
      else{
        return raw;
      }
    }

    ChatMessage.getFake = function(){
      var raw = ChatMessage.getRaw();
      var host = 'fakehost'
      return new ChatMessage(raw, host);
    }

    return ChatMessage;
});

define('chat/models/OutboundChatMessage',['ko','chat/models/ChatMessage','text-utilities'],
function(ko,ChatMessage, TextUtilities){
    var OutboundChatMessage = function(raw, host){
    Object.setPrototypeOf(this, new ChatMessage(raw ,host));

    this.owner = true;
    this.token = Date.now();

    this.getConstructorName = function(){
      return "OutboundChatMessage";
    }

    this.setRecipientId = function(id){
      if(!id || Number.isInteger(id) == false){
        throw new Error('recipient_id must be a integer.');
      }
      this.recipient_id = id;
    }
    this.setRecipientId(raw.recipient_id);

    this.setSent = function(token){
      token == this.token ? this.sent(true) : null;
    }

    this.setSeen = function(messageId){
      messageId == this.getId() ? this.seen(true) : null;
    }

    /**
      Overrides
    */
    this.getHTML = function(){
      return TextUtilities.wrapLinks(this.text, 'chat-link');
    }

    this.getToken = function(){
      return this.token;
    }
  } // end constructor

  OutboundChatMessage.constructor = OutboundChatMessage;

  OutboundChatMessage.getFake = function(){
    var raw = ChatMessage.getRaw()
    raw.recipient_id = 1
    return new OutboundChatMessage(raw,'host');
  }
    return OutboundChatMessage;
});

define('chat/models/InboundChatMessage',['chat/models/ChatMessage',
        'text-utilities'],
function(ChatMessage,
         TextUtilities){
    var InboundChatMessage = function(raw, host){

    Object.setPrototypeOf(this, new ChatMessage(raw, host));

    this.setId(raw.message_id);
    this.sent(true);

    this.setSeen = function(seen){
      if(seen != 1 && seen != 0){
        throw new Error('seen must be 1 or 0');
      }
      this.seen(seen);
    }
    this.setSeen(raw.seen);

    this.setSenderId = function(id){
        if(!id || typeof id != 'number'){
          throw new Error('user_id must be set on each message.');
        }
      this.user_id = id;
    }
    this.setSenderId(raw.user_id);


    this.getSenderId = function(){
      return this.user_id;
    }

    this.setRecipientId = function(id){
      if(!id || typeof id != 'number'){
        throw new Error('recipient_id must be set on each message.');
      }
      this.recipient_id = id;
    }
    this.setRecipientId(raw.recipient_id);


    this.setTimestamp = function(time){
      if(typeof time != 'string' || time.length < 1){
        throw new Error('timestamp must exist.');
      }
      this.timestamp = time;
    }
    this.setTimestamp(raw.timestamp);

    this.isSent = function(){
      return false;
    }

    this.maybeSetAsOwner = function(owner){
      if(owner && owner != 'recipient'){
        this.owner = true;
      }
      else{
        this.owner = false;
      }
    }
    this.maybeSetAsOwner(raw.owner);


    this.isOwner = function(){
      return this.owner === true;
    }

    this.setStyleClass = function(styleClass){
      this.styleClass = styleClass;
    }

    /**
      To be used in a html binding in  knockoutjs.
    */
    this.getHTML = function(){
      if(!this.isOwner()){
        return TextUtilities.wrapLinks(this.text, 'chat-link-friend');
      }
      else{
        return TextUtilities.wrapLinks(this.text, 'chat-link');
      }
    }



  } // end constructor

  InboundChatMessage.getRaw = function(){
    var raw = ChatMessage.getRaw()
    var obj = Object.assign(raw,{
      message_id:1,
      user_id:2,
      recipient_id:3,
      text:'hello',
      timestamp:'moments ago',
      seen:0
    })
    console.log(obj)
    return obj
  }

  InboundChatMessage.getFake = function(){
    var raw = InboundChatMessage.getRaw()
    var host = 'host'
    return new InboundChatMessage(raw, host);
  }
  return InboundChatMessage;
});

define('chat/ChatRemoteService',['socketio',
        'ActiveRemoteService',
        'dispatcher/Dispatcher',
        'chat/models/InboundChatMessage'],
function(io,
         ActiveRemoteService,
         Dispatcher,
         InboundChatMessage){

var ChatRemoteService = function(){

    this.constructor = ChatRemoteService;
    this.sock = null;
    this.io = io;
    this.dis = new Dispatcher();
    Object.setPrototypeOf(this, new ActiveRemoteService());
    this.setMicroServer("chat");


    this.onAuth = function(change){
      if(change.state == 'authenticated'){
        this.setSock(this.onSock);
      }
    }
    this.onAuth = this.onAuth.bind(this);
    this.disAuthId = this.dis.reg('authState', this.onAuth);


    this.onSock = function(){
      this.sock.on('io_error',this.onError);
      this.sock.on('messageSent', this.onMessageSent);
      this.sock.on('chatHistory',this.onMessageHistory);
      this.sock.on('friendTyping',this.onTyping);
      this.sock.on('message', this.onMessage);
      this.sock.on('seen', this.onSeen);
    }
    this.onSock = this.onSock.bind(this);


    this.onError = function(err){
      console.log(err);
    }

    this.onMessageHistory = function(raw){
      var collection = [];
      var host = this.getServerURL()
      raw.forEach(function(e){
        collection.push(new InboundChatMessage(e,host));
      })
      this.dis.dispatch('chatHistory', collection);
    }
    this.onMessageHistory = this.onMessageHistory.bind(this);

    this.onMessage = function(raw){
      var host = this.getServerURL()
      this.dis.dispatch('message', new InboundChatMessage(raw, host));
    }
    this.onMessage = this.onMessage.bind(this);

    this.onMessageSent = function(acknowledgement){
      this.dis.dispatch('messageSent', acknowledgement);
    }
    this.onMessageSent = this.onMessageSent.bind(this);


    this.onSeen = function(messageIds){
      if(!Array.isArray(messageIds)){
        throw new Error('messageIds must be an array.')
      }
      else if(messageIds.length > 0){
        this.dis.dispatch('seen',messageIds);
      }
    }
    this.onSeen = this.onSeen.bind(this);


    this.emitGetHistory = function(classmateId){
      this.sock.emit('getChatHistory',classmateId);
    }
    this.emitGetHistory = this.emitGetHistory.bind(this);
    this.histId = this.dis.reg('getChatHistory', this.emitGetHistory);


    this.emitSeen = function(m){
      this.sock.emit('messageSeen', m);
    }
    this.emitSeen = this.emitSeen.bind(this);
    this.seenId = this.dis.reg('messageSeen', this.emitSeen);


    this.emitMessage = function(m){
      this.sock.emit('sendMessage', m);
    }
    this.emitMessage = this.emitMessage.bind(this);
    this.sendMessageId = this.dis.reg('sendMessage',this.emitMessage);

    this.emitTyping = function(classmatesTyping){
      this.sock.emit('typing',classmatesTyping);
    }
    this.emitTyping = this.emitTyping.bind(this);
    this.typingId = this.dis.reg('typing',this.emitTyping);

    this.onTyping = function(classmateId){
      this.dis.dispatch('friendTyping',classmateId);
    }
    this.onTyping = this.onTyping.bind(this);

}

return ChatRemoteService;
})
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */

define('chat/ViewModel',['ko',
        'socketio',
        'text-utilities',
        'text!chat/template.html',
        'chat/models/ChatMessage',
        'chat/models/OutboundChatMessage',
        'chat/ChatRemoteService',
        'dispatcher/Dispatcher'],

function(ko,
         io,
         TextUtilities,
         template,
         ChatMessage,
         OutboundChatMessage,
         ChatRemoteService,
         Dispatcher){


  function ViewModel(params,componentInfo){

    this.dis = new Dispatcher();
    this.selectedClassmateId = ko.observable(null);
    this.inputHasFocus = ko.observable(false).extend({notify: 'always'});
    this.placeholder = ko.observable('');
    this.messages = ko.observableArray([]);
    this.showSendMsgPrompt = ko.observable(false);
    this.newMessage = ko.observable('');
    this.isValidInput = ko.observable(false);
    this.isSpinnerVisible = ko.observable(false);
    this.friendTyping = ko.observable(false);
    this.remoteService = new ChatRemoteService();
    this._messageSentHideDelay = 5000;
    this.chatBoxHeight = ko.observable(1)


    this.onClassmateSelected = (function(classmate){
      if(!classmate || typeof classmate != 'object'){
        throw new Error('Classmate must be an object.');
      }
      this.selectedClassmateId(classmate.getId());
      this.refreshChat();
    }).bind(this)
    this.dis.reg('focusPerson',this.onClassmateSelected);

    this.isVisible = ko.computed(function(){
        return this.selectedClassmateId() > 0 && this.selectedClassmateId() != null;
    },this);

    this.possiblyScaleInputBox = (function(){
      var rows = this.newMessage().split(/\r\n|\r|\n/).length
      $('#chat-text-area').attr('rows',rows)
    }).bind(this)


    this.onKeyPress = (function(vm, event){
      event.send = this.send;
      this.possiblyScaleInputBox()
      return TextUtilities.onKeyPress(event);
    }).bind(this)

    this.validateTextInput = function(value){
      /[^\s]+/.test(value) ? this.isValidInput(true) : this.isValidInput(false);
    }
    this.validateTextInput = this.validateTextInput.bind(this);
    this.newMessage.subscribe(this.validateTextInput,this);

    this.recordPartialText = function(text){
      var classmateId = this.selectedClassmateId();
      if(isNaN(classmateId) || classmateId < 1){
        throw new Error('classmateId must be a postive integer.');
      }
      else if(typeof text == 'string' && text.length > 0){
        this.dis.dispatch('typing',{recipient_id: classmateId, text:text});
      }
    }
    this.recordPartialText = this.recordPartialText.bind(this);
    this.typingSub = this.newMessage.subscribe(this.recordPartialText,this);


    this.setNoPersonSelected = (function(){
      this.selectedClassmateId(null);
    }).bind(this)
    this.dis.reg('groupInfo',this.setNoPersonSelected);
    this.dis.reg('openNews', this.setNoPersonSelected)

    this.onMessageHistory = function(msgs){
      if(!Array.isArray(msgs)){
        throw new Error('msgs must be an array.');
      }
      this.isSpinnerVisible(false);
      if(msgs.length <= 0){
        this.attachSendMessagePrompt();
      }
      else{
        this.showSendMsgPrompt(false);
        for(var i = 0; i < msgs.length; i++){
          var classmateId = this.selectedClassmateId();
          var senderId = msgs[i].getSenderId();
          var owner = msgs[i].isOwner();
          if(classmateId == senderId || owner){
              this.messages.unshift(msgs[i]);
          }
        }
      }
    }
    this.onMessageHistory = this.onMessageHistory.bind(this);
    this.dis.reg('chatHistory', this.onMessageHistory);


    /**
     * Shows the "Send a message to X" prompt
     * because there currently is no chat
     * history for the given friend.
     */
    this.attachSendMessagePrompt = function(){
      this.showSendMsgPrompt(true);
    }
    this.attachSendMessagePrompt = this.attachSendMessagePrompt.bind(this);

    this.initialize = ko.computed(function(){
      var friendId = this.selectedClassmateId();
      return friendId;
    },this);

    this.clearChat = function(){
        this.messages([]);
        this.friendTyping(false);
    }

    this.updateTextInputPlaceHolder = function(classmate){
      this.placeholder("What would you like to say to " + classmate.getFirst() + "?");
    }
    this.updateTextInputPlaceHolder = this.updateTextInputPlaceHolder.bind(this);
    this.dis.reg('selectedClassmate', this.updateTextInputPlaceHolder);



    this.oldFriendId = null;

    this.refreshChat = function(){
        var friendId = this.selectedClassmateId();
        if(friendId < 1){
          return; // no friend selected.
        }
        if(this.oldFriendId){
          this.clearChat();
        }
        this.isSpinnerVisible(true);
        this.oldFriendId = friendId;
        this.newMessage('');
        this.dis.dispatch('getChatHistory',friendId)
    }
    this.refreshChat = this.refreshChat.bind(this);

    this.inputClicked = function(){
      this.inputHasFocus(true);
    }


    /**
     * adds the message to the display and sends it
        because there is a noticable lag before the
        server response. (sent!) gets shown when the serve responds.
     */
    this.send = function(){
      var r = this.selectedClassmateId();
      var text = TextUtilities.formatToHTML(this.newMessage());
      var host = this.remoteService.getServerURL()
      var obj = {
        text:text,
        small_photo_url:'img',
        recipient_id:r
      }
      var m = new OutboundChatMessage(obj,host);
      this.messages.unshift(m);
      m.text = Object.getPrototypeOf(m).text;
      this.dis.dispatch('sendMessage', m);
      this.newMessage('');
    }
    this.send = this.send.bind(this);



    /**
      Finds the matching message
      and set it to 'sent'.
    */
    this.onMessageSent = function(acknowledgement){
      var token = acknowledgement.token;
      this.messages().forEach(function(m){
        if(m.getConstructorName() == 'OutboundChatMessage' && token == m.getToken()){
            m.setSent(token);
            m.setId(acknowledgement.id);
        }
      })
      this.possiblyScaleInputBox()
    }
    this.onMessageSent = this.onMessageSent.bind(this);
    this.dis.reg('messageSent', this.onMessageSent);


    this.onMessagesSeen = function(messageIds){
      this.messages().forEach(function(m){
        if(m.getConstructorName() == 'OutboundChatMessage'){
          messageIds.forEach(function(id){
              m.setSeen(id);
          })
        }
      })
    }
    this.onMessagesSeen = this.onMessagesSeen.bind(this);
    this.seenId = this.dis.reg('seen', this.onMessagesSeen);


    this.onTyping = function(id){
      if(id == this.selectedClassmateId()){
        this.friendTyping(true);
        var self = this;
        if(self.onTypingId){
          clearTimeout(self.onTypingId);
        }
        self.onTypingId = setTimeout(function(){
          self.friendTyping(false);
        },3000);
      }
    }
    this.onTyping = this.onTyping.bind(this);
    this.dis.reg('friendTyping',this.onTyping);

    this.onMessage = function(message){
        var classmateId = this.selectedClassmateId();
        if(message.getSenderId() === classmateId){
          this.messages.unshift(message);
          this.showSendMsgPrompt(false);
          this.friendTyping(false);
          this.dis.dispatch('messageSeen', message);
        }
    }
    this.onMessage = this.onMessage.bind(this);
    this.disChatId = this.dis.reg('message', this.onMessage);

}; // end view model.

  return {
    viewModel: ViewModel,
    template: template
  }

});


define('text!right-panel/template.html',[],function () { return '\n\n\n    <screen-share></screen-share>\n    <forum-stats></forum-stats>\n    <course-info></course-info>\n    <pre-view></pre-view>\n    <person-info></person-info>\n    <file-dropper></file-dropper>\n';});

define('right-panel/Component',['ko', 'text!right-panel/template.html',],
function(ko, template){
  var ViewModel = function(){};
  return {
    viewModel:ViewModel,
    template: template
  }
});

define('ad-views/AdRemoteService',['ActiveRemoteService',
        'socketio',
        'dispatcher/Dispatcher',
        'jquery'],
function(ActiveRemoteService,
         io,
         Dispatcher,
         $){


  var AdRemoteService = function(data){
    this._io = io;
    this.dis = new Dispatcher();
    this.constructor = AdRemoteService;
    Object.setPrototypeOf(this, new ActiveRemoteService());
    this.setMicroServer("ads");


    this.registerOnAdReceived = function(fn){
      this.checkFunction(fn);
      this.onAdReceived = fn;
    }

    this.getAdFromServer = function(){
      var url = this.getServerURL() + '/ad';
      var self = this;
      $.ajax({
        url:url,
        type:'GET',
        beforeSend:this.setAuthorizationHeader,
        success:function(json){
          self.onAdReceived(JSON.parse(json));
        },
        error:function(a,b,err){
          console.log(err);
        }
      });
    }


    this.registerOnMessageSent = function(fn){
      this.checkFunction(fn);
      this.onMessageSent = fn;
    }



    this.onAdHovered = function(ad){
      var url = this.getServerURL() + '/adHovered';
      $.ajax({
        url:url,
        type:'POST',
        data:{adId:ad.getId()},
        beforeSend:this.setAuthorizationHeader,
        error:function(a,b,err){
          console.log(err);
        }
      });
    }
    this.onAdHovered = this.onAdHovered.bind(this);
    this.adHoveredId = this.dis.reg('adHovered', this.onAdHovered);



    this.recordLeadClick = function(ad){
      var url = this.getServerURL() + '/adClicked';
      $.ajax({
        url:url,
        type:'POST',
        data:{adId:ad.getId()},
        beforeSend:this.setAuthorizationHeader,
        error:function(a,b,err){
          console.log(err);
        }
      });
    }


    this.sendMessage = function(adMsgPair){
      var url = this.getServerURL() + '/message';
      var ad = adMsgPair.ad;
      var msg = adMsgPair.message;
      $.ajax({
        url:url,
        type:'POST',
        data:{
          adId:ad.getId(),
          message:msg,
          headline:ad.getHeadline()
        },
        beforeSend:this.setAuthorizationHeader,
        success:this.onMessageSent,
        error:function(a,b,err){
          console.log(err);
        }
      });
    }


    this.checkFunction = function(fn){
      if(typeof fn != 'function'){
        throw new Error('fn must be a function');
      }
    }

  } // end constructor.

  return AdRemoteService;

})
;

define('ad-views/NullAd',['ko'],
function(ko){

  var NullAd = function(data){
    this.getConstructorName = function(){
      return "NullAd";
    }

    this.id = 0;
    this.headline = "Your Headline";
    this.degree = "B.A";
    this.school = "York University";
    this.major = "Computer Science";
    this.experience = 2;
    this.firstName = "First";
    this.lastName = "Last";
    this.imgURL = './assets/no-photo.jpg';
    this.hourlyRate = 25;
    this.isDegreeVerified = true;

    this.getId = function(){
      return this.id;
    }

    this.getHeadline = function(){
      return this.headline;
    }

    this.getDegree = function(){
      return this.degree;
    }


    this.getSchool = function(){
      return this.school;
    }


    this.getMajor = function(){
      return this.major;
    }

    this.getExperience = function(){
      return this.experience;
    }


    this.getFirstName = function(){
      return this.firstName;
    }

    this.getLastName = function(){
      return this.lastName;
    }

    this.getImgURL = function(){
      return this.imgURL;
    }


    this.getHourlyRate = function(){
      return this.hourlyRate;
    }


    this.isDegreeVerified = function(){
      return this.isDegreeVerified;
    }

    this.getText = function(){
      return '';
    }

  } // end constructor.

  return NullAd;

})
;

define('ad-views/Ad',['ko'],
function(ko){

  var Ad = function(data){


    this.getConstructorName = function(){
      return "Ad";
    }

    this.checkString = function(str, errMsg){
      if(!str || typeof str != 'string' || str.length < 1){
        throw new Error(errMsg);
      }
    }

    this.checkNum = function(num, errMsg){
      if(!num || Number.isInteger(num) == false || num < 1){
        throw new Error(errMsg);
      }
    }


    this.setId = function(id){
      this.checkNum(id, 'ad_id required');
      this.ad_id = id;
    }
    this.setId(data.ad_id);

    this.getId = function(){
      return this.ad_id;
    }


    this.setHeadline = function(headline){
      this.checkString(headline,'headline is required.');
      this.headline = headline;
    }
    this.setHeadline(data.headline);

    this.getHeadline = function(){
      return this.headline;
    }

    this.setDegree = function(degree){
      this.checkString(degree, 'degree is required.');
      this.degree = degree;
    }
    this.setDegree(data.degree);


    this.getDegree = function(){
      return this.degree;
    }

    this.setSchool = function(school){
      this.checkString(school, 'school is required.');
      this.school = school;
    }
    this.setSchool(data.school);


    this.getSchool = function(){
      return this.school;
    }

    this.setMajor = function(major){
      this.checkString(major, 'major is required.');
      this.major = major;
    }
    this.setMajor(data.major);


    this.getMajor = function(){
      return this.major;
    }

    this.setExperience = function(exp){
      this.checkNum(exp, 'experience is required.');
      this.experience = exp;
    }
    this.setExperience(data.experience);


    this.getExperience = function(){
      return this.experience + " years";
    }


    this.setFirstName = function(name){
      this.checkString(name, 'first_name is is required.');
      this.firstName = name;
    }
    this.setFirstName(data.first_name);


    this.getFirstName = function(){
      return this.firstName;
    }


    this.setLastName = function(name){
      this.checkString(name, 'last_name is is required.');
      this.lastName = name;
    }
    this.setLastName(data.last_name);


    this.getLastName = function(){
      return this.lastName;
    }

    this.setImgURL = function(url){
      this.checkString(url, 'img_url is is required.');
      this.imgURL = url;
    }
    this.setImgURL(data.img_url);

    this.getImgURL = function(){
      return this.serverPrefix + '/' + this.imgURL;
    }

    this.setServerPrefix = function(host){
      this.checkString(host);
      this.serverPrefix = host;
    }

    this.setHourlyRate = function(rate){
      this.checkNum(rate, 'hourly_rate is required.');
      this.hourlyRate = rate;
    }
    this.setHourlyRate(data.hourly_rate);

    this.getHourlyRate = function(){
      return this.hourlyRate;
    }

    this.setDegreeVerification = function(isVerified){
      if(isVerified != 0 && isVerified != 1){
        throw new Error('is_degree_verified is required.');
      }
      this.isDegreeVerified = isVerified;
    }
    this.setDegreeVerification(data.is_degree_verified);


    this.isDegreeVerified = function(){
      return this.isDegreeVerified;
    }

    this.setText = function(text){
      if(!text || typeof text != 'string' || text.length < 1){
        throw new Error('Ads must have non-empty text.');
      }
      this.text = text;
    }
    this.setText(data.text);


    this.getText = function(){
      return this.text;
    }

  } // end constructor.

  return Ad;

})
;
define('ad-views/AdStore',['ko',
         'ad-views/AdRemoteService',
         'dispatcher/Dispatcher',
         'ad-views/NullAd',
         'ad-views/Ad'],
function(
  ko,
  RemoteService,
  Dispatcher,
  NullAd,
  Ad
){


  var Store = {};
  var _currentAd = new NullAd();
  var _subscribers = [];

  var _remoteService = new RemoteService();
  var _isWaiting = false;
  var _dis = new Dispatcher();
  var _isAdVisible = true;
  var _isLeadOpen = false;
  var _leadMessage = 'Hi, I’m interested. Please contact me.';
  var _onPub = null;


  var _publish = function(){
    _subscribers.forEach(function(e){
      e();
    })
    if(typeof _onPub == 'function'){
      _onPub();
    }
  }

  Store.onPub = function(fn){
    _onPub = fn;
  }

  Store.getCurrentAd = function(){
    return _currentAd;
  }

  Store.setCurrentAd = function(ad){
    if(ad.getConstructorName() != 'Ad'){
      throw new Error('error');
    }
    _currentAd = ad;
  }


  Store.isAdVisible = function(){
    return _isAdVisible;
  }

  Store.setAdVisible = function(){
    _isAdVisible = true;
  }

  Store.setAdNotVisible = function(){
    _isAdVisible = false;
  }

  Store.onOpenGroupView = function(){
     Store.setAdVisible();
    _publish();
  }
  _dis.reg('showGroupView',Store.onOpenGroupView);



  Store.onGiveClassmateFocus = function(){
    Store.setAdNotVisible();
    _publish();
  }
  Store.classmateId = _dis.reg('focusPerson', Store.onGiveClassmateFocus);


  Store.init = function(){
    _remoteService.registerOnAdReceived(Store.onAdReceived);
    _remoteService.registerOnMessageSent(Store.onMessageSent);
  }

  Store.onAdReceived = function(rawAd){
    _currentAd = new Ad(rawAd);
    _currentAd.setServerPrefix(_remoteService.getServerURL());
    Store.publish();
  }

  Store.onMessageSent = function(){
    _isWaiting = false;
    Store.publish();
  }

  Store.getLeadMessage = function(){
    return _leadMessage;
  }

  Store.onCourseInfo = function(groupInfo){
    _remoteService.getAdFromServer();
  }
  _dis.reg('groupInfo', Store.onCourseInfo);

  Store.isWaiting = function(){
    return _isWaiting;
  }

  Store.isLeadOpen = function(){
    return _isLeadOpen;
  }

  Store.onOpenLead = function(){
    _isLeadOpen = true;
    Store.publish();
    _remoteService.recordLeadClick(_currentAd);
  }
  _dis.reg('openLead', Store.onOpenLead);


  Store.onCloseLead = function(){
    _isLeadOpen = false;
    Store.publish();
  }
  _dis.reg('closeLead', Store.onCloseLead);

  Store.onMessage = function(msg){
    _remoteService.sendMessage({
      ad:_currentAd,
      message:msg
    });
    _isWaiting = true;
    Store.publish();
  }
  _dis.reg('leadMessage', Store.onMessage);

  Store.subscribe = function(fn){
    _subscribers.push(fn);
  }

  Store.publish = function(){
    _subscribers.forEach(function(fn){
      fn();
    })
    if(typeof _onPub == 'function'){
      _onPub();
    }
  }

  Store.getRemoteService = function(){
    return _remoteService;
  }

  Store.init();
  return Store;
});


define('text!ad-views/pre-view/template.html',[],function () { return '<link rel="stylesheet"\n      href="./styles/components/right-panel/ad-views/pre-view.css">\n  <div id=\'ad-views-holder\'\n       data-bind="visible:isVisible(),click:openLead,  event: { mouseenter: onHover}">\n       <div id="inner-ad-holder">\n         <img id="ad-image"\n              data-bind="attr:{\'src\':currentAd().getImgURL()}">\n         </img>\n         <div id="preview-bottom-part">\n           <div id="preview-footer"\n                data-bind="text:currentAd().getHeadline()">\n           </div>\n         </div>\n       </div>\n\n\n  </div>\n';});

define('right-panel/ad-views/pre-view/Component',['ko',
        'dispatcher/Dispatcher',
        'ad-views/AdStore',
        'text!ad-views/pre-view/template.html',
         'ad-views/NullAd'],
function(
  ko,
  Dispatcher,
  AdStore,
  template,
  NullAd){

  var ViewModel = function(){
    this.dis = new Dispatcher();
    this.isVisible = ko.observable(false);
    this.isLeadVisible = ko.observable(false).extend({notify:'always'});
    this.currentAd = ko.observable(new NullAd());
    this.store = AdStore;

    this.onStoreChange = function(){
      this.isVisible(this.store.isAdVisible());
      this.currentAd(this.store.getCurrentAd());
    }
    this.onStoreChange = this.onStoreChange.bind(this);
    this.store.subscribe(this.onStoreChange);


    this.openLead = function(){
      this.dis.dispatch('openLead');
    }


    this.onHover = function(){
      this.dis.dispatch('adHovered',this.currentAd());
    }
    this.onHover = this.onHover.bind(this);


}; // end view model.

  return {
    viewModel:ViewModel,
    template: template
  }
});


define('text!ad-views/lead-view/template.html',[],function () { return '\n<link rel="stylesheet"\n      href="./styles/components/right-panel/ad-views/lead-view.css?v=1.0">\n\n<div id="lead-submitter"\n     class=\'background-dimmer\'\n     data-bind="visible: isVisible()">\n  <div id="ad-waiting"\n       class="loader"\n       data-bind="visible:isWaiting()">\n  </div>\n\n  <div id="message-sent" data-bind="visible:showMessageSent()">\n      Message Sent!\n  </div>\n\n  <!-- ko if: currentAd() != null -->\n  <div id="submitter-window" data-bind="click : closeLead">\n\n    <div>\n\n      <div id="ad-space" data-bind="click: dontPropagate">\n         <div id="ad-headline" data-bind="text:currentAd().getHeadline()"></div>\n         <!-- top row -->\n            <div id="ad-header-holder">\n\n              <img id="tutor-image"\n                   data-bind="attr:{src : currentAd().getImgURL()}">\n              </img>\n\n              <ul id=\'qualifications-list\'>\n                <li>\n                   <span> School</span> <span class="qual-data" data-bind="text:currentAd().getSchool()"></span>\n                </li>\n                <li>\n                   <span> Degree </span> <span class="qual-data"  data-bind="text:currentAd().getDegree()"></span>\n                </li>\n                <li>\n                   <span> Major </span><span class="qual-data"  data-bind="text:currentAd().getMajor()"></span>\n                </li>\n                <li>\n                   Experience <span  class="qual-data" data-bind="text:currentAd().getExperience()"></span>\n                </li>\n              </ul>\n\n            </div>\n         <div id="ad-text" data-bind="html:currentAd().getText()"></div>\n      </div>\n\n\n\n\n      <div id="ad-right-side" data-bind="click: dontPropagate">\n        <div id="lead-submition-space">\n          <div id="advertiser-name"> Contact\n            <span data-bind="text:currentAd().getFirstName()"></span>\n            <span data-bind="text:currentAd().getLastName()"></span>\n          </div>\n          <textarea id="submitter-text-area"\n                    data-bind="value:leadMessage">\n          </textarea>\n          <button id="submitter-message-button"\n                  data-bind="click:sendMessage">Send Message</button>\n        </div>\n\n      </div>\n\n    </div>\n\n\n\n  </div>\n <!-- /ko -->\n\n\n</div>\n';});

define('right-panel/ad-views/lead-view/Component',['ko',
        'dispatcher/Dispatcher',
        'text!ad-views/lead-view/template.html',
         'ad-views/AdStore',
         'ad-views/NullAd'],
function(
  ko,
  Dispatcher,
  template,
  AdStore,
  NullAd){

  var ViewModel = function(){
    this.isVisible = ko.observable(false);
    this.leadMessage = ko.observable('Hi, I’m interested. Please contact me.');
    this.isWaiting = ko.observable(false);
    this.currentAd = ko.observable(new NullAd());
    this.showMessageSent = ko.observable(false);
    this.store = AdStore;
    this.dis = new Dispatcher();



    this.onStoreChanged = function(){
      this.currentAd(this.store.getCurrentAd());
      this.isVisible(this.store.isLeadOpen());
      var wasWaiting = this.isWaiting();
      var isWaiting = this.store.isWaiting();
      if(wasWaiting && !isWaiting){
          this.leadMessage(this.store.getLeadMessage());
          this.showMessageSent(true);
          var self = this;
          setTimeout(function(){
            self.showMessageSent(false);
            self.isVisible(false);
          },1500);
      }
      this.isWaiting(isWaiting);
    }
    this.onStoreChanged = this.onStoreChanged.bind(this);
    this.store.subscribe(this.onStoreChanged);

    /**
      Stops the click event from propagating up to
      the window holder,  this is so the window
      does not close.
      */
    this.dontPropagate = function(a, event){
      event.stopImmediatePropagation();
    }


    this.closeLead = function(e, a){
      this.dis.dispatch('closeLead');
    }
    this.closeLead = this.closeLead.bind(this);


    this.sendMessage = function(){
      var message = this.leadMessage().trim();
      if(message.length > 0){
        this.dis.dispatch('leadMessage', message);
        this.leadMessage('');
      }
      else{
        alert('Messages can\'t be empty');
      }
    }
    this.sendMessage = this.sendMessage.bind(this);

}; // end view model.

  return {
    viewModel:ViewModel,
    template: template
  }
});


define('text!right-panel/current-courses/template.html',[],function () { return '\n<link rel="stylesheet" href="./styles/components/right-panel/current-courses.css">\n\n<div id="current-courses-holder"\n     data-bind="visible:isVisible()">\n\n  <div data-bind="visible:isConciseVisible()">\n    <span data-bind="visible:verboseCourses().length > 0">\n      Courses:\n      <span data-bind="foreach:conciseCourses()">\n        <span class="current-course"\n              data-bind="text:getDept() + getCourseCode() + getSectionLetter(), click:$parent.selectCourse">\n        </span>\n      </span>\n    </span>\n     <span data-bind="visible:verboseCourses().length > 3, click:showVerboseList"\n           class="current-course">more</span>\n  </div>\n\n\n  <div data-bind="visible:isVerboseVisible()">\n    <span data-bind="visible:verboseCourses().length > 0">\n      Courses:\n      <span data-bind="foreach:verboseCourses()">\n        <span class="current-course"\n              data-bind="text:getDept() + getCourseCode() + getSectionLetter(), click:$parent.selectCourse">\n        </span>\n      </span>\n    </span>\n    <span data-bind="visible:isVerboseVisible(), click:hideVerboseList"\n          class="current-course">less</span>\n  </div>\n\n\n</div> <!--end holder  -->\n';});

define('right-panel/current-courses/Component',[
'ko',
'text!right-panel/current-courses/template.html',
'dispatcher/Dispatcher',
'course/models/CourseGroup',
'course/CourseStore'], function(
  ko,
  template,
  Dispatcher,
  CourseGroup,
  CourseStore){

  var ViewModel = function(){

    this.dis = new Dispatcher();
    this.store = CourseStore.getInstance();
    this.isVisible = ko.observable(false);

    this.isVerboseVisible = ko.observable(false);
    this.verboseCourses = ko.observableArray([]);

    this.isConciseVisible = ko.observable(true);
    this.conciseCourses = ko.observableArray([]);

    this.onStoreUpdate = function(){
      this.maybeSetExperimentalMode();
      var grps = this.store.getClassmateCourseGroups();
      this.verboseCourses(grps);
      var MAX_CONCISE_COURSES = 3;
      var concise = grps.slice(0, MAX_CONCISE_COURSES);
      this.conciseCourses(concise);
    }
    this.onStoreUpdate = this.onStoreUpdate.bind(this);
    this.store.sub(this.onStoreUpdate);


    this.maybeSetExperimentalMode = function(){
      var classmateId = this.store.getClassmatesId();

      if(Number.isInteger(classmateId)){
        if(classmateId % 2 == 0){
          this.isVisible(false);
        }
        else {
          this.isVisible(true);
        }
      }
    }


    this.selectCourse = function(grp){
      this.dis.dispatch('selectedGroupId', grp.getId());
    }
    this.selectCourse = this.selectCourse.bind(this);


    this.showVerboseList = function(){
      this.isVerboseVisible(true);
      this.isConciseVisible(false);
    }

    this.hideVerboseList = function(){
      this.isVerboseVisible(false);
      this.isConciseVisible(true);
    }




  }

  return {
    viewModel:ViewModel,
    template: template
  }

});


define('text!right-panel/course-info/template.html',[],function () { return '\n<!-- <link rel="stylesheet"\n      href="./styles/components/right-panel/course-info/course-info.css"> -->\n\n<div id="course-info-holder"\n     data-bind="visible:isVisible()">\n     <course-photos></course-photos>\n     <course-text-info></course-text-info>\n</div>\n';});

define('right-panel/course-info/Component',[
'ko',
'text!right-panel/course-info/template.html',
'dispatcher/Dispatcher',
'course/CourseStore'],
function(
  ko,
  template,
  Dispatcher,
  Store){

  var ViewModel = function(){

    this.dis = new Dispatcher();
    this.store = Store.getInstance();
    this.isVisible = ko.observable(false);

    this.onStoreChanged = function(){
      this.isVisible(this.store.isGroupViewVisible());
    }
    this.onStoreChanged = this.onStoreChanged.bind(this);
    this.store.sub(this.onStoreChanged);

}; // end view model.

  return {
    viewModel:ViewModel,
    template: template
  }
});


define('text!right-panel/course-info/text-info/template.html',[],function () { return '\n<link rel="stylesheet"\n      href="./styles/components/right-panel/course-info/text-info.css?v=1.1">\n\n<div id="course-text-info-holder">\n\n\n    <!-- ko if: group() != null -->\n\n  <div id="course-info-text">\n\n    <span id="course-group-location"\n         class="disable-select">\n\n        <span data-bind=\'text:group().getDept()\'></span>\n        <span data-bind="text:group().getCourseCode()"></span>\n        <span> Section </span>\n        <span data-bind="text:group().getSectionLetter()"></span>\n    </span>\n    <span id="course-description"\n         class="disable-select">\n         <span id=\'desc-name\' data-bind="text:group().getCourseDescription()"></span>\n    </span>\n    <span id="course-description"\n         class="disable-select">\n         Location:\n         <span data-bind="text:group().getBuilding()"></span>\n    </span>\n  </div>\n\n  <non-member-prompt></non-member-prompt>\n\n  <span id="leave-group-button"\n          data-bind="visible:isLeaveButtonVisible(), click:leaveGroup">\n          leave group\n  </span>\n\n\n\n  <!-- /ko -->\n\n\n</div>\n';});

define('right-panel/course-info/text-info/Component',[
'ko',
'text!right-panel/course-info/text-info/template.html',
'dispatcher/Dispatcher',
'course/CourseStore'],
function(
  ko,
  template,
  Dispatcher,
  Store){

  var ViewModel = function(){

    this.dis = new Dispatcher();
    this.store = Store.getInstance();
    this.group = ko.observable(null);
    this.isLeaveButtonVisible = ko.observable(false);

    this.onStoreChange = (function(){
      var g = this.store.getCurrentGroup()
      if(g){
        this.group(g);
      }
      this.isLeaveButtonVisible(this.store.isGroupMember());
    }).bind(this)
    this.store.sub(this.onStoreChange);


    this.leaveGroup = function(){
      this.dis.dispatch('leaveSelectedCourse');
    }

}; // end view model.

  return {
    viewModel:ViewModel,
    template: template
  }
});


define('text!right-panel/course-info/course-photos/template.html',[],function () { return '<link rel="stylesheet"\n      href="./styles/components/right-panel/course-info/course-photos.css?v=1.1">\n\n<div id="location-image-holder">\n\n\n  <img id="forum-img"\n       class="disable-select"\n       src="#"\n       data-bind="attr:{src:currentImageUrl()}">\n\n   <input id="location-image-upload-button"\n          type="file"\n          data-bind="event:{change:uploadPhoto}">\n   </input>\n   <span class=\'course-prof-holder\'>\n          <img class=\'prof-img\'\n               data-bind=\'attr:{src:profsPhotoURL()}\'>\n          </img>\n      <span class=\'groups-prof-name\'\n            data-bind=\'text:profsName()\'>\n      </span>\n  </span>\n</div>\n';});

define('right-panel/course-info/course-photos/CoursePhoto',[],
function(){

  var CoursePhoto = function(group, image){

    this.setGroup = function(group){
      if(Number.isInteger(group) == false){
        throw new Error('group cant be empty.');
      }
      this.groupId = group;
    }
    this.setGroup(group);


    this.getGroupId = function(){
      return this.groupId;
    }

    this.setImage = function(image){
      if(!image){
        throw new Error("image cant be empty.");
      }
      this.image = image;
    }
    this.setImage(image);


    this.getImage = function(){
      return this.image;
    }




  }

  return CoursePhoto;
});

define('right-panel/course-info/course-photos/Component',[
'ko',
'text!right-panel/course-info/course-photos/template.html',
'dispatcher/Dispatcher',
'course/CourseStore',
'right-panel/course-info/course-photos/CoursePhoto'],
function(
  ko,
  template,
  Dispatcher,
  Store,
  CoursePhoto){

  var ViewModel = function(){

  this.currentImageUrl = ko.observable('./assets/missing-group-photo.jpg');
  this.dis = new Dispatcher();
  this.store = Store.getInstance();
  this.isVisible = ko.observable(false);
  this.profsName = ko.observable('Unknown Professor')
  this.profsPhotoURL = ko.observable('./assets/no-photo.jpg')

  this.onStoreChange = function(){
    var g = this.store.getGroupInfo();
    if(g){
      this.profsName(g.getProfsName())
      this.currentImageUrl(g.getImgUrl()  + '?' + (new Date()).getTime());
      this.profsPhotoURL(g.getProfsPhoto())
    }
  }
  this.onStoreChange = this.onStoreChange.bind(this);
  this.store.sub(this.onStoreChange);


    this.uploadPhoto = function(data, event){
      var files = event.currentTarget.files;
      if (files && files[0]) {
          var file = files[0];
          var reader = new FileReader();
          var self = this;
          reader.onload = function(event){
            self.onPhotoReady(event);
          }
          reader.readAsDataURL(file);
      }
    }
    this.uploadPhoto = this.uploadPhoto.bind(this);



    this.onPhotoReady = function (e) {
        var image = e.target.result;
        var groupId = this.store.getGroupId();
        var coursePhoto = new CoursePhoto(groupId, image);
        this.dis.dispatch('saveCoursePhotograph', coursePhoto);
    }
    this.onPhotoReady = this.onPhotoReady.bind(this);



    /**
        Sets the next location. If the end of locations
        is reach it wraps around to beggining again.
    */
    this.nextPhoto = function(){
      // if(this.courseLocations.length > 0){
      //   if(this.currentLocationIndex < this.courseLocations.length - 1){
      //       this.currentLocationIndex++;
      //   }
      //   else{
      //     this.currentLocationIndex = 0;
      //   }
      //   // var location = this.courseLocations[this.currentLocationIndex];
      //   // this.locationImageURL(location.getLocationImageURL());
      //   // this.locationName(location.getLocationName())
      // }
    }
    this.nextPhoto = this.nextPhoto.bind(this);



    }; // end view model.

      return {
        viewModel:ViewModel,
        template: template
      }
    });


define('text!file-dropper/template.html',[],function () { return '<link rel="stylesheet" href="./styles/components/right-panel/file-dropper.css?v=1.0">\n\n\n      <form id="file-dropper-form"\n              data-bind="visible:isVisible()">\n              <div id="upload-button-holder">\n                  <label for="upload-button"\n                         title="Upload File"\n                         data-toggle="tooltip">\n                    <span class="glyphicon glyphicon-open"\n                          id="upload-button-image"></span>\n                  </label>\n                  <input id="upload-button"\n                         type="file"\n                         data-bind="event: { change : uploadFile}"/>\n              </div>\n      </form>\n\n\n      <span id="file-upload-progress-holder"\n            data-bind="visible:uploadInProgress()">\n      <span id="file-upload-progress-percentage"\n            data-bind="text:percentageComplete"></span>\n            <div id="file-upload-progress-bar"></div>\n      </span>\n      <div id="shared-files-holder"\n           class="show-vert-scroll"\n           data-bind="visible:isVisible()">\n           <div id="no-files-shared-message"\n                class="disable-select"\n                data-bind="visible:files().length <= 0">\n              no files shared.\n           </div>\n          <ul id="file-list"\n              class="show-vert-scroll"\n              data-bind="foreach: files">\n              <li>\n                <div class ="shared-files-holder "\n                     data-bind="css:{\'opened-file\' : user_opened(), \'unopened-file\' : !user_opened()},\n                                click:$parent.downloadFile">\n\n                  <div class="file-name-holder shared-files-text disable-select"\n                       data-bind="text:name">\n                  </div>\n                  <span class="trashbin glyphicon glyphicon-trash"\n                        data-toggle="tooltip"\n                        title="Delete"\n                        data-bind="click:$parent.deleteFile">\n                  </span>\n                </div>\n\n              </li>\n          </ul>\n        </div>\n';});



define('file-dropper/FileSharerRemoteService',['ActiveRemoteService',
        'format-converter'],
function(ActiveRemoteService,
         FormatConverter){

  var FileSharerRemoteService = function(){

      Object.setPrototypeOf(this,new ActiveRemoteService());
      this.sock = null;
      this._callbacks = {};
      this.setMicroServer("files");

      /**
       * Initializes the socket instance.
       */
      this.initSocket = function(){
        this.setSock();
      }

      this.registerFileUploadCallback = function(callback){
        this.sock.on('fileUpload',callback);
      }

      this.registerFileDeleteCallback = function(callback){
        this.sock.on('fileDelete',callback);
      }

       this.registerUploadProgressCallback = function(cb){
         this._callbacks['uploadProgressCallback'] = cb;
       }


      /**
       * Returns the first fileUpload callback for the socket.
       * There should be only one fileupload callback,  all others
       * are ignored.
       * @return {Function}
       */
      this.getFileUploadCallback = function(){
        let callbacks = this.sock._callbacks.$fileUpload;
        if(!callbacks){
          throw new Exception("no callback for that event is registered.");
        }
        else{
          return callbacks[0];
        }
      }
      /**
       * Sets the file  with the given name as opened, by the current user.
       */
      this.setFileAsOpened = function(fileName, friendId, onSuccess){
        // http://files.localhost/57/seen/Untitled%201.docx
        var url = this.getServerURL() + "/" + friendId + "/seen/" + fileName;
        // console.log(url);
          $.ajax({
            url:url,
            type:"POST",
            beforeSend:this.setAuthorizationHeader,
            success:onSuccess,
            error:function(a,b,err){
              console.log(err);
            }
          })
      }



      /**
       * Loads all the files shared between the current user
       * and the given friend.
       * @param  {Number} friendId  The userId of the currently selected friend.
       * @param  {Function} onSuccess callback function that
       * is executed with the list of files that are shared
       * between the two users.
       */
      this.loadFiles = function(friendId, onSuccess){
        var self = this;

        $.ajax({
          url:this.getServerURL() + "/" + friendId + "/files",
          type:"GET",
          cache:true,
          beforeSend:this.setAuthorizationHeader,
          success:function(response){
            var files = JSON.parse(response);
            for(var i = 0; i < files.length; i++){
              files[i].url = self.getServerURL() + "/" + files[i].url;
            }
            onSuccess(files);
          },
          error:function(jq,status,err){
            console.log(err);
          }
        })
      }


      /**
       * requests that the server delete the given file.
       * @param  {string} fileName
       * @param  {Number} friendId  int
       * @param  {Function} onSuccess callback.
       */
      this.deleteFile = function(fileName,friendId, onSuccess){

        var self = this;
        var url = this.getServerURL() + '/' + friendId + "/" + fileName;
        $.ajax({
            url:url,
            type: 'DELETE',
            beforeSend:this.setAuthorizationHeader,
            success: function(result) {
              onSuccess();
            },
            error:function(a,b,c){
              console.log(a.responseText);
              console.log(c);
            }
        });
      }




      /**
       * @param  {[type]} fileData is the image in base64 format.
       * @param {Function} callback is called on successful upload of the fileData.
       */
      this.uploadFile = function(fileData, fileName, friendId, onSuccess, onFailure){

        var data = fileData.replace(/^data:(.*);base64,/, "");
        var blob = FormatConverter.base64ToBlob(data);
        var formData = new FormData();
        formData.append('fileName', fileName);
        formData.append('friendId',friendId);
        formData.append('file', blob);
        var self = this;
        $.ajax({
          url:this.getServerURL() + '/uploadFile',
          type:"POST",
          contentType:false,
          processData:false,
          data:formData,
          beforeSend:this.setAuthorizationHeader,
          xhr:function(){
            var xhr = new window.XMLHttpRequest();
                xhr.upload
                   .addEventListener("progress",
                                      self._callbacks.uploadProgressCallback,
                                      false
                                    );
            return xhr;
          },
          success:function(fileResponse){
            var response = JSON.parse(fileResponse);
            response.url = self.getServerURL() + "/" + response.url;
            onSuccess(response);
          },
          error:function(jq,status,err){
            onFailure(jq.responseText);
          }
        })
      }
      this.uploadFile = this.uploadFile.bind(this);
  }


  return FileSharerRemoteService;

})
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */

define('right-panel/file-dropper/Component',[
'jquery',
'ko',
'text!file-dropper/template.html',
'file-dropper/FileSharerRemoteService',
'dispatcher/Dispatcher',
'people-store/PeopleStore',
'people-models/NullPerson'],
function($,
  ko,
  template,
  FileSharerRemoteService,
  Dispatcher,
  Store,
  NullPerson){

  function SharedFilesViewModel(params,componentInfo){


    this._remoteService = new FileSharerRemoteService();
    this.dis = new Dispatcher();
    this.store = Store.getInstance();
    this.files = ko.observableArray([]);
    this.isVisible = ko.observable(false);
    this.uploadInProgress = ko.observable(false);
    this.percentageComplete = ko.observable("0");
    this.selectedClassmateId = -1;
    this._fileToBeUploaded = null;
    this.FILE_SIZE_LIMIT = 25000000; // about 25 megabytes.

    /**
     * Formats the url so that it has the server URL prefixed to it.
     * @param  {[type]} response
     */
    this.formatURL = function(response){
      response.url = this._remoteService.getServerURL() + "/" + response.url;
      if(response.senderId == this.selectedClassmateId){
        this.onSuccessfulUpload(response);
      }
      // console.log("response.url == " + response.url);
    }
    this.formatURL = this.formatURL.bind(this);


    /**
     *
     * @param  {[type]} deleteMsg [description]
     * @return {[type]}           [description]
     */
    this.friendDeleteFile = function(deleteMsg){
      if(deleteMsg.senderId == this.selectedClassmateId){
        this.removeFileFromView(deleteMsg.name);
      }
    }
    this.friendDeleteFile = this.friendDeleteFile.bind(this);


    /**
     * Shows the view when the user state becomes authenticated and
     * Initializes the socket using the users token,
     * @param  {string} state
     */
    this.onAuth = function(update){
       if(update.state == 'authenticated'){
          this._remoteService.initSocket();
          this._remoteService.registerFileUploadCallback(this.formatURL);
          this._remoteService.registerFileDeleteCallback(this.friendDeleteFile);
          this._remoteService.registerUploadProgressCallback(this.uploadProgressCallback);
       }
       else{
         this.isVisible(false);
       }
    }
    this.onAuth = this.onAuth.bind(this);
    this.dis.reg('authState',this.onAuth);





    this.onFilesDownloaded = function(files){
        this.files([]);
        for(var i = 0; i < files.length; i++){
            files[i].user_opened = ko.observable(files[i].user_opened);
            this.files.push(files[i]);
        }
    }
    this.onFilesDownloaded = this.onFilesDownloaded.bind(this);


    /**
     *  Changes the state 'opened' to true for the
     *  file with the given fileName.
     */
    this.showFileAsSeen = function(fileName){
      var self = this;

      return function(){
        for(var i = 0; i < self.files().length; i++){
          if(self.files()[i].name == fileName){
            self.files()[i].user_opened(true);
            break;
          }
        }
      }
    }
    this.showFileAsSeen = this.showFileAsSeen.bind(this);



    /**
     * @pre: expects the accessToken to be
             stored in localStorage and the selectedFriend
             observable to be the currently selected
             friendId.

     * @post: Query's the remote service for the list
     *        of all files shared between this user
     *        and the currently selected friend.
     */
    this.onStoreChange = function(){
      var p = this.store.getFocusedPerson();
      if(p.getConstructorName() == 'NullPerson'){
        this.isVisible(false);
      }
      else{
        this.selectedClassmateId = p.getId();
        this._remoteService.loadFiles(this.selectedClassmateId, this.onFilesDownloaded);
        this.isVisible(true);
      }
    }
    this.onStoreChange = this.onStoreChange.bind(this);
    this.store.sub(this.onStoreChange);

    /**
     * downloads the file from the remote service
     * and displays it too the user. If
     * the file has not been opened before then
     * it sends a message to the remote service
     * that the file has now been opened.
     */
    this.downloadFile = function(data, event ,testMode){
      if(testMode != 'test'){
        window.open(data.url,'_blank');
      }

      if(!data.user_opened()){
        var self = this;
        var fileName = data.name;
        this._remoteService
            .setFileAsOpened(
              data.name,
              this.selectedClassmateId,
              this.showFileAsSeen(fileName));
      }
    }
    this.downloadFile = this.downloadFile.bind(this);

    /**
     * Uploads the file to the server.
     * @param  data is the file that was clicked.
     */
    this.uploadFile = function(data, input, testMode){

      if(!this.uploadInProgress()){
        if(testMode){
          testMode.callback();
        }
        if(input.target.files && input.target.files[0]){
          var reader = new FileReader();
          this._fileToBeUploaded = input.target.files[0];
          if(this._fileToBeUploaded.size > this.FILE_SIZE_LIMIT){
            alert('Files greater than 10mb cant be uploaded at the moment.');
            return;
          }
          var self = this;
          reader.onload = function(event){
            self.clearFileChooserInput(input.target);
            self.onFileLoadedInBrowser(event);
            $('#file-dropper-upload-btn').val('');
          }
          reader.readAsDataURL(this._fileToBeUploaded);
        }
      }
      else{
        alert('Only one file can be uploaded at a time.');
        $('#file-dropper-upload-btn').val('');
      }
    }
    this.uploadFile = this.uploadFile.bind(this);

    this.clearFileChooserInput = function(inputElement){
      var $el = $(inputElement);
      $el.wrap('<form>').closest('form').get(0).reset();
      $el.unwrap();
    }
    this.clearFileChooserInput = this.clearFileChooserInput.bind(this);


    this.uploadProgressCallback = function(event){
     this.uploadInProgress(true);
     var percent = (event.loaded / event.total) * 100;
     var progress = Math.round(percent);
     var strPercent = progress + "%";
     this.percentageComplete(strPercent);
     $('#file-upload-progress-bar').css('width',strPercent);
   }
   this.uploadProgressCallback = this.uploadProgressCallback.bind(this);



    /**
     * @param  {Event} event the fileReader has completed reading
     *  the file as a URL.
     */
    this.onFileLoadedInBrowser = function(event){

      for(var i = 0; i < this.files().length; i++){
        if(this.files()[i].name == this._fileToBeUploaded.name){
          alert("A file already exists with that name, please choose another name.");
          return;
        }
      }
      this._remoteService
          .uploadFile(
            event.target.result,
            this._fileToBeUploaded.name,
            this.selectedClassmateId,
            this.onSuccessfulUpload,
            this.onFailedUpload);
    }
    this.onFileLoadedInBrowser = this.onFileLoadedInBrowser.bind(this);



    this.onFailedUpload = function(httpResponseText){
      this.uploadInProgress(false);
      alert(httpResponseText);
    }
    this.onFailedUpload = this.onFailedUpload.bind(this);


    /**
     * Puts the uploaded file name at the top of the
     * list given the fileResponse from the server.
     */
    this.onSuccessfulUpload = function(fileResponse){
      if(!fileResponse.name || typeof fileResponse.user_opened == 'undefined' || !fileResponse.url)
      {
        throw new Error('invalid file response! Are you sure you did JSON.parse?');
      }

      fileResponse.user_opened = ko.observable(fileResponse.user_opened);
      this.files.unshift(fileResponse);
      this.uploadInProgress(false);
    }
    this.onSuccessfulUpload = this.onSuccessfulUpload.bind(this);


    /**
     *  Asks the remote service to delete the given file.
     * @param  {[type]} data  must have
     * @param  {[type]} event
     */
    this.deleteFile = function(data, event){

        if(event){
          event.stopPropagation();
        }
        var self = this;
        this._remoteService.deleteFile(
          data.name,
          this.selectedClassmateId,
          function(){
              self.removeFileFromView(data.name);
          });
    }
    this.deleteFile = this.deleteFile.bind(this);


    /**
     * Removes the file from files which have
     * the same name as fileName.
     * @param  {[type]} fileName [description]
     */
    this.removeFileFromView = function(fileName){

      for(var i = 0; i < this.files().length; i++){
        if(this.files()[i].name == fileName){
          this.files.splice(i,1);
          break;
        }
      }
    }
    this.removeFileFromView = this.removeFileFromView.bind(this);



}; // end view model.

  return {
    viewModel: SharedFilesViewModel,
    template: template
  }
});


define('text!right-panel/person-info/template.html',[],function () { return '\n<link rel="stylesheet"\n      href="./styles/components/right-panel/person-info.css?v=1.2">\n\n\n<div id="person-info-holder" data-bind="visible:isVisible()">\n        <!-- ko if: selectedClassmate() != null -->\n      <div id="large-user-photo-holder">\n\n          <button class=\'book-tutor-button\'\n                  data-bind=\'click:buyHours, visible:isTutor()\'>\n            Pro Tutor\n          </button>\n\n\n            <img id="person-info-photo"\n                 class="disable-select"\n                 src="#"\n                 data-bind="visible:isPhotoVisible(),\n                            attr:{src:selectedClassmate().getLargePhotoURL()}">\n            </img>\n\n            <!-- Video room button -->\n            <div id=\'video-button-panel\'>\n              <span id=\'call-button\'\n                    class=\'glyphicon glyphicon-facetime-video\'\n                    data-bind=\'click:connectToRoom, visible:isCallButtonVisible()\'\n                    title="Live video call"\n                    data-toggle="tooltip">\n              </span>\n              <span data-bind="visible:isCallButtonLoaderVisible()"\n                    class=\'nano-spinner\'>\n              </span>\n            </div>\n      </div>\n\n\n      <div id="person-info-name"\n           class="disable-select"\n           data-bind="text:selectedClassmate().getFirst()">\n      </div>\n\n      <div class="person-info-row-holder">\n\n        <i class="glyphicon glyphicon-education person-info-row-icon"></i>\n        <span class="person-info-row"\n              data-bind="text:selectedClassmate().getEducationLevel()">\n        </span>\n\n\n      </div>\n  <!-- /ko -->\n\n\n      <current-courses></current-courses>\n      <div  data-bind="visible:isAddPalVisible()"\n            class="right-panel-add-pal-holder">\n        <button class="add-pal add-pal-btn right-panel-add-pal"\n                data-bind="click:addPal">\n                add friend\n        </button>\n      </div>\n\n</div>\n';});

define('compatability',[], function(){

  var Compatability = function(){}

  Compatability.isVideoCallingSupported = function(onTrue, onFalse) {
    var twilio = require('twilio-video')
    if(twilio.isSupported) onTrue()
    else onFalse()
  }

return Compatability;
});

define('right-panel/person-info/Component',[
'jquery',
'ko',
'text!right-panel/person-info/template.html',
'dispatcher/Dispatcher',
'people-models/NullPerson',
'people-store/PeopleStore',
'compatability'],
function(
  $,
  ko,
  template,
  Dispatcher,
  NullPerson,
  Store,
  Compatability){

  var ViewModel = function(){

      this.dis = new Dispatcher();
      this.store = Store.getInstance();
      this.isVisible = ko.observable(false);
      this.selectedClassmate = ko.observable(null);
      this.isPhotoVisible = ko.observable(true);
      this.isExperimentalGroup = false;
      this.isAddPalVisible = ko.observable(false)
      this.isTutor = ko.observable(false)
      this.isCallButtonVisible = ko.observable(true)
      this.isCallButtonLoaderVisible = ko.observable(false)




      this.onStore = (function(){
        var p = this.store.getFocusedPerson();
        if(!p.isReal()){
          this.isVisible(false);
        }
        else{
          this.selectedClassmate(p);
          this.isVisible(true);
          this.isAddPalVisible(p.isAddable())
          this.isTutor(p.getRole() == 'tutor')
        }
      }).bind(this)
      this.store.sub(this.onStore);

      this.addPal = (function(){
        var classmate = this.selectedClassmate()
        if(classmate.isAddable()){
          this.dis.dispatch('addPal',classmate)
        }
      }).bind(this)

      this.connectToRoom = (function(){
          Compatability.isVideoCallingSupported(this.onCallingSupported,this.onNoCallingSupported)
      }).bind(this)

      this.onCallingSupported = (function(){
        var palId = this.store.getFocusedPerson().getId()
        this.isCallButtonVisible(false)
        this.isCallButtonLoaderVisible(true)
        var self = this
        setTimeout(function(){
          self.isCallButtonVisible(true)
          self.isCallButtonLoaderVisible(false)
        },1000)
        this.dis.dispatch('getRoomToken',palId)
      }).bind(this)

      this.onNoCallingSupported =  (function(){
        alert('Your browser does not support video calling here. \nPlease use the latest version of one of the following browsers:\n - Google Chrome\n - Firefox\n - Safari\n - Chromium Edge')
      }).bind(this)



      this.buyHours = function(){
        var pal = this.store.getFocusedPerson()
        this.dis.dispatch('openTutoringPlans',pal)
      }


}; // end view model.

  return {
    viewModel:ViewModel,
    template: template
  }
});


define('text!video-chat/template.html',[],function () { return '<link rel="stylesheet"\n      href="./styles/components/video-chat/style.css?v=1.4">\n</link>\n    <div id="video-chat-loader"\n         class="loader"\n         data-bind="visible:isSpinnerVisible()">\n    </div>\n\n<div id=\'caller-hungup-message\'\n     data-bind=\'visible:isPalHungupVisible()\'>\n     They hungup.\n</div>\n\n\n<div id=\'video-chat-holder\'\n     data-bind="visible:isVisible()">\n\n  <div id=\'video-chat-control-center\'>\n    <!-- <button style="position:absolute; z-index:10;" data-bind=\'click:download\'>DOWNLOAD RECORDING</button> -->\n\n    <span id=\'control-center-resizer\' class=\'resize-window-button\'>\n    </span>\n    <span id=\'hangup-button\'\n            data-bind="click:disconnect">\n            x\n    </span>\n    <div id=\'camera-video-holder\'>\n      <span id=\'camera-preview\'>\n      </span>\n    </div>\n    <div id=\'video-chat-buttons\'>\n\n      <div class="video-chat-button"\n           data-bind=\'click:shareScreen\'>\n          <div class="video-chat-screen-share-icon">\n            <span id=\'sharescreen-button-arrow\'\n                  class=\'glyphicon glyphicon-arrow-up\'>\n            </span>\n          </div>\n          <div class="video-chat-button-text">Share Screen</div>\n      </div>\n\n\n      <div id=\'mic-button\' class="video-chat-button" data-bind=\'click:toggleMicrophone\'>\n          <div class="video-chat-mute-icon">\n               <i id=\'mute-icon\' data-bind=\'visible:!isSharingMicrophone()\' class="video-chat-icon  fa fa-microphone-slash"></i>\n               <i id=\'mute-icon\' data-bind=\'visible:isSharingMicrophone()\' class="video-chat-icon fa fa-microphone"></i>\n          </div>\n          <div data-bind="visible:isSharingMicrophone()"class="video-chat-button-text">Mute</div>\n          <div data-bind="visible:!isSharingMicrophone()"class="video-chat-button-text">Unmute</div>\n      </div>\n\n\n      <div class="video-chat-button"\n           data-bind=\'click:shareVideo\'>\n          <div class="video-chat-facetime-icon">\n            <span class=\'video-chat-icon glyphicon glyphicon-facetime-video\'>\n            </span>\n          </div>\n          <div class="video-chat-button-text">Start Video</div>\n      </div>\n\n      <div id=\'session-timer-button\'\n           class="video-chat-button"\n           data-bind=\'click:openSessionTracker\'>\n          <div class="video-chat-time-icon">\n            <span\n                  class=\'video-chat-icon glyphicon glyphicon-time\'>\n            </span>\n          </div>\n          <div class="video-chat-button-text">Session Timer</div>\n      </div>\n\n    </div>\n      <session-tracker></session-tracker>\n\n    <div class=\'video-chat-message\'\n         data-bind=\'visible:showCallingRecipient()\'>\n        Calling\n        <span data-bind=\'text:focusedPersonsName()\'></span>...\n    </div>\n\n\n\n    <div class=\'video-chat-message\'\n        data-bind=\'visible:participants() < 1 && !showWaitingForPalToJoin() && isPalOnline()\'>\n      <div> No one in this room yet.</div>\n      <button id=\'invite-pal-button\'\n              data-bind=\'click:invitePal\'>\n        Invite <span data-bind="text:focusedPersonsName()"></span>\n      </button>\n    </div>\n\n    <div class=\'video-chat-message\'\n        data-bind=\'visible:!isPalOnline() && participants() < 1\'>\n         <span>\n            <span data-bind="text:focusedPersonsName()"></span> is offline.\n         </span>\n    </div>\n\n    <div class=\'video-chat-message\'\n        data-bind=\'visible:showWaitingForPalToJoin()\'>\n        Waiting for <span data-bind="text:focusedPersonsName()"></span> to join..\n    </div>\n\n    <div class=\'video-chat-message\'\n        data-bind=\'visible:participants() > 0 && isParticipantsCameraOn() == false\'>\n      <div>\n        <span data-bind="text:participantsName()"></span> is in this room.\n      </div>\n    </div>\n\n    <div  class=\'mic-state-message\'\n          data-bind=\'visible:!isParticipantMicrophoneOn() && participants() > 0\'>\n      Their microphone is off.\n    </div>\n\n    <div  class=\'mic-state-message\'\n          data-bind=\'visible:isParticipantMicrophoneOn() && participants() > 0\'>\n      Their microphone is on.\n    </div>\n\n\n\n  </div>\n\n  <div id="remote-media-holder">\n    <!-- all the media tracks get appended here. -->\n  </div>\n\n\n<!-- <span id=\'effect-credit\' >Sound effects obtained from https://www.zapsplat.com</span> -->\n  </div>\n\n\n</div>\n';});

define('video-chat/VideoRemoteService',['dispatcher/Dispatcher',
        'ActiveRemoteService',
        'people-models/Person'],
function(Dispatcher,
        ActiveRemoteService,
        Person){

   var VideoRemoteService  = function(){
     Object.setPrototypeOf(this, new ActiveRemoteService());
     this.dis = new Dispatcher();
     this.setMicroServer('live')

     this.onLeaveRoom = (function(palId){
       this.sock.emit('leaveRoom',palId)
     }).bind(this)
     this.leaveRoomId = this.dis.reg('leaveRoom', this.onLeaveRoom)


     this.emitRoomInviteError = (function(err){
       this.sock.emit('roomInviteError',err)
     }).bind(this)
     this.inviteErrId = this.dis.reg('roomInviteError',this.emitRoomInviteError)


     this.onRingRecipient = (function(palId){
       this.sock.emit('invitePalToRoom',palId)
     }).bind(this)
     this.ringRecipId = this.dis.reg('invitePalToRoom',this.onRingRecipient)

     this.onAuth = (function(auth){
       if(auth.state == 'authenticated' && !this.sock){
        this.setSock()
        this.sock.on('roomInvite',this.onRoomInvite)
        this.sock.on('roomInviteError',this.onRoomInviteError)
        this.sock.on('palLeftRoom',this.onPalLeftRoom)

      }
     }).bind(this)
     this.dis.reg('authState',this.onAuth)


     this.onPalLeftRoom = (function(palId){
       this.dis.dispatch('palLeftRoom', palId)
     }).bind(this)

     this.onRoomInviteError = (function(err){
       this.dis.dispatch('inboundRoomInviteError',err)
     }).bind(this)


     this.onRoomInvite = (function(data){
       var host = this.getServerURL()
       var p = new Person(data, host)
       this.dis.dispatch('roomInvite',p)
     }).bind(this)


     this.onDownloadSessionRecording = (function(){
       var url = this.getServerURL() + '/downloadSessionRecording';
       $.ajax({
         url:url,
         type:'get',
         beforeSend:this.setAuthorizationHeader,
         success:function(res){
            console.log(res)
            window.location = res
         },
         error:this.onError
       })
     }).bind(this)
     this.dis.reg('downloadSessionRecording', this.onDownloadSessionRecording)

     this.getRoomToken = (function(palId){
       var url = this.getServerURL() + '/getRoomToken?palId=' + palId;
       $.ajax({
         url:url,
         type:'get',
         beforeSend:this.setAuthorizationHeader,
         success:this.onTokenReceived,
         error:this.onError
       })
     }).bind(this)
     this.dis.reg('getRoomToken',this.getRoomToken)
     this.dis.reg('joinRoom',this.getRoomToken)


     this.onTokenReceived = (function(response){
       this.dis.dispatch('roomToken',response)
     }).bind(this)

     this.onError = (function(err){
       console.log(err)
       this.dis.dispatch('videoChatDown')
     }).bind(this)

  } // end

    return VideoRemoteService
  })
;
define('video-chat/WebRTCDevices',['DetectRTC'],
function(DetectRTC){

  var instance;

  var WebRTCDevices = function(){
    this._detect = DetectRTC;
    this.callbacks = [];

    this.reg = function(name, callback){
      if(!name || typeof name != 'string'){
        throw new Error('name must be a string.');
      }
      if(!callback || typeof callback != 'function'){
        throw new Error('callback must be a function.');
      }
      this.callbacks.push({
        name:name,
        callback:callback
      });
    }

    this.getCallbackFor = function(name){
      var cbs = this.callbacks;
      for(var i = 0; i < length; i++){
        if(name == cbs[i].name){
          return cbs[i].callback;
        }
      }
    }


    // callback is for dependants of this module.
    // once a callback is executed, dependants can
    // start accessing features of this module.
    this.onLoaded = (function(){
      for(var i = 0; i < this.callbacks.length; i++){
        var cb = this.callbacks[i];
        var capabilities = this.getCapabilties();
        cb.callback(capabilities);
      }
    }).bind(this)
    this._detect.load(this.onLoaded);

    this.getCapabilties = function(){
      if(!this._detect.isWebRTCSupported){
        return {
          hasWebcam:false, hasMicrophone:false
        }
      } else{
        return {
          hasWebcam:this.isWebcamAvailable(),
          hasMicrophone:this.isMicrophoneAvailable()
        }
      }
    }

    this.isWebcamAvailable = function(){
      var hasPermission = this._detect.isWebsiteHasWebcamPermissions
      var exists = this._detect.hasWebcam
      return hasPermission && exists
    }

    this.isMicrophoneAvailable = function(){
      var hasPermission = this._detect.isWebsiteHasMicrophonePermissions
      var exists = this._detect.hasMicrophone
      return hasPermission && exists
    }

  }

  return {
    getInstance:function(){
      if(!instance){
        instance = new WebRTCDevices();
      }
      return instance;
    },
    getNew:function(){
      return new WebRTCDevices();
    }
  }

});

define('window-utilities',[], function(){

  var Window = function(){}


  /**
     If there an element is already full screen,
     then it makes it not full screen.
  **/
  Window.toggleFullscreen = function(elem) {
    if (!document.fullscreenElement) {
      elem.requestFullscreen().catch(function(err){
        alert('Error attempting to enable full-screen mode: ' + err.message + ' ' + err.name);
      });
    } else {
      document.exitFullscreen();
    }
  }

  Window.attachResizer = function(element, resizer, options){

      if(!element || !resizer)
        throw new Error('elemen and resizer must be arguments.')

        var onMouseMove = function(event){
          event.preventDefault()
          var elementWidth = element.offsetWidth
          var centerPointX = elementWidth / 2
          var elementOffsetX = element.offsetLeft - centerPointX
          var elementOffsetY = element.offsetTop
          var mouseX = event.clientX
          var mouseY = event.clientY
          var newWidth = (mouseX - elementOffsetX)
          var newHeight = (mouseY - elementOffsetY)

          if(options){
            if(options['min-width'] < newWidth){
              element.style.width = newWidth + 'px'
            }
            if(options['min-height'] < newHeight){
              element.style.height = newHeight + 'px'
            }
          } else {
            element.style.width = newWidth + 'px'
            element.style.height = newHeight + 'px'
          }
        }

        resizer.addEventListener('mousedown', function(event){
          event.stopPropagation() // so draggin the div does not occur.
          document.addEventListener('mousemove',onMouseMove)
        })
        // dont resize anymore after the mouseup occurs.
        document.addEventListener('mouseup',function(){
          document.removeEventListener('mousemove',onMouseMove)
        })
  }



  Window.makeDragable = function(element){
    dragElement(element);
    // setDefaultPosition(element)
  }

  function setDefaultPosition(element){
    if(element){
      var percentFromTop = 0.2
      pos1 = (window.innerWidth / 2.)
      pos2 = percentFromTop * window.innerHeight
      element.style.left = (pos1) + "px";
      element.style.top = (pos2) + "px";
    }
  }

  function dragElement(element) {
    var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    if(!element){
      console.log('element does not exist!')
    }
    else if (document.getElementById(element.id + "header")) {
      // if present, the header is where you move the DIV from:
      document.getElementById(element.id + "header").onmousedown = dragMouseDown;
    } else {
      // otherwise, move the DIV from anywhere inside the DIV:
      element.onmousedown = dragMouseDown;
      element.ontouchstart = dragMouseDown;
    }

    function dragMouseDown(e) {
      e = e || window.event;
      e.preventDefault();
      // get the mouse cursor position at startup:
      pos3 = e.clientX;
      pos4 = e.clientY;
      document.onmouseup = closeDragElement;
      document.ontouchend = closeDragElement;

      // call a function whenever the cursor moves:
      document.onmousemove = elementDrag;
      document.ontouchmove = elementDrag;
    }

    function elementDrag(e) {
      e = e || window.event;
      e.preventDefault();
      // calculate the new cursor position:
      pos1 = pos3 - e.clientX;
      pos2 = pos4 - e.clientY;
      pos3 = e.clientX;
      pos4 = e.clientY;
      // set the element's new position:
      element.style.top = (element.offsetTop - pos2) + "px";
      element.style.left = (element.offsetLeft - pos1) + "px";
    }

    function closeDragElement() {
      // stop moving when mouse button is released:
      document.onmouseup = null;
      document.ontouchend = null;

      document.onmousemove = null;
      document.ontouchmove = null;
    }
  }

return Window;
});

define('video-chat/VideoStore',['dispatcher/Dispatcher',
        'abstract-interfaces/Store',
        'video-chat/VideoRemoteService',
        'video-chat/WebRTCDevices',
        'window-utilities',
         'people-models/Person'],
function(Dispatcher,
        Store,
        VideoRemoteService,
        WebRTCDevices,
        WindowUtil,
        Person){

   var instance = null;
   var VideoStore  = function(){
     new VideoRemoteService()
     this.twilio = require('twilio-video');
     Object.setPrototypeOf(this, new Store());
     this.dis = new Dispatcher();
     this.focusedPerson = null
     this.isRoomVisible = false
     this.isSpinnerOn = false
     this.currentParticipant = null
     this.participantCount = 0
     this.room = null
     this.videoChatDown = false
     this.roomInviter = null
     this.receivingRoomInvite = false
     this.RTCDevices = WebRTCDevices.getInstance()
     this.capabilities = null
     this.sharingScreen = false
     this.sharingMicrophone = true
     this.participantCameraOn = false
     this.participantMicrophoneOn = false
     this.isTutor = false
     this.palHungupVisible = false

     this.isParticipantMicrophoneOn = (function(){
       return this.participantMicrophoneOn
     }).bind(this)

     this.getFocusedPersonsId = function(){
       if(this.focusedPerson){
        return this.focusedPerson.getId()
      } else {
        return null
      }
     }

     this.onPalLeftRoom = (function(palId){
       if(this.roomInviter && this.roomInviter.getId() == palId){
         this.roomInviter = null
         this.receivingRoomInvite = false
         this.showPalHungup()
         this.pub()
       }
     }).bind(this)
     this.palLeftId = this.dis.reg('palLeftRoom',this.onPalLeftRoom)


     this.showPalHungup = (function(){
       this.palHungupVisible = true
       var self = this
       setTimeout(function(){
         self.palHungupVisible = false
         self.pub()
       },2500)
     }).bind(this)

     this.isPalHungupVisible = function(){
       return this.palHungupVisible
     }

     this.onInboundRoomInviteErr = (function(err){
       if(this.focusedPerson && this.focusedPerson.getId() == err.id){
         this.waitingForPalToJoin = false
         alert(err.err)
         this.pub()
       }
     }).bind(this)
     this.dis.reg('inboundRoomInviteError',this.onInboundRoomInviteErr)

     this.onProfile = (function(info){
       if(info.role == 'tutor'){
         this.isTutor = true
       } else {
         this.isTutor = false
       }
       this.pub()
     }).bind(this)
    this.dis.reg('profileUpdate',this.onProfile)


    this.isCurrentUserTutor = function(){
      return this.isTutor
    }

     this.onInvitePalToRoom = (function(){
       this.waitingForPalToJoin = true
       this.pub()
     }).bind(this)
     this.dis.reg('invitePalToRoom',this.onInvitePalToRoom)



     this.isWaitingForPalToJoin = (function(){
       return this.waitingForPalToJoin
     }).bind(this)


     this.onShareScreen = (function(){
       var room = this.getRoom()
       if(!room) throw new Error('You must be in a room to share your screen.')
       var promise = navigator.mediaDevices.getDisplayMedia()
       promise.then(this.onScreenStream).catch(function(err){
         alert(err.message)
       })
     }).bind(this)
     this.dis.reg('shareScreen',this.onShareScreen)

     /**
        pre: room is set.
      */
     this.onScreenStream = (function(stream, testing){
       var screenTrack = null
       if(!testing){
         var LocalVideoTrack = this.twilio.LocalVideoTrack;
         screenTrack = new LocalVideoTrack(stream.getTracks()[0]);
       }
       stream.getVideoTracks()[0].onended = this.stopScreenShareTrack
       var room = this.getRoom()
       room.localParticipant.publishTrack(screenTrack);
       this.sharingScreen = true
       this.pub()
     }).bind(this)


     this.isSharingScreen = function(){
       return this.sharingScreen
     }


     this.getRoom = function(){
        return this.room
     }


     this.onJoinRoom = (function(){
       this.isSpinnerOn = true
       this.pub()
     }).bind(this)
     this.dis.reg('joinRoom',this.onJoinRoom)

     this.isReceivingRoomInvite = function(){
       return this.receivingRoomInvite
     }

     this.onRoomInvite = (function(person){
       if(this.twilio && this.twilio.isSupported){
         this.roomInviter = person
         this.receivingRoomInvite = true
         this.pub()
       } else {
         var err = 'This persons device does not support video calling.'
         this.dis.dispatch('roomInviteError',{err:err, id:person.getId()})
         var name = person.getFirst()
         var m = name + ' is trying to call you but your browser does not support video calling.\n'
         m = m + 'Please upgrade your browser to its latest version.'
         alert(m)
       }
     }).bind(this)
     this.onRoomInviteId = this.dis.reg('roomInvite',this.onRoomInvite)

     this.getRoomInviter = function(){
       return this.roomInviter
     }

     this.wasInvitedToRoom = function(){
       return this.roomInviter != null
     }

     this.onVideoChatDown = (function(){
       this.videoChatDown = true
       this.pub()
     }).bind(this)
     this.onVideoDownId = this.dis.reg('videoChatDown',this.onVideoChatDown)


     this.isVideoChatDown = function(){
       return this.videoChatDown
     }

     // only update the focused person when
     // there is not already a video chat room
     // open.
     this.onFocusPerson = (function(person){
       if(!this.room){
         this.focusedPerson = person
         this.pub()
       }
     }).bind(this)
     this.FPersonId = this.dis.reg('focusPerson',this.onFocusPerson)

     // updates the state of the currently focused person.
     this.onUpdateFocusPerson = (function(person){
       this.focusedPerson = person
       if(this.focusedPerson.isPresent() == false)
         this.waitingForPalToJoin = false
       this.pub()
     }).bind(this)
     this.updateFPersonId = this.dis.reg('updateFocusPerson',this.onUpdateFocusPerson)



     this.isFocusedPersonOnline = function(){
       return this.focusedPerson && this.focusedPerson.isPresent()
     }

     this.getFocusedPersonsName = function(){
       if(this.focusedPerson)
        return this.focusedPerson.getFirst()
     }

     this.hasPalId = function(){
       return this.focusedPerson != null
     }

     this.getPalId = function(){
       return this.focusedPerson.getId()
     }

     this.showSpinner = function(){
       return this.isSpinnerOn
     }

     this.isRoomWindowOpen = function(){
       return this.isRoomVisible && (this.hasPalId() || this.wasInvitedToRoom())
     }

     this.onGettingToken = (function(){
       this.isSpinnerOn = true
       this.pub()
     }).bind(this)
     this.dis.reg('getRoomToken',this.onGettingToken)


     this.onDevicesLoaded = (function(capabilities){
       // console.log(capabilities)
       this.capabilities = capabilities
     }).bind(this)
     this.RTCDevices.reg('deviceCheck',this.onDevicesLoaded)

     this.getCapabilities = function(){
       return this.capabilities
     }

     this.isVideoAvailable = function(){
       if(!this.capabilities) throw new Error('Devices have not had a chance to load yet.')
       return this.capabilities.hasWebcam
     }

     this.isMicrophoneAvailable = function(){
       if(!this.capabilities) throw new Error('Devices have not had a chance to load yet.')
       return this.capabilities.hasMicrophone
     }

     // a fresh token shoudl be used for each pair.
     this.onRoomToken = (function(roomObject){
       this.isRoomVisible = true
       this.receivingRoomInvite = false
       this.waitingForPalToJoin = false
       var token = roomObject.token
       var roomName = roomObject.room
       var options = { name:roomName, audio:false,video:false}
       this.twilio
           .connect(token, options)
           .then(this.onRoomConnected,this.onRoomError);

     }).bind(this)
     this.roomTokenId = this.dis.reg('roomToken', this.onRoomToken)



     this.onShareVideo = (function(){
       var self = this
       var localMediaContainer = document.getElementById('camera-preview');

       if(localMediaContainer.childElementCount < 1){

         // attach stop button
         var $stop = $('<button id="stop-video-button">stop video</button>')
         $stop.on('click',this.stopCameraTrack)
         localMediaContainer.appendChild($stop[0])

          // attach video
          this.twilio.createLocalVideoTrack({ name: 'camera' }).then(function(localTrack) {
          self.room.localParticipant.publishTrack(localTrack);
          localMediaContainer.appendChild(localTrack.attach());
          self.sharingCamera = true
          self.pub()
        });
      } else{
        console.log('Already sharing your webcam.')
      }
     }).bind(this)
     this.dis.reg('shareVideo',this.onShareVideo)


     this.getConstraints = function(){
       if(this.isVideoAvailable() && this.isMicrophoneAvailable())
        return { audio:true, video: { width: 600 }}
       else if(this.isVideoAvailable() && !this.isMicrophoneAvailable())
        return { audio:false, video: { width: 600 }}
        else if(!this.isVideoAvailable() && this.isMicrophoneAvailable())
         return { audio:true, video: false}
     }


     this.onRoomConnected = (function(room){
        if(!this.focusedPerson && !this.roomInviter)
          throw new Error('if caller then person must be focused,  if recipient, roomInviter must exist!')

        this.isSpinnerOn = false
        this.dis.dispatch('videoCallRoomConnected')
        this.updateParticipantCount(room)
        this.showParticipantsAlreadyConnected(room)
        room.on('participantConnected',this.onParticipantConnected)
        room.on('participantDisconnected', this.onParticipantDisconnected)
        room.on('disconnected',this.onDisconnect)
        this.room = room

        this.pub()

    }).bind(this)

    this.getParticipantCount = function(){
      return this.participantCount
    }

    this.updateParticipantCount = (function(room){
      if(room)
      this.participantCount = room.participants.size
    }).bind(this)

    this.isParticipantsCameraOn = function(){
      return this.participantCameraOn
    }

    /**
      Should append a new element to the media holder
      if the track type is video.  if its audio,
      it just append it to the holder its self.
    */
    this.appendToMediaTrackHolder = (function(track){
      var holder = document.getElementById('remote-media-holder')
      if(track.kind == 'video'){
          if(track.name == 'camera'){
            var e1 = document.getElementById('camera-video-holder')
            e1.appendChild(track.attach());
            e1.childNodes[0].id = 'camera-video'
            this.participantCameraOn = true
          } else  {
            this.attachSharedScreen(track, holder)
          }
      } else if(track.kind == 'audio'){
        holder.appendChild(track.attach())
        this.participantMicrophoneOn = true
      }
      this.pub()
    }).bind(this)



    this.attachSharedScreen = (function(track, holder){
      var e2 = document.createElement('div');

      // attach resizer.
      var resizerButton = document.createElement('span')
      resizerButton.classList.add('resize-window-button')
      WindowUtil.attachResizer(e2,resizerButton)
      e2.appendChild(resizerButton)

      // attach fullscreen button.
      var fullScreenButton = document.createElement('button')
      fullScreenButton.classList.add('toggle-fullscreen-share-button')
      fullScreenButton.innerHTML = 'Toggle Fullscreen'
      var self = this
      fullScreenButton.onclick = function(event){
        WindowUtil.toggleFullscreen(e2)
      }
      e2.appendChild(fullScreenButton)

      e2.classList.add('screen-video-track')
      e2.appendChild(track.attach());
      WindowUtil.makeDragable(e2)
      holder.appendChild(e2)
      this.participantScreenOn = true
    }).bind(this)






    this.isParticipantsScreenShared = function(){
      return this.participantScreenOn
    }


      // Log any Participants already connected to the Room
    this.showParticipantsAlreadyConnected = (function(room){
      var self = this
      room.participants.forEach(function(participant){
        console.log("Participant " + participant.identity + " is connected to the Room");
        self.setParticipant(participant)
        self.attachAudioTrack()
        // show  media tracks of already connected participants
        participant.tracks.forEach(function(publication){
              if (publication.track) {
                self.appendToMediaTrackHolder(track)
              }
            });
            participant.on('trackUnsubscribed',self.onParticipantTrackUnsubscribed);
            participant.on('trackSubscribed', track => {
              self.appendToMediaTrackHolder(track)
            });
      });
    }).bind(this)


    /**
      When the other person stops their camera
      this gets fired and ensures that the attached video
      element is removed.
    */
    this.onParticipantTrackUnsubscribed = (function(track){
      if(track.name == 'camera'){
        $('#camera-video-holder').find('video').remove()
        this.participantCameraOn = false

      } else if (track.kind == 'video'){
        $('.screen-video-track').remove()
        this.participantScreenOn = false
      }
      else if (track.kind == 'audio'){
        this.participantMicrophoneOn = false
      }

      this.pub()
    }).bind(this)


    this.getCurrentParticipant = function(){
      return this.currentParticipant
    }

    this.setParticipant = function(p){
        this.waitingForPalToJoin = false
      if(this.roomInviter && this.roomInviter.getId() == p.identity){
        this.currentParticipant = this.roomInviter
      } else if(this.focusedPerson && this.focusedPerson.getId() == p.identity){
        this.currentParticipant = this.focusedPerson
      }else{
        throw new Error('expected participant to be either inviter or focusedPerson.')
      }
    }


    this.attachAudioTrack = (function(callback){
      var LocalAudioTrack = this.twilio.LocalAudioTrack;
      var self = this
      return navigator.mediaDevices.getUserMedia({audio:true}).then(function(stream){
        var microphoneTrack = new LocalAudioTrack(stream.getTracks()[0]);
        self.room.localParticipant.publishTrack(microphoneTrack);
        self.sharingMicrophone = true
        if(typeof callback == 'function') callback()
      }).catch(function(err){
        alert(err.message)
      })
    }).bind(this)



    this.shareMicrophone = (function(){
      if(!this.isSharingMicrophone()){
          var self = this
          this.attachAudioTrack().then(function(){
              self.pub()
          })
      }
    }).bind(this)
    this.dis.reg('unmuteMicrophone', this.shareMicrophone)



    this.onParticipantConnected = (function(participant){
      console.log('Participant ' + participant.identity + ' is connected to the Room');
      this.attachAudioTrack()
      this.updateParticipantCount(this.room)
      this.setParticipant(participant)

      participant.tracks.forEach(publication => {
        if (publication.isSubscribed) {
          var track = publication.track;
          this.appendToMediaTrackHolder(track)
        }
      });
      participant.on('trackSubscribed', track => {
        this.appendToMediaTrackHolder(track)
      });
      participant.on('trackUnsubscribed',this.onParticipantTrackUnsubscribed)
      this.pub()
    }).bind(this)




    this.onParticipantDisconnected = (function(participant){
        console.log("Participant " + participant.identity + " has disconnected from the Room");
        this.stopMicrophoneTrack()
        this.stopCameraTrack()
        this.stopScreenShareTrack()
        this.currentParticipant = null
        this.removeMediaDivs()
        this.updateParticipantCount(this.room)
        this.pub()
    }).bind(this)


    this.stopMicrophoneTrack = (function(){
      if(this.room){
        this.room.localParticipant.tracks.forEach(function(publication){
          if(publication.track.kind == 'audio'){
            publication.track.stop()
            publication.unpublish() // stop sharing audio with the room.
            console.log('microphone muted')
          }
        });
        this.sharingMicrophone = false
        this.pub()
      }
    }).bind(this)
    this.dis.reg('muteMicrophone',this.stopMicrophoneTrack)


    this.isSharingMicrophone = function(){
      return this.sharingMicrophone
    }




    this.isSharingCamera = function(){
      return this.sharingCamera
    }

    this.stopCameraTrack = (function(){
      var self = this
      if(this.room)
      this.room.localParticipant.tracks.forEach(function(publication){
        if(publication.track.name == 'camera'){
          publication.track.stop()
          publication.unpublish() // stop sharing with the room.
          $('#camera-preview').empty()
          self.sharingCamera = false
          self.pub()
        }
      });
    }).bind(this)
    this.dis.reg('stopCamera',this.stopCameraTrack)


    this.stopScreenShareTrack = (function(){
      var room = this.getRoom()
      var self = this
      room.localParticipant.tracks.forEach(function(publication){
        if(publication.track.name != 'camera' && publication.track.kind == 'video' ){
          publication.track.stop() // stop it.
          publication.unpublish() // stop sharing with the room.
          self.sharingScreen = false
          self.pub()
        }
      });
    }).bind(this)
    this.dis.reg('stopSharingScreen',this.stopScreenShareTrack)

    this.onDisconnect = (function(room){
      if(room){
        this.stopMicrophoneTrack()
        this.stopScreenShareTrack()
        this.stopCameraTrack()
      }
      this.removeMediaDivs()
      this.room = null
      this.roomInviter = null
      this.isRoomVisible = false
      this.sharingScreen = false
      this.pub()
    }).bind(this)


    this.removeMediaDivs = (function(){
      document.getElementById('remote-media-holder').innerHTML = ''
    }).bind(this)


    this.disconnect = (function(){
      if(this.room){
        this.room.disconnect();
      }
    }).bind(this)
    this.dis.reg('leaveRoom',this.disconnect)
    window.addEventListener('beforeunload',this.disconnect);

    this.onRoomError =  (function(error){
      console.log(error)
      if(/Invalid Access Token/.test(error.message)){
        alert('Video access has been disabled.  Please contact use at 905-808-8791 and we will fix it quickly.')
      }
      else if(/Permission denied/.test(error.message)){
        alert('Please change your browsers permissions\nto allow microphone or webcam access.')
      }
      else if(/Could not start video source/.test(error.message)){
        alert('Video could not start\nCheck that your camera is not already in use.')
      }
      else if(/NotFoundError/.test(error.message)){
        alert('No webcam or microphone detected\nPlease ensure either your webcam or microphone are enabled.')
      }
      else{
        alert('Video calling is currently not working.\n  Please contact support at 905-808-8791 and we will fix it quickly.')
      }
      this.receivingRoomInvite = false
      this.isRoomVisible = false
      this.disconnect()
      this.pub()
     }).bind(this)



  } // end

    return {
      getInstance:function(){
        if(!instance){
          instance = new VideoStore();
        }
        return instance;
      },
      getNew:function(){
        return new VideoStore();
      }
    }
  })
;

define('video-chat/Component',['ko',
        'text!video-chat/template.html',
        'video-chat/VideoStore',
        'dispatcher/Dispatcher',
        'window-utilities'],
function(ko,
         template,
         Store,
         Dispatcher,
         WindowUtil){

  function ViewModel(params, componentInfo){
    this.dis = new Dispatcher()
    this.store = Store.getInstance()
    this.isVisible = ko.observable(false)
    this.participants = ko.observable(0)
    this.focusedPersonsName = ko.observable('name')
    this.participantsName = ko.observable('')
    this.showCallingRecipient = ko.observable(false)
    this.showWaitingForPalToJoin = ko.observable(false)
    this.isParticipantsCameraOn = ko.observable(false)
    this.isSharingMicrophone = ko.observable(false)
    this.isSharingScreen = ko.observable(false)
    this.isSharingCamera = ko.observable(false)
    this.mediaCenterOpenedAtLeastOnce = false
    this.isSpinnerVisible = ko.observable(false)
    this.isPalOnline = ko.observable(false)
    this.isPalHungupVisible = ko.observable(false)
    this.isParticipantMicrophoneOn = ko.observable(false)


    this.onStore = (function(){
      this.isParticipantMicrophoneOn(this.store.isParticipantMicrophoneOn())
      this.isPalHungupVisible(this.store.isPalHungupVisible())
      this.isSpinnerVisible(this.store.showSpinner())
      var online = this.store.isFocusedPersonOnline()

      this.isPalOnline(online)
      if(!this.store.isVideoChatDown()){
        this.isVisible(this.store.isRoomWindowOpen())
        if(this.store.isRoomWindowOpen() && this.mediaCenterOpenedAtLeastOnce == false){
          this.mediaCenterOpenedAtLeastOnce = true
          var e = document.getElementById('video-chat-control-center')
          WindowUtil.makeDragable(e)
        }
        this.isSharingMicrophone(this.store.isSharingMicrophone())
        this.isSharingScreen(this.store.isSharingScreen())
        this.isSharingCamera(this.store.isSharingCamera())
        this.isParticipantsCameraOn(this.store.isParticipantsCameraOn())
        this.participants(this.store.getParticipantCount())
        var participant = this.store.getCurrentParticipant()
        if(participant){
          this.participantsName(participant.getFirst() + ' ' + participant.getLast())
        }
        this.focusedPersonsName(this.store.getFocusedPersonsName())
        this.showWaitingForPalToJoin(this.store.isWaitingForPalToJoin())
      } else {
        var m = 'Sorry, video chat is currently not working.\n please try again later.'
        alert(m)
      }
    }).bind(this)
    this.store.sub(this.onStore)



    this.download = (function(){
      this.dis.dispatch('downloadSessionRecording')
    })

    this.openSessionTracker = (function(){
      var isTutor = this.store.isCurrentUserTutor();
      this.dis.dispatch('openSessionTracker',isTutor)
    }).bind(this)


    this.attachResizers = function(testing){
      var controlCenter = document.getElementById('video-chat-control-center')
      var resizer = document.getElementById('control-center-resizer')
      WindowUtil.attachResizer(controlCenter, resizer, {
        'min-width':454,
        'min-height':341
      })
    }
    this.attachResizers()


    this.onStopResize = (function(vm, event){
      event.stopPropagation()
    }).bind(this)


    this.invitePal = (function(){
      var palId = this.store.getPalId()
      this.dis.dispatch('invitePalToRoom',palId)
    }).bind(this)


    this.isScreenSharingSupported = function(){
      if(navigator.mediaDevices.getDisplayMedia)
          return true
        else
          return false
    }


    this.shareScreen = (function(){
      var isSharingAlready = this.store.isSharingScreen()
      if(isSharingAlready) return
      var self = this
      if(this.isScreenSharingSupported()){
        self.dis.dispatch('shareScreen')
      }else{
        alert('Please upgrade your browser to its latest versions to support screen share.')
      }
    }).bind(this)


    this.stopScreenShare = (function(){
      this.dis.dispatch('stopSharingScreen')
    }).bind(this)

    this.shareVideo = (function(){
      this.dis.dispatch('shareVideo')
    }).bind(this)

    this.stopCamera = (function(){
      this.dis.dispatch('stopCamera')
    }).bind(this)


    this.toggleMicrophone = (function(){
      if(this.store.isSharingMicrophone())
        this.dis.dispatch('muteMicrophone')
      else
        this.dis.dispatch('unmuteMicrophone')
    }).bind(this)


    this.disconnect = (function(){
      var palId = this.store.getFocusedPersonsId()
      this.dis.dispatch('leaveRoom', palId)
    }).bind(this)

    window.onunload = this.disconnect


  }; // end viewModel.

  return {
    viewModel: ViewModel,
    template : template
  }


});


define('text!video-chat/incoming-call/template.html',[],function () { return '<link rel="stylesheet"\n      href="./styles/components/video-chat/incoming-call.css?v=1.1">\n\n<div class=\'background-dimmer\'\n     data-bind=\'visible:isVisible()\'\n       id=\'incoming-call-holder\'>\n\n       <div id=\'incoming-call-box\'>\n         <img id=\'caller-photo\'\n              data-bind=\'attr:{src:invitersPhoto()}\'>\n         </img>\n         <div id=\'caller-message\'>\n            <span id=\'inviters-name\'\n                  data-bind="text:invitersName()">\n            </span>\n            has invited you to join a room.\n         </div>\n         <button id=\'call-answer-button\'\n                 data-bind=\'click:join\'>\n                 Join With Computer Audio\n          </button>\n       </div>\n</div>\n';});


define('video-chat/incoming-call/Component',['ko',
        'text!video-chat/incoming-call/template.html',
        'video-chat/VideoStore',
        'dispatcher/Dispatcher'],

function(ko,
         template,
         Store,
         Dispatcher){

  function View(){
      this.dis = new Dispatcher()
      this.store = Store.getInstance()
      this.isVisible = ko.observable(false)
      this.invitersName = ko.observable('')
      this.invitersPhoto = ko.observable('')
      this.audio = new Audio('./assets/audio/cutering.mp3');

      this.onStore = (function(){
        var isBeingInvited = this.store.isReceivingRoomInvite()
        this.isVisible(isBeingInvited)
        if(isBeingInvited){
            var inviter = this.store.getRoomInviter()
            this.invitersName(inviter.getFirst() + ' ' + inviter.getLast())
            this.invitersPhoto(inviter.getLargePhotoURL())
            this.startRinging()
        }else{
          this.stopRinging()
        }
      }).bind(this)
      this.store.sub(this.onStore)

      this.startRinging = function(){
        this.audio.loop = true;
        this.audio.play();
      }

      this.stopRinging = function(){
        this.audio.pause();
        this.audio.currentTime = 0;
      }

      this.join = (function(){
        this.stopRinging()
        var p = this.store.getRoomInviter()
        this.dis.dispatch('joinRoom',p.getId())
      }).bind(this)

  }; // end viewModel.

  return {
    viewModel: View,
    template : template
  }


});


define('text!blackboard/template.html',[],function () { return '<link rel="stylesheet" href="./styles/components/blackboard/style.css?v=2.1"></link>\n<div id="blackboard-holder"\n     draggable="false">\n\n  <div id="blackboard-background"\n       class=\'background-dimmer\'\n       data-bind="visible:blackboardOpen(), click:toggleVisibility">\n  </div>\n\n\n  <div id="hideable-area"\n       data-bind="visible:blackboardOpen()">\n\n     <div id="board-trashed-message"\n           data-bind="visible:isTrashedMessageVisible()">\n       Your classmate deleted the board.\n     </div>\n\n\n     <div id="left-tool-bar" class="tool-bar">\n       <button\n               class="top-board-buttons tool-button glyphicon glyphicon glyphicon-trash"\n               data-bind="click:trashCurrentBoard"\n               data-toggle="tooltip"\n               title="Delete board.">\n       </button>\n       <button id="board-undo-button"\n               class="fa fa-undo tool-button top-board-buttons"\n               data-toggle="tooltip"\n               title="Undo delete."\n               data-bind="visible:recentlyTrashedBoards().length > 0, click:undoTrashBoard">\n       </button>\n     </div>\n\n\n    <div id="center-tool-bar"\n         class="tool-bar">\n    <div id=\'blackboard-colors\'>\n      <button id=\'blackboard-blue\'\n              class=\'blackboard-color-picker\'\n              data-bind=\'click:selectBlue\'>\n      </button>\n      <button id=\'blackboard-pink\'\n              class=\'blackboard-color-picker\'\n              data-bind=\'click:selectPink\'>\n      </button>\n      <button id=\'blackboard-yellow\'\n              class=\'blackboard-color-picker\'\n              data-bind=\'click:selectYellow\'>\n      </button>\n      <button id=\'blackboard-green\'\n              class=\'blackboard-color-picker\'\n              data-bind=\'click:selectGreen\'>\n      </button>\n    </div>\n    <button\n            data-bind="click: setPencilTool"\n            class="tool-button glyphicon glyphicon-pencil"\n            data-toggle="tooltip"\n            data-placement="top"\n            title="Pencil" >\n    </button>\n    <button class="tool-button glyphicon glyphicon-erase"\n            data-bind="click:setEraserTool"\n            data-toggle="tooltip"\n            data-placement="top"\n            title="Eraser">\n    </button>\n    </div>\n\n    <div id="right-tool-bar" class="tool-bar">\n      <div id=\'blackboard-sharing-options\'\n           data-bind=\'visible:isEmailOptionsOpen()\'>\n        <input type=\'text\' placeholder=\'Subject\' data-bind=\'textInput:emailBoardTitle\'></input>\n        <textarea id=\'shared-blackboard-message\'\n                  data-bind=\'textInput:emailBoardMessage\'>\n        </textarea>\n        <button id=\'send-blackboards\'\n                class=\'purple-button\'\n                data-bind=\'click:emailBoard\'>\n                <span data-bind=\'!isWaitingForEmail()\'>SEND</span>\n                <span class=\'nano-spinner\' data-bind=\'visible:isWaitingForEmail()\'></span>\n                <span data-bind=\'visible:showEmailCheckmark()\' id=\'okay-message\' class=\'glyphicon glyphicon-ok\'></span>\n        </button>\n      </div>\n      <button\n              id=\'blackboard-email-button\'\n              class="top-board-buttons tool-button glyphicon glyphicon-envelope"\n              data-toggle="tooltip"\n              data-bind=\'click:openEmailWindow\'\n              title="Email board">\n      </button>\n      <button\n              id=\'blackboard-fullscreen-button\'\n              class="top-board-buttons tool-button glyphicon glyphicon-fullscreen"\n              data-toggle="tooltip"\n              title="Toggle fullscreen">\n      </button>\n\n    </div>\n\n\n\n    <!-- spinner -->\n    <div  class="screen-center-outer">\n     <div class="screen-center-inner">\n        <div id="blackboard-loader"\n             class="loader"\n             data-bind="visible:spinnerVisible()"></div>\n     </div>\n   </div>\n\n    <span class="blackboard-btn blackboard-prev-btn glyphicon glyphicon-menu-left"\n          data-toggle="tooltip"\n          title="Previous board"\n          data-bind="visible:prevArrowVisible(), click:prevArrowClicked">\n    </span>\n      <canvas id="tool-area"\n               width="1864"\n               height="980">\n      </canvas>\n      <canvas id=\'drawing-area\'\n              width=1864\n              height=980>\n      </canvas>\n      <span class="blackboard-btn blackboard-next-btn glyphicon glyphicon-menu-right"\n            data-toggle="tooltip"\n            title="Next board"\n            data-bind="click:nextArrowClicked">\n      </span>\n  </div>\n<!-- END hideable area -->\n\n\n    <!-- toggle open / close blackboard  -->\n    <div id="blackboard-toggle-button-holder" data-bind="visible:isToggleVisible()">\n      <button id="blackboard-toggle-button"\n              data-toggle="tooltip"\n              title="Chalkboard"\n              data-bind="click:toggleVisibility, visible:!blackboardOpen()"\n              class="blackboardButton glyphicon">\n      </button>\n      <span data-bind="visible:blackboardOpen()"\n            class="blackboard-toggle-button-arrow glyphicon glyphicon-menu-up"></span>\n      <span data-bind="visible:!blackboardOpen()"\n            class="blackboard-toggle-button-arrow glyphicon glyphicon-menu-down"></span>\n    </div>\n\n</div>\n';});

define('blackboard/BlackboardRemoteService',['jquery',
        'ActiveRemoteService'],
function($,
         ActiveRemoteService){

    var BlackboardRemoteService = function(){

      Object.setPrototypeOf(this, new ActiveRemoteService());
      this._callbacks = {};
      this.lastBoardDataRequest = null;
      this.setMicroServer("blackboard");


      this.initialize = (function(){
        this.setSock()
        this.sock.on('io_error', this.onError)
        this.sock.on('friendAddedNewBoard',this.onFriendAddedNewBoard)
      }).bind(this)

      this.onFriendAddedNewBoard = (function(board){
         this.dis.dispatch('friendAddedNewBoard',JSON.parse(board))
      }).bind(this)


      this.onError = (function(message){
        alert(message)
      }).bind(this)

      this.attachFriendJoinedBlackboardHandler = (function(callback){
        this.sock.on('friendJoinedBlackboard',callback);
      }).bind(this)


      this.emailBlackboard = (function(args, ack){
        this.sock.emit('emailBlackboard',args, ack)
      }).bind(this)

      this.getBoardData = (function(boardId, ack){
          this.sock.emit('getBoard',boardId, ack)
      }).bind(this)


      this.saveCurrentBoard = (function(currentBoard){
        var ack =  this._callbacks['onSaveCallback'];
        if(typeof ack != 'function') throw new Error('saveCurrentBoard callback missing.');
        var json = JSON.stringify(currentBoard);
        this.sock.emit('saveBoardState', {json:json}, ack);
      }).bind(this)


      this.registerOnSaveCallback = (function(callback){
        if(typeof callback != 'function'){
          throw new Error("Save board callback needs to be a function.");
        }
        this._callbacks['onSaveCallback'] = callback;
      }).bind(this)



      /**
       * Requests the last board the current user viewed from the set of
       * boards that are shared with friendId.
       * @param  {Number} friendId The id number of the currently selected friend.
       */
      this.getSharedBoards = (function(friendId){
        if(isNaN(friendId) || friendId < 1){
          throw new Error('friendId must be a positive integer.');
        }
        var onSuccess = this._callbacks['onSharedBoardsReceived'];
        if(typeof onSuccess != 'function'){
          throw new Error('onSharedBoardsReceived callback has not been registered.');
        }
        if(!this.sock._callbacks['$sharedBoards']){
          this.sock.on('sharedBoards',this._callbacks['onSharedBoardsReceived'])
        }
        this.sock.emit('getSharedBoards',{friendId:friendId})
      }).bind(this)


      this.getNextBoard = (function(boardId,friendId){
        this.sock.emit('nextBoard', {boardId:boardId, friendId:friendId})
      }).bind(this)


      this.registerOnNextBoardRecievedCallback = (function(callback){
          this.sock.on('nextBoardReceived',callback)
      }).bind(this)




      this.joinFriend = function(friendId, currentTool){
        if(this.sock){
          var data = {
                      friendId:friendId,
                      currentTool:currentTool
                     };
          this.sock.emit('joinRoom',data,function(result){
            if(result == 'success'){
              // console.log('Blackboard:Connected to friend:' + friendId);
            }
          });
        }
      }

      this.getPreviousBoard = (function(boardId,friendId){
        this.sock.emit('previousBoard',{boardId:boardId, friendId:friendId})
      }).bind(this)


      this.registerOnPreviousBoardRecievedCallback = (function(cb){
        this.sock.on('previousBoardReceived', cb)
      }).bind(this)




      /**
      * @param  {Function} callback The function to be executed on successful retrieval
      *                             of the board. It is passed the board data.
      */
      this.registerGetSharedBoardsCallback = function(callback){
        this._callbacks['onSharedBoardsReceived'] = callback;
      }

      this.getAdditionalBoardData = (function(boardId, ack){
        this.sock.emit('getAdditionalBoardData',boardId, ack)
      }).bind(this)

      this.emitMyCursorPosition = function(update,onSuccess){
        this.sock.emit('myCursorPosition',update,function(result){
          if(result == 'success'){
            onSuccess();
          }
        });
      }

      this.attachOnFriendCursorPositionReceivedHandler = (function(callback){
        this.sock.on('friendsCursorPosition',callback);
      }).bind(this)

      this.emitMyPencilPosition = (function(update){
        this.sock.emit('myPencilPosition',update);
      }).bind(this)

      this.attachOnFriendPencilPositionCallback = (function(callback){
        this.sock.on('friendPencilPositionUpdate',callback);
      }).bind(this)

      this.emitMyPencilLine = (function(pencilLine,onSuccess){
        this.sock.emit('myPencilLine',pencilLine,onSuccess);
      }).bind(this)

      this.attachFriendsPencilLineUpdateHandler = (function(callback){
        this.sock.on('friendsPencilLineUpdate',callback);
      }).bind(this)

      this.emitMyEraserPosition = (function(update){
        this.sock.emit('myEraserPosition', update);
      })

      this.attachOnFriendsEraserPositionUpdateCallback = (function(cb){
        this.sock.on('onFriendsEraserPositionUpdate',cb);
      }).bind(this)

      this.emitMyEraserDown = (function(erase, ack){
        this.sock.emit('myEraserDown',erase, ack);
      }).bind(this)

      this.attachFriendsEraserDownCallback = (function(callback){
        this.sock.on('friendsEraserDownUpdate',callback);
      }).bind(this)

      this.registerOnBoardTrashedCallback = (function(callback){
        this.checkType(callback);
        this.sock.on('boardTrashed', callback)
      }).bind(this)

      this.registerOnFriendTrashedBoard = function(callback){
        this.checkType(callback);
        this.sock.on('boardTrashed',callback);
      }

      this.trashBoard = (function(boardId, friendId){
        var o = {friendId:friendId, boardId:boardId}
        this.sock.emit('trashBoard',o)
        this.sock.emit('relayTrashBoard',o);
      }).bind(this)

      this.registerOnTrashBoardUndone = (function(callback){
        this.checkType(callback);
        this.sock.on('boardRestored', callback)
      }).bind(this)

      this.undoTrashBoard = (function(boardId, friendId){
         var o = {friendId:friendId, boardId:boardId}
         this.sock.emit('restoreBoard',o)
         this.sock.emit('relayRestoreBoard',o);
      }).bind(this)

      this.registerOnFriendRestoredBoard = (function(callback){
        this.sock.on('friendsBoardRestored',callback);
      }).bind(this)

      this.checkType = function(fn){
        if(typeof fn != 'function'){
          throw new Error("Callback must be a function");
        }
      }

    }

    return BlackboardRemoteService;
});

define('blackboard/canvas/Layer',[],function(){

    var Context = function(viewModel){

      this.getDefaultStroke = function(){
        return '#ffffff'
      }

      this.setupCanvas = function(){
        var id = this.getLayerId();
        this._canvas = document.getElementById(id);
        if(!this._canvas){
          throw new Error('html template is missing canvas with id ' + id);
        }
        var $canvas = $(this._canvas);
        var tagName = $canvas.prop('tagName');
        if(tagName != 'CANVAS'){
          throw new Error("tag must be a canvas element");
        }
        this._context = this._canvas.getContext('2d');
      }

      this.getContext = function(){
        return this._context;
      }

      this.getCanvas = function(){
        return this._canvas;
      }

      this.clear = function(){
        if(!this._canvas)
          throw new Error('Canvas not set.');
        var w = this._canvas.width;
        var h = this._canvas.height;
        this._context.clearRect(0, 0, w, h);
      }

      this.getLayerId = function(){
        throw new Error('cannot call abstract function.');
      }

      this.normalizedToCanvasCoordinates = function(point){
        var width = this.getCanvas().width;
        var height = this.getCanvas().height;
        return {
          x:point.x * width,
          y:point.y * height
        }
      }

      this.getCurrentPosition = function(e){
        var leftOffset = $(this._canvas).offset().left;
        var topOffset = $(this._canvas).offset().top;
        var width = $(this._canvas).width();
        var height = $(this._canvas).height();
        return {
                    x: (e.clientX - leftOffset) / width,
                    y: (e.clientY - topOffset) / height
                }
      }


      this.getHeight = function(){
        return this._canvas.height;
      }

      this.setHeight = function(height){
        if(!height){
          // console.warn('height must be a positive number.')
          return;
        }
        this._canvas.style.height = height + 'px';
      }

      this.getWidth = function(){
        return this._canvas.width;
      }

      this.setWidth = function(width){
        this._canvas.style.width = width + 'px';
      }


      

    }
    return Context;
});

define('blackboard/canvas/ToolLayer',['blackboard/canvas/Layer'],
function(Layer){

    var ToolLayer = function(viewModel){

      Object.setPrototypeOf(this, new Layer());
      this._layerId = 'tool-area';

      this.getLayerId = function(){
        return this._layerId;
      }
      this.setupCanvas.call(this);
      this.getCurrentPosition = this.getCurrentPosition.bind(this);
      this._context.font = "39px Arial";
      this._context.fillStyle = "#828282";
      this._context.zIndex = "5";


      this.drawEraserCircle = function(radius, point){
        var cPoint = this.normalizedToCanvasCoordinates(point);
        var screenRadius = radius * this.getCanvas().width;
        var initialAngle = 0;
        var terminalAngle = 2 * Math.PI;
        this.clear();
        this._context.lineWidth   = "4";
        this._context.strokeStyle = "#dfffff";
        this._context.beginPath();
        this._context.arc(cPoint.x, cPoint.y, screenRadius, initialAngle, terminalAngle);
        this._context.stroke();
      }

      this.drawFriendsCursor = function(point){
        var url = './assets/cursor_friend_small.png';
        this.drawImage(point, 0, url);
      }

      this.drawFriendLeftMarker = function(y){
        var canvasHeight = this._canvas.height;
        var y = y * canvasHeight;
        var left = 20; // pixels.
        this.clear();
        this._context.fillText("<- Friend",  left, y);
      }

      this.drawFriendRightMarker = function(y){
        var canvasHeight = this._canvas.height;
        var y = y * canvasHeight;
        var right = 180;
        this.clear();
        this._context.fillText("Friend ->", this._canvas.width - right, y);
      }

      this.drawFriendsPencil = (function(line){
          var point = {x:line.x0,y:line.y0}
          var url = './assets/friends_pencil.png';
          var verticalOffset = -67;
          this.drawImage(point, verticalOffset, url);
      }).bind(this)


      this.drawFriendsEraser = function(point){
        var url = './assets/eraser_friend.png';
        var verticalOffset = -45;
        this.drawImage(point, verticalOffset, url);
        // this.drawEraserCircle(radius, point);
      }

      this.drawImage = function(point, yOffset, imgURL){
        var image = new Image();
        image.src = imgURL;
        var canvasPoint = this.normalizedToCanvasCoordinates(point);
        var x = canvasPoint.x;
        var y = canvasPoint.y;
        this.clear();
        this.getContext().drawImage(image,x,y + yOffset);
      }






    }
    return ToolLayer;
});

define('blackboard/canvas/DrawingLayer',['blackboard/canvas/Layer'],
function(Layer){

    var DrawingLayer = function(){

      Object.setPrototypeOf(this, new Layer());
      this._layerId = 'drawing-area';

      this.getLayerId = function(){
        return this._layerId;
      }
      // ensures that 'this' in setupCanvas refers to this DrawingLayer.
      // and that _context and _cavas are visible in this Layer.
      this.setupCanvas.call(this);
      this.getCurrentPosition = this.getCurrentPosition.bind(this);
      this.getCanvas().oncontextmenu = function(){
        return false;
      }

      this.getPNG = function(){
        return document.getElementById(this.getLayerId()).toDataURL('image/png')
      }

      this.drawOntoBoard = function(commands){
        this._context.lineWidth   = "4";
        this._context.strokeStyle = this.getDefaultStroke()
        var data = commands;
        for(var i = 0; i < data.length; i++){
          var e = data[i]
          if(!e || !e.isLine){
            throw new Error('Unrecognized command:' + e)
          }else if(!e.isLine()){
            this.eraseArea(e);
          }else if(e.isLine()){
            this.drawLine(e);
          } else {
            throw new Error('Unrecognized command:' + e)
          }
        } // end loop.
      }

      this.drawEntireBoard = function(commands){
        this.clear();
        this.drawOntoBoard(commands)
      }

      this.eraseArea = function(erase){
        this._context.beginPath();
        var startAngle = 0;
        var endAngle = 2 * Math.PI;
        var p = this.normalizedToCanvasCoordinates(erase);
        var screenRadius = erase.getRad() * this.getWidth();
        this._context.arc(p.x, p.y, screenRadius, startAngle, endAngle);
        this._context.fillStyle = 'black';
        this._context.fill();
      }

      /**
        Draws a single line. i.e two points
        and a line between them.
      **/
      this.drawLine = function(line){
        var color = line.getColor()
        this._context.strokeStyle = color
        var width = this.getWidth();
        var height = this.getHeight();
        this._context.beginPath();

        var startX = line.x0 * width;
        var startY = line.y0 * height;
        this._context.moveTo(startX, startY);

        var endX = line.x1 * width;
        var endY = line.y1 * height;
        this._context.lineTo(endX,endY);
        this._context.stroke();
      }



    }
    return DrawingLayer;
});

define('blackboard/models/Line',[],
function(){

  var Line = function(data){

    this.boardId = null
    this.friendId = null




    this.setColor = function(color){
      this.color = color
    }
    this.setColor(data.color)

    this.getColor = function(){
      return this.color
    }

    this.isLine = function(){
      return true
    }

    this.isBoardable = function(){
      return true
    }

    this.getColor = function(){
      return this.color
    }

    this.getBoardId = function(){
      return this.boardId
    }

    this.setBoardId = function(id){
      this.boardId = id
    }
    this.setBoardId(data.board_id)

    this.isOnBoard = function(otherId){
      return this.boardId == otherId
    }

    this.getFriendId = function(){
      return this.friendId
    }

    this.setFriendId = function(id){
      this.friendId = id
    }
    this.setFriendId(data.friend_id)

    this.isFrom = function(id){
      return this.friendId == id
    }

    this.checkKind = function(kind){
      if(kind != 'line')
        throw new Error('kind was expected to be of type line.')
    }
    this.checkKind(data.kind)

    this.getEndPoint = function(){
      var self = this
      return {
        getX:function(){
          return self.getEndX()
        },
        getY:function(){
          return self.getEndY()
        }
      }
    }

    this.getStartX = function(){
      return this.x0
    }

    this.setStartX = function(x0){
      this.x0 = x0
    }
    this.setStartX(data.x0)


    this.getStartY = function(){
      return this.y0
    }

    this.setStartY = function(y0){
      this.y0 = y0
    }
    this.setStartY(data.y0)

    this.getEndX = function(){
      return this.x1
    }

    this.setEndX = function(x1){
      this.x1 = x1
    }
    this.setEndX(data.x1)


    this.getEndY = function(){
      return this.y1
    }

    this.setEndY = function(y1){
      this.y1 = y1
    }
    this.setEndY(data.y1)


    this.serialize = function(){
      return {
        color:this.color,
        x0:this.x0,
        y0:this.y0,
        x1:this.x1,
        y1:this.y1,
        kind:'line',
        board_id:this.getBoardId(),
        friend_id:this.getFriendId()
      }
    }
  } // end

  Line.WHITE = '#ffffff'

  Line.getDefaultColor = function(){
    return Line.WHITE
  }

  Line.getRaw = function(){
    return {color:'#ffffff',board_id:6, friend_id:7, x0:2, y0:3, x1:4, y1:5, kind:'line'}
  }

  Line.getFake = function(){
    var r = Line.getRaw()
    return new Line(r)
  }


  return Line;

});

define('blackboard/canvas/Canvas',['blackboard/canvas/ToolLayer',
        'blackboard/canvas/DrawingLayer',
        'blackboard/models/Line',
        'window-utilities'],
  function(ToolLayer,
           DrawingLayer,
           Line,
           WindowUtils){

    var Canvas = function(viewModel){

      if(!viewModel || typeof viewModel.setMyCursorPosition != 'function'){
        throw new Error('Canvas must have a board collection injected.');
      }
      this.viewModel = viewModel;
      this.toolLayer = new ToolLayer();
      this.drawingLayer = new DrawingLayer();
      this._drawingCanvas = this.drawingLayer.getCanvas();

      this.HIDEABLE_AREA_ID = 'hideable-area'
      this.mouseDown = false;
      this.LEFT_MOUSE_BUTTON = 0;
      this.RIGHT_MOUSE_BUTTON = 2;


      this.initialize = function(){
        var $b = $('#blackboard-fullscreen-button')
        this._hideableArea = document.getElementById(this.HIDEABLE_AREA_ID);
        $b.on('click',this.makeFullScreen)
        $(window).on('resize',this.resizeBlackboard);
        this.initMouseListeners();
      }

      this.makeFullScreen = (function(){
        WindowUtils.toggleFullscreen(this._hideableArea)
      }).bind(this)


      this.clear = function(){
        this.toolLayer.clear();
      }
      this.clear = this.clear.bind(this);

      this.mouseMoveHandler = (function(e){
        var currentPosition = this.drawingLayer.getCurrentPosition(e);

        var tool = this.viewModel.getMyCurrentTool();
        this.toolLayer.clear();

        if(tool == 'cursor'){
          this.viewModel.setMyCursorPosition(currentPosition);
        }
        else if(tool == 'eraser'){
          var radius = this.viewModel.ERASER_RADIUS;
          this.drawEraserCircle(radius, currentPosition);
          if(this.mouseDown == false){
             this.viewModel.setMyEraserPosition(currentPosition);
          }else{
            this.viewModel.setMyEraserDown(currentPosition);
            this.viewModel.startSaveCountDown();
          }
        }
        else if(tool == 'pencil'){

          if(this.mouseDown == false){
            this.viewModel.setMyPencilPosition(currentPosition);
          }
          else{

            this.possiblyDrawLine(currentPosition);
          }
        }
      }).bind(this)


      /**
       * Only does a draw line request if the first point
       * of the line has been set.
       * @param  {[type]} currentMousePosition
       */
      this.possiblyDrawLine = (function(currentMousePosition){
        if(!currentMousePosition){
          throw new Error('currentMousePosition must be an object with a x and y coordinate.');
        }
        if(!this.previousPosition){
          this.previousPosition = currentMousePosition;
        } else {
          this.viewModel.startSaveCountDown();
          var x0 = this.previousPosition.x
          var y0 = this.previousPosition.y
          var x1 = currentMousePosition.x
          var y1 = currentMousePosition.y
          var raw = {kind:'line',x0:x0,y0:y0,x1:x1,y1:y1}
          var l = new Line(raw)
          this.viewModel.setMyPencilLine(l);
          this.previousPosition = currentMousePosition;
        }
      }).bind(this)




      this.mouseDownHandler = function(event){
        this.mouseDown = true;
        if(event.button == this.RIGHT_MOUSE_BUTTON){
          this.viewModel.setEraserTool();
        }
      }
      this.mouseDownHandler = this.mouseDownHandler.bind(this);


      this.mouseUpHandler = function(event){
        this.mouseDown = false;
        this.previousPosition = null;
        if(event.button == this.RIGHT_MOUSE_BUTTON){
          this.viewModel.setPencilTool();
        }
      }
      this.mouseUpHandler = this.mouseUpHandler.bind(this);

      /**
       * ensures that the tool does not "stick" down
       * when the users cursor leaves the black board.
       *
       * @param  {object} event
       */
      this.mouseLeaveHandler = function(event){

        if(this.mouseDown){
          var currentPosition = this.drawingLayer.getCurrentPosition(event);
          var tool = this.viewModel.getMyCurrentTool();

          if(tool == 'pencil'){
            this.mouseDown = false;
            this.possiblyDrawLine(currentPosition);
          }
          else if(tool == 'eraser'){
            this.mouseDown = false;
          }
          this.previousPosition = null;
        }
      }
      this.mouseLeaveHandler = this.mouseLeaveHandler.bind(this);

      /**
       * Absolutely needed to prevent accidentally draging items on the screen
       * when the user drags the the tool off from the board.
       * @param  {object} e event
       */
      this.dragStartHandler = function(e){
        e.preventDefault();
      }
      this.dragStartHandler = this.dragStartHandler.bind(this);


      this.initMouseListeners = function(){
        this._drawingCanvas.onmousemove = this.mouseMoveHandler;
        this._drawingCanvas.onmousedown = this.mouseDownHandler;
        this._drawingCanvas.onmouseup = this.mouseUpHandler;
        this._drawingCanvas.onmouseleave = this.mouseLeaveHandler;
        this._drawingCanvas.ondragstart = this.dragStartHandler;

      }
      this.initMouseListeners = this.initMouseListeners.bind(this);


      this.setMyToolToPencil = function(){
        this._drawingCanvas.style.cursor = "url('./assets/my_pencil.cur') 0 45,auto";
      }

      this.setMyToolToEraser = function(){
        this._drawingCanvas.style.cursor = "url('./assets/eraser_my.cur') 0 45,auto";
      }


      this.drawFriendsCursor = function(update){
          this.toolLayer.drawFriendsCursor(update.position);
      }
      this.drawFriendsCursor = this.drawFriendsCursor.bind(this);

      this.drawFriendsEraser = (function(erase){

        this.toolLayer.drawFriendsEraser(erase);
      }).bind(this)

      this.drawFriendsPencil = (function(pencil){
        this.toolLayer.drawFriendsPencil(pencil);
      }).bind(this)

      this.drawMyPencilLine = function(line){
        this.drawLine(line);
      }

      this.drawFriendsPencilLine = function(line){
        this.drawLine(line);
        this.drawFriendsPencil(line);
      }

      this.friendEraseArea = (function(erase){
        this.drawFriendsEraser(erase);
        this.eraseArea(erase);
      }).bind(this)


      this.getPNG = function(){
        return this.drawingLayer.getPNG()
      }


      this.eraseArea = (function(erase){
        this.drawingLayer.eraseArea(erase);
      }).bind(this)


      this.drawEraserCircle = function(radius, point){
        this.toolLayer.drawEraserCircle(radius, point);
      }

      this.drawFriendLeftMarker = function(y){
        this.toolLayer.drawFriendLeftMarker(y);
      }

      this.drawFriendRightMarker = function(y){
        this.toolLayer.drawFriendRightMarker(y);
      }

      this.resizeBlackboard = function(){
        var ASPECT_RATIO = 1.777777778;  // 16:9 ratio.
        var $hideableArea = $(this._hideableArea);
        var newHeight = $hideableArea.width() / ASPECT_RATIO;
        this.drawingLayer.setHeight(newHeight);
        this.toolLayer.setHeight(newHeight);
      }
      this.resizeBlackboard = this.resizeBlackboard.bind(this);

      /**
       * show the given board.
       */
      this.drawEntireBoard = function(commands){
        this.drawingLayer.drawEntireBoard(commands);
      }

      this.drawOntoBoard = function(commands){
        this.drawingLayer.drawOntoBoard(commands)
      }

      this.drawLine = (function(line){
        this.drawingLayer.drawLine(line);
      }).bind(this)


    }
    return Canvas;
});

define('blackboard/boards/BlackBoard',[],
function(){

    var BlackBoard = function(board){

      if(!board || typeof board != 'object'){
        throw new Error('Board data must be passed to constructor.');
      }

      this.getLastModifiedMillis = function(){
        return new Date(this.lastModified).getTime()
      }

      this.setLastModified = function(millis){
        this.lastModified = new Date(millis).toISOString();
      }

      this.lastModified = null;

      this.updateLastModified = (function(){
        this.lastModified = new Date(Date.now()).toISOString()
      }).bind(this)



      this.getCommandCount = function(){
        return this.commands.length
      }

      this.setBoardId = function(id){
        if(!id || isNaN(id))
          throw new Error("board_id missing or not a number.");
        this.boardId = id
      }
      this.setBoardId(board.board_id)



      this.setBoardURL = function(url){
        if(!url || typeof url != 'string'){
          throw new Error("board_url missing or not a string.");
        }
        this.boardURL = url
      }
      this.setBoardURL(board.board_url)

      this.dirty = false;

      this.getCommands = function(){
        return this.commands.slice(0);
      }

      this.setCommands = function(commands){
        if(Array.isArray(commands)){
          this.commands = commands;
        }
        else{
          this.commands = [];
        }
      }
      this.setCommands(board.commands)

      this.append = function(command){
        if(typeof command == 'object' && command.isBoardable && command.isBoardable()){
          this.commands.push(command);
          this.setDirty()
          this.updateLastModified()
        }
        else
          throw new Error('Expected a Boardable command.')
      }

      this.getId = function(){
        return this.boardId;
      }

      this.isDirty = function(){
        return this.dirty;
      }

      this.setDirty = function(){
        this.dirty = true;
      }

      this.getURL = function(){
        return this.boardURL;
      }

      this.getLastTimeLoadedMillis = function(){
        return new Date(this.lastLoaded).getTime()
      }

      this.getLastTimeLoadedISO = function(){
        return this.lastLoaded
      }


      this.setLastTimeLoaded = function(time){
        if(typeof time != 'string' || time.length < 1){
          throw new Error('last_loaded must be a iso date string.');
        }
        this.lastLoaded = time;
      }
      this.setLastTimeLoaded(board.last_loaded)


      this.deepCopy = function(){
        var d = {
          board_url:this.getURL(),
          last_loaded:this.getLastTimeLoadedISO(),
          is_dirty:this.isDirty(),
          board_id:this.getId(),
          commands:this.getCommands()
        }
        var b = new BlackBoard(d);
        b.setLastModified(this.getLastModifiedMillis())
        return b;
      }

      this.serialize = function(){
        var serialized = []
        this.getCommands().forEach(function(c){
          serialized.push(c.serialize())
        })
        return {
          board_url:this.getURL(),
          last_loaded:this.getLastTimeLoadedISO(),
          is_dirty:this.isDirty(),
          board_id:this.getId(),
          commands:serialized
        }
      }
    } // end

    BlackBoard.getRaw = function(){
      return {
        board_url:'url',
        last_loaded:(new Date(0).toISOString()),
        is_dirty:true,
        board_id:1,
        commands:[]
      }
    }

    BlackBoard.getFake = function(){
      var raw = BlackBoard.getRaw()
      return new BlackBoard(raw);
    }

    return BlackBoard;
});

define('blackboard/models/Erase',[],
function(){

  var Erase = function(data){

    this.x = null
    this.y = null
    this.r = null

    this.isBoardable = function(){
      return true
    }

    this.isLine = function(){
      return false
    }

    this.getX = function(){
      return this.x
    }

    this.setX = function(x){
      this.x = x
    }
    this.setX(data.x)

    this.getY = function(){
      return this.y
    }

    this.setY = function(y){
      this.y = y
    }
    this.setY(data.y)

    this.getRad = function(){
      return this.rad
    }

    this.setRad = function(rad){
      this.rad = rad
    }
    this.setRad(data.r)

    this.serialize = function(){
      return {
        x:this.x,
        y:this.y,
        r:this.rad
      }
    }
  }

  Erase.getRaw = function(){
    return {
      x:0.2,
      y:0.3,
      r:0.1
    }
  }

  Erase.getFake = function(){
    var r = Erase.getRaw()
    return new Erase(r)
  }


  return Erase;

});

define('blackboard/boards/BlackboardCollection',['blackboard/boards/BlackBoard',
        'blackboard/models/Erase'],
function(BlackBoard, Erase){

    var BlackboardCollection = function(){

      this.boards = [];
      this.index = -1;

      this.contains = function(board){
        return this.getBoardById(board.board_id) != null
      }

      this.getLastBoard = function(){
        if(this.boards.length == 0)
          throw new Error('Cannot get a last board because no boards exist yet.')
        return this.boards[this.boards.length - 1]
      }

      this.getBoards = function(){
        return this.boards.slice(0);
      }


      this.getBoardById = function(id){
        var board = null
        this.boards.forEach(function(b){
          if(b.getId() == id){
            board = b
            return
          }
        })
        return board
      }

      this.setBoards = (function(boards){
        if(!Array.isArray(boards)){
          throw new Error("Needs to be an array.");
        }
        else if(boards.length < 1){
          throw new Error("Needs to have at least one element.");
        }
        this.boards = [];
        for(var i = 0; i < boards.length; i++){
          var rawData = boards[i];
          var blackboard = new BlackBoard(rawData);
          this.boards.push(blackboard);
        }
        var index = this.getLastViewedBoardIndex();
        this.index = index;
      }).bind(this)


      this.getLastViewedBoardIndex = function(){
        var candidateCurrentBoard = null;
        var latestSoFar = 0;
        var index = 0;
        for(var i = 0; i < this.boards.length; i++){
          var loadTime = this.boards[i].getLastTimeLoadedMillis()
          if(loadTime > latestSoFar){
            index = i;
            latestSoFar = loadTime;
          }
        }
        return index;
      }


      this.appendBoard = function(rawBoard){
        var blackBoard = new BlackBoard(rawBoard);
        this.boards.push(blackBoard);
        if(this.getCount() == 1) this.index = 0
      }

      this.setIndexToLastBoard = function(){
        this.index = this.boards.length - 1;
      }

      this.setCurrentBoardById = function(boardId){
        for(var i = 0; i < this.getCount(); i++){
          var candidateId = this.boards[i].getId();
          if(boardId == candidateId){
            this.index = i;
            return;
          }
        }
        throw new Error("That boardId does not exist in the board set.");
      }


      this.setCurrentBoardIndex = function(index){
        if(isNaN(index) || index < 0 || index >= this.getCount()){
          throw new Error("Invalid index.");
        }
        this.index = index;
      }


      this.deleteAll = function(){
        this.index = null;
        this.boards = [];
      }

      this.appendCommandsToCurrentBoard = function(commands){
        var self = this
        commands.forEach(function(c){
          self.boards[self.index].append(c)
        })
      }

      this.getCurrentBoardDeepCopy = function(){
        return this.boards[this.index].deepCopy();
      }

      this.getSerializedCurrentBoard = function(){
        return this.getCurrentBoardDeepCopy().serialize()
      }

      // private.
      this._getCurrentBoard = function(){
        var board = this.boards[this.index];
        if(!board){
          throw new Error("Current board has not been initialized.");
        }
        else{
          return board;
        }
      }

      this.pushEraserCallOntoState = function(command){
        if(this.isEmpty()){
          throw new Error("Can't store erase call because current board does not exist yet.");
        } else if(!command.isBoardable || !command.isBoardable()){
          throw new Error('Can only add Boardable objects to a Blackboards state.')
        }
        var b = this._getCurrentBoard();
        b.setDirty();
        b.append(command);
      }

      this.appendLineToCurrentBoard = function(line){
        var b = this._getCurrentBoard();
        b.append(line);
        b.setDirty();
      }

      this.appandCommandToAnotherBoard = function(line){
        this.boards.forEach(function(b){
          if(b.getId() == line.getBoardId()){
            b.append(line)
            b.updateLastModified()
            return;
          }
        })
      }


      this.getCurrentBoardCommandCount = function(){
        return this._getCurrentBoard().getCommands().length;
      }

      this.isEmpty = function(){
        return this.boards.length == 0;
      }

      this.isNotEmpty = function(){
        return this.boards.length > 0
      }

      this.getCount = function(){
        return this.boards.length;
      }

      this.getCurrentBoardIndex = function(){
        return this.index;
      }

      this.getCurrentBoardCommands = function(){
        return this._getCurrentBoard().getCommands();
      }

      this.getCurrentBoardId = function(){
        return this._getCurrentBoard().getId();
      }

      this.isCurrentBoardDirty = function(){
        var board = this._getCurrentBoard();
        if(board){
          return board.isDirty();
        }
        else{
          return false;
        }
      }
      this.isCurrentBoardDirty = this.isCurrentBoardDirty.bind(this);

      this.getCurrentBoardURL = function(){
        return this._getCurrentBoard().getURL();
      }

      this.setCurrentBoardCommands = function(state){
        this._getCurrentBoard().setCommands(state);
      }
    }

    BlackboardCollection.getFake = function(){
      var b1 = BlackBoard.getRaw()
      var b2 = BlackBoard.getRaw()
      b2.board_id = b1.board_id + 1
      var boards = [b1,b2]
      var c = new BlackboardCollection()
      c.setBoards(boards)
      return c
    }


    return BlackboardCollection;
});

define('blackboard/models/RemoteErase',['blackboard/models/Erase'],
function(Erase){

  var RemoteErase = function(data){
    Object.setPrototypeOf(this,new Erase(data))


    this.setX = function(x){
      if(x > 1 || x < 0)
        throw new Error('x must be between 0 and 1')
      this.x = x
    }
    this.setX(data.x)

    this.setY = function(y){
      if(y > 1 || y < 0)
        throw new Error('y must be between 0 and 1')
      this.y = y
    }
    this.setY(data.y)


    this.setFriendId = function(id){
      this.friendId = id
    }
    this.setFriendId(data.friend_id)

    this.getFriendId = function(){
      return this.friendId
    }

    this.setBoardId = function(id){
      this.boardId = id
    }
    this.setBoardId(data.board_id)

    this.getBoardId = function(){
      return this.boardId
    }

    this.isForCurrentBoard = function(friendId, boardId){
      var sameFriend = friendId == this.friendId
      var sameBoard = this.boardId == boardId
      return  sameFriend && sameBoard
    }

    this.serialize = function(){
      return {
        x:this.x,
        y:this.y,
        r:this.rad,
        board_id:this.getBoardId(),
        friend_id:this.getFriendId()
      }
    }
  }

  RemoteErase.getRaw = function(){
    var r = Erase.getRaw()
    r.board_id = 2
    r.friend_id = 3
    return r
  }


  RemoteErase.getFake = function(){
    var r = RemoteErase.getRaw()
    return new RemoteErase(r)
  }

  RemoteErase.create = function(x,y,r){
    return new RemoteErase({x:x, y:y, r:r})
  }

  return RemoteErase;

});

define('blackboard/BlackboardStore',['dispatcher/Dispatcher',
        'abstract-interfaces/Store',
        'blackboard/BlackboardRemoteService'],
function(Dispatcher,
         Store,
         RemoteService){

   new RemoteService()
   var instance = null;
   var BlackboardStore  = function(){

     Object.setPrototypeOf(this, new Store())
     this.dis = new Dispatcher()
     this.blackboardSharerOpen = false

     this.openBlackboardSharer = (function(){
       this.blackboardSharerOpen = true
       this.pub()
     }).bind(this)
     this.dis.reg('openBlackboardSharer',this.openBlackboardSharer)

     this.closeBlackboardSharer = (function(){
       this.blackboardSharerOpen = false
       this.pub()
     }).bind(this)
     this.dis.reg('closeBlackboardSharer',this.closeBlackboardSharer)


     this.isBlackboardSharerOpen = function(){
       return this.blackboardSharerOpen
     }



  } // end

    return {
      getInstance:function(){
        if(!instance){
          instance = new BlackboardStore();
        }
        return instance;
      },
      getNew:function(){
        return new BlackboardStore();
      }
    }
  })
;
this.selectedClassmateId
define('blackboard/ViewModel',[
  'ko',
  'dispatcher/Dispatcher',
  'text!blackboard/template.html',
  'blackboard/BlackboardRemoteService',
  'blackboard/canvas/Canvas',
  'blackboard/boards/BlackBoard',
  'blackboard/boards/BlackboardCollection',
  'blackboard/models/Line',
  'blackboard/models/Erase',
  'blackboard/models/RemoteErase',
  'blackboard/BlackboardStore',
],
function(ko,
         Dispatcher,
         template,
         RemoteService,
         Canvas,
         Blackboard,
         BlackboardCollection,
         Line,
         Erase,
         RemoteErase,
         BlackboardStore){

  function BlackboardViewModel(params,componentInfo){


    this.dis = new Dispatcher();
    this.store = BlackboardStore.getInstance()
    this.selectedClassmateId = -1;
    this.isToggleVisible = ko.observable(false);
    this.spinnerVisible = ko.observable(false);
    this.prevArrowVisible = ko.observable(false);
    this.blackboardOpen = ko.observable(false);
    this.isTrashedMessageVisible = ko.observable(false);
    this.recentlyTrashedBoards = ko.observableArray([]);
    this.isWaitingForEmail = ko.observable(false)
    this.showEmailCheckmark = ko.observable(false)
    this.isEmailOptionsOpen = ko.observable(false)


    this.remoteService = new RemoteService();
    this.SAVING_DELAY = 5000; // * 60;
    this.ERASER_RADIUS = 0.02;

    this.boards = new BlackboardCollection();


    this.white = '#ffffff'
    this.blue = '#00c4ff'
    this.green = '#00FF2D'
    this.yellow = '#ffd800'
    this.pink = '#FF00DC'

    // tool stuff.
    this._myCurrentTool = 'cursor'
    this.myToolsColor =  this.white
    this._friendsCurrentTool = 'cursor'


    this.setPencilTool = (function(){
     this._myCurrentTool = 'pencil';
     this.canvas.setMyToolToPencil();
   }).bind(this)

    this.setEraserTool = function(){
      this._myCurrentTool = 'eraser';
      this.canvas.setMyToolToEraser();
    }



    this.selectBlue = function(){
      this.myToolsColor = this.blue
      this.setPencilTool()
    }

    this.selectPink = function(){
      this.myToolsColor = this.pink
      this.setPencilTool()
    }

    this.selectYellow = function(){
      this.myToolsColor = this.yellow
      this.setPencilTool()
    }

    this.selectGreen = function(){
      this.myToolsColor = this.green
      this.setPencilTool()
    }

    this.getMyCurrentTool = (function(){
      return this._myCurrentTool;
    }).bind(this)


    this.setBoardCollection = function(boards){
      this.boards = boards
    }


    this.emailBoard = (function(){
      var png = this.canvas.getPNG()
      var friendId = this.selectedClassmateId
      var p = {friendId:friendId, img:png}
      this.remoteService.emailBlackboard(p, this.onBlackboardEmailed)
      this.isWaitingForEmail(true)
    }).bind(this)


    this.emailBoardTitle = ko.observable('')
    this.titleValid = ko.observable(false)
    this.onEmailBoardTitle = (function(title){
      if(title.length < 2) {
        this.titleError('needs to be longer.')
        this.titleValid(false)
      }
      else this.titleValid(true)
    }).bind(this)
    this.emailBoardTitle.subscribe(this.onEmailBoardTitle)


    this.emailBoardMessage = ko.observable('')
    this.messageValid = ko.observable(false)
    this.onEmailBoardMessage = (function(message){
      if(message.length < 2){
        this.messageError('message must be longer')
        this.messageValid(false)
      } else{
        this.messageValid(true)
      }
    }).bind(this)

    this.onStore = (function(){
      this.isEmailOptionsOpen(this.store.isBlackboardSharerOpen())
    }).bind(this)
    this.store.sub(this.onStore)


    this.openEmailWindow = (function(){
      this.dis.dispatch('openBlackboardSharer')
    }).bind(this)

    this.closeEmailWindow = (function(){
      this.dis.dispatch('closeBlackboardSharer')
    }).bind(this)


    this.onBlackboardEmailed = (function(){
      this.isWaitingForEmail(false)
      var self = this
      this.showEmailCheckmark(true)
      setTimeout(function(){
        self.showEmailCheckmark(false)
      },1250)
    }).bind(this)


    /**
     * "slides" the blackboard up or down.
     * @return {[type]} [description]
     */
    this.toggleVisibility = (function(){
      if(!this.blackboardOpen()){
        this.blackboardOpen(true);
        this.canvas.resizeBlackboard();
        var self = this;
        setTimeout(function(){
          self.canvas.resizeBlackboard();
        },50);
      }
      else{
          this.blackboardOpen(false);
      }
    }).bind(this)




    this.hideBlackboard = (function(){
      this.blackboardOpen(false);
      this.isToggleVisible(false);
    }).bind(this)
    this.openGroupId = this.dis.reg('showGroupView', this.hideBlackboard);
    this.groupInfoId  = this.dis.reg('groupInfo', this.hideBlackboard);
    this.dis.reg('openNews',this.hideBlackboard)




    this.handleFriendChange = (function(classmate){
      if(classmate){
        this.selectedClassmateId = classmate.getId();
        var id = this.selectedClassmateId;
        this.possiblySaveState();
        if(this.canvas.clear){
          this.canvas.clear();
        }
        this.spinnerVisible(true);
        this.remoteService.getSharedBoards(id);
        this.remoteService.joinFriend(id, this._myCurrentTool);
        this.recentlyTrashedBoards([]);
        this.isToggleVisible(true);
      }
      else{
        this.blackboardOpen(false);
      }
    }).bind(this)
    this.classmateCallbackId = this.dis.reg('focusPerson', this.handleFriendChange);




    /**
     * Asks the remote service to send out the current position of this
     * user on the black board so that the friend can see where the current
     * user is on the board.
     * @param  {object} position
     */
    this.setMyCursorPosition = (function(position){
      if(this.boards.isEmpty() == false){
        var update = {
          position:position,
          boardId:this.getCurrentBoardId(),
          friendId:this.selectedClassmateId
        }
        var self = this;
        this.remoteService.emitMyCursorPosition(update,function(){
          // on success.
        });
      }
    }).bind(this)
    this.canvas = new Canvas(this);


    /**
     * Cavvas is only updated if the friend is the currently
     * selected friend and the current board id matches
     * the board id in the update.
     * @param  {[type]} update [description]
     */
    this.onFriendsCursorPositionReceived = (function(update){
      if(this.selectedClassmateId == update.friendId && update.boardId == this.getCurrentBoardId()){
          this.canvas.drawFriendsCursor(update);
      }
      else if(this.selectedClassmateId == update.friendId){
        this.drawFriendPositionHintMarker(update);
      }
    }).bind(this)


    /**
     * Gives a hint to the current user about which
     * way they should move through the boards to
     * see what their friend is doing.
     * @param  {[type]} update [description]
     */
    this.drawFriendPositionHintMarker = (function(position){
      if(position.boardId < this.getCurrentBoardId()){
        this.canvas.drawFriendLeftMarker(position.y0);
      }
      else if(position.boardId > this.getCurrentBoardId()){
        this.canvas.drawFriendRightMarker(position.y0);
      }
    }).bind(this)



    this.setMyPencilPosition = (function(position){
      if(this.boards.isEmpty() == false){
        var update = {
          x0:position.x,
          y0:position.y,
          boardId:this.getCurrentBoardId(),
          friendId:this.selectedClassmateId
        }
        this.remoteService.emitMyPencilPosition(update);
      }
    }).bind(this)


    /**
     * Attemps to ask the canvas to draw the friends pencil
     * However if the friends pencil is on another board
     * it will no be drawn.
     * @param  {object} update
     */
    this.onFriendPencilPositionReceived =  (function(update){
        if(update.friendId == this.selectedClassmateId && this.boards.isEmpty() == false){
          if(update.boardId == this.getCurrentBoardId()){
              this.canvas.drawFriendsPencil(update);
          }
          else{
            this.drawFriendPositionHintMarker(update);
          }
        }
    }).bind(this)

    this.setMyPencilLine = function(line){
      line.setFriendId(this.selectedClassmateId)
      line.setBoardId(this.getCurrentBoardId())
      line.setColor(this.myToolsColor)
      var self = this;
      var serial = line.serialize()
      this.remoteService.emitMyPencilLine(serial, function(){
        self.onPencilLineSent(line);
        self.startSaveCountDown();
      });
    }

    /**
     * An acknowledgment function which gets
     * exectuted when a line has been successfully
     * sent out to all subscribers of the current board.
     */
    this.onPencilLineSent = (function(line){
      this.boards.appendLineToCurrentBoard(line);
      this.canvas.drawMyPencilLine(line);
    }).bind(this)


    /**
     *
     * @param  {object} position of the form {x:Number,y:Number}
     */
    this.setMyEraserPosition = (function(position){
      position.boardId = this.getCurrentBoardId();
      position.friendId = this.selectedClassmateId;
      this.remoteService.emitMyEraserPosition(position);
    }).bind(this)


    /**
     * Updates the board with the friends eraser position.
     * @param  {[type]} update [description]
     */
    this.onFriendsEraserPositionReceived = (function(update){
      if(update.friendId == this.selectedClassmateId){
        if(update.boardId == this.getCurrentBoardId()){
          this.canvas.drawFriendsEraser(update.position);
        }
        else{
          this.drawFriendPositionHintMarker(update);
        }
      }
    }).bind(this)


    this.setMyEraserDown = (function(point){
      var erase = RemoteErase.create(point.x, point.y, this.ERASER_RADIUS)
      erase.setFriendId(this.selectedClassmateId)
      erase.setBoardId(this.getCurrentBoardId())
      var s = erase.serialize()
      var self = this
      this.remoteService.emitMyEraserDown(s,function(){
        self.onEraseSent(erase)
      });
    }).bind(this)


    this.onEraseSent = (function(erase){
      this.boards.pushEraserCallOntoState(erase);
      this.canvas.eraseArea(erase);
      this.startSaveCountDown();
    }).bind(this)


    this.onFriendsEraserDown = (function(command){
      console.log('here')
      var erase = new RemoteErase(command)
      var friendId = this.selectedClassmateId
      var boardId = this.getCurrentBoardId()
      console.log('erase:')
      console.log(erase)
      console.log('friendId:' + friendId)
      console.log('boardId:' + boardId)

      if(erase.isForCurrentBoard(friendId, boardId)){
        this.boards.pushEraserCallOntoState(erase);
        this.canvas.friendEraseArea(erase);
      }
    }).bind(this)





    /**
     * Draws the friends line to the canvas if the
     * current board id is the same as the arguments
     * boardId.   also updates the current board state by
     * appending the line to it.
     *
     * friendId:Number
     * boardId:Number
     * line: {p0:{x,y},p1:{x,y}}
     */
    this.onFriendPencilLineReceived = (function(rawLine){
      var line = new Line(rawLine)
      var friendId = this.selectedClassmateId
      var boardId = this.getCurrentBoardId()

      if(line.isFrom(friendId)){
        if(line.isOnBoard(boardId)){
          this.boards.appendLineToCurrentBoard(line);
          this.canvas.drawFriendsPencilLine(line);
        }
        else{
          this.boards.appandCommandToAnotherBoard(line)
          var p = line.getEndPoint()
          this.drawFriendPositionHintMarker(p);
        }
      }
    }).bind(this)


    /**
     * Handles what happens when the board data
     * is loaded from the remote service.
     * @param  {object} board has a id and lines property.
     */
    this.onSharedBoardsReceived = (function(json){
      var boards = JSON.parse(json)
      this.boards.setBoards(boards);
      if(this.boards.getCurrentBoardIndex() > 0){
        this.prevArrowVisible(true);
      }
      else{
        this.prevArrowVisible(false);
      }
      var currentBoardId = this.getCurrentBoardId();
      this.remoteService.getBoardData(currentBoardId, this.onBoardDataReceived);
    }).bind(this)




    this.timeoutReferences = [];
    this.testMode = false;
    this.startSlowServerResponseTimer = (function(testString){
      var self = this;
        var timerReferece = setTimeout(function(){
                if(!self.testMode)
                  alert("Problem loading chalkboards, try refreshing the screen.");
          },5000);
        this.timeoutReferences.push(timerReferece);
    }).bind(this)

    this.getCurrentBoardId = function(){
      return this.boards.getCurrentBoardId()
    }


    this.processIncomingBoardData = (function(json){
      var raw = JSON.parse(json)
      var board_id = raw.board_id
      var commands = []
      if(board_id == this.getCurrentBoardId()){
        raw.commands.forEach(function(c){
          if(c.kind == 'line')
            commands.push(new Line(c))
          else
            commands.push(new Erase(c))
        })
      }
        this.spinnerVisible(false);
        return commands;
    }).bind(this)


    this.onBoardDataReceived = (function(json){
        var commands = this.processIncomingBoardData(json)
        this.canvas.drawEntireBoard(commands);
        this.boards.setCurrentBoardCommands(commands);
    }).bind(this)


    this.onAdditionalBoardData = (function(json){
        var commands = this.processIncomingBoardData(json)
        this.canvas.drawOntoBoard(commands);
        this.boards.appendCommandsToCurrentBoard(commands);
    }).bind(this)

    /**
     * Saves the changes to the server when the user
     * stops doing their work for more than a few seconds.
     * or they switch to a new board.
     */
    this.saveTimers = [];
    this.startSaveCountDown = (function(callback){
      this.clearExistingTimers();
      this.createNewSaveTimer();
    }).bind(this)


    this.clearExistingTimers = (function(){
      if(this.saveTimers.length > 0){
        for(var i = 0; i < this.saveTimers.length; i++){
          clearTimeout(this.saveTimers[i]);
        }
        this.saveTimers = [];
      }
    }).bind(this)

    /**
     * Schedules a new save event to occur after SAVING_DELAY time.
     * @param  {Function} callback  for testing purposes.
     */
    this.createNewSaveTimer = (function(callback){
      var self = this;
      var saveTimerHandle = setTimeout(function(){
        self.possiblySaveState();
        if(callback && typeof callback == 'function'){
              callback(true);
        }
      },self.SAVING_DELAY);
      this.saveTimers.push(saveTimerHandle);
    }).bind(this)




    /**
        Trashes the current board.
    **/
    this.trashCurrentBoard = (function(){
      try{
        this.spinnerVisible(true);
        var currentBoardId = this.getCurrentBoardId();
        var friendId = this.selectedClassmateId;
        this.possiblySaveState();
        this.remoteService.trashBoard(currentBoardId, friendId);
      } catch(err) {
        console.log(err.message);
      }
    }).bind(this)


    this.onBoardTrashed = (function(jsonBoard){
      var trashedBoard = JSON.parse(jsonBoard);
      var trashedBoardId = trashedBoard.boardId;
      var friendId = this.selectedClassmateId;
      this.remoteService.getSharedBoards(friendId);
      this.recentlyTrashedBoards.push(trashedBoardId);
    }).bind(this)


    this.undoTrashBoard = function(){
      if(this.recentlyTrashedBoards().length <= 0){
        throw new Error('Cannot undo because there is no recently trashed boards.');
      }
      this.possiblySaveState()
      var lastBoardTrashed = this.recentlyTrashedBoards.pop(); // oldest of the recently trashed.
      var friendId = this.selectedClassmateId;
      this.remoteService.undoTrashBoard(lastBoardTrashed, friendId);
    }

    this.onTrashBoardUndone = (function(){
      var friendId = this.selectedClassmateId;
      this.remoteService.getSharedBoards(friendId);
    }).bind(this)

    this.onFriendRestoredBoard = (function(info){
      this.validateBoardUpdateInfo(info);
      var friendId = info.friendId;
      let selectedClassmateId = this.selectedClassmateId;
      if(friendId == selectedClassmateId){
        this.remoteService.getSharedBoards(friendId);
      }
    }).bind(this)


    this.onFriendTrashedBoard = (function(json){
      var info = JSON.parse(json)
      this.validateBoardUpdateInfo(info);
      var currentFriendId = this.selectedClassmateId;
      var currentBoardId = this.getCurrentBoardId();
      if(info.friendId == currentFriendId && currentBoardId == info.boardId){
        this.remoteService.getSharedBoards(currentFriendId);
        this.isTrashedMessageVisible(true);
        var self = this;
        setTimeout(function(){
          self.isTrashedMessageVisible(false);
        },3000);
      }
    }).bind(this)


    this.validateBoardUpdateInfo = function(info){
      if(!info || typeof info != 'object' || isNaN(info.friendId) || info.friendId < 1){
        throw new Error("Invalid trash board command,  friendId is required.");
      }
      if(!info.boardId || isNaN(info.boardId) || info.boardId < 1){
        throw new Error('boardId must be a positive integer.');
      }
    }


    /**
     * [description]
     * @param  {object} data has friendId and currentTool
     */
    this.onFriendToolUpdated = (function(data){
      if(data.friendId == this.selectedClassmateId){
        this._friendsCurrentTool = data.currentTool;
      }
    }).bind(this)


    this.onAuth = function(update){
      if(update.state == 'authenticated'){
        this.remoteService.initialize();
        this.canvas.initialize();

        this.remoteService.registerGetSharedBoardsCallback(this.onSharedBoardsReceived);
        this.remoteService.registerOnNextBoardRecievedCallback(this.onNextBoardRecieved);
        this.remoteService.registerOnPreviousBoardRecievedCallback(this.onPreviousBoardRecieved);
        this.remoteService.registerOnSaveCallback(this.onCurrentBoardSaved);
        this.remoteService.registerOnBoardTrashedCallback(this.onBoardTrashed);
        this.remoteService.registerOnFriendTrashedBoard(this.onFriendTrashedBoard);
        this.remoteService.registerOnTrashBoardUndone(this.onTrashBoardUndone);
        this.remoteService.registerOnFriendRestoredBoard(this.onFriendRestoredBoard);

        this.remoteService.attachFriendJoinedBlackboardHandler(this.onFriendToolUpdated);
        this.remoteService.attachOnFriendCursorPositionReceivedHandler(this.onFriendsCursorPositionReceived);
        this.remoteService.attachOnFriendPencilPositionCallback(this.onFriendPencilPositionReceived);
        this.remoteService.attachFriendsPencilLineUpdateHandler(this.onFriendPencilLineReceived);
        this.remoteService.attachOnFriendsEraserPositionUpdateCallback(this.onFriendsEraserPositionReceived);
        this.remoteService.attachFriendsEraserDownCallback(this.onFriendsEraserDown);
        this.setPencilTool() // so the user can draw right away.
      }
    }
    this.onAuth = this.onAuth.bind(this);
    this.dis.reg('authState',this.onAuth);




    this.onCurrentBoardSaved = function(){
      console.log('Current board saved.');
    }
    this.onCurrentBoardSaved = this.onCurrentBoardSaved.bind(this);


    this.prevArrowClicked = function(){
      this.possiblySaveState();
      this.spinnerVisible(true);
      var boardId = this.getCurrentBoardId();
      var friendId = this.selectedClassmateId;
      this.remoteService.getPreviousBoard(boardId,friendId);
    }


    this.nextArrowClicked = (function(){
      this.possiblySaveState();
      this.spinnerVisible(true);
      var currentBoardId = this.getCurrentBoardId();
      var currentFriendId = this.selectedClassmateId;
      this.remoteService.getNextBoard(currentBoardId, currentFriendId);
    }).bind(this)


    this.possiblySaveState = (function(){
      if(this.boards.isNotEmpty() && this.boards.isCurrentBoardDirty()){
        var s = this.boards.getSerializedCurrentBoard();
        this.remoteService.saveCurrentBoard(s);
      }
    }).bind(this)


    this.onFriendAddedNewBoard = (function(board){
      if(!this.boards.contains(board)){
        this.boards.appendBoard(board);
      }
    }).bind(this)
    this.dis.reg('friendAddedNewBoard',this.onFriendAddedNewBoard)

    /**
     * @param  {object} jsonBoard
     *  appends a new board to the collection if it is not there already.
     *  loads the most recent version of the board.  (compares the persisted one to the local one.)
     */
    this.onNextBoardRecieved = (function(jsonBoard){
      var board = JSON.parse(jsonBoard);
      if(!this.boards.contains(board)){
        this.boards.appendBoard(board);
        this.boards.setIndexToLastBoard()
      } else
        this.boards.setCurrentBoardById(board.board_id)

      var currentBoard = this.boards.getCurrentBoardDeepCopy()
      var cacheLastUpdated = currentBoard.getLastModifiedMillis()
      var serverLastUpdated = (new Date(board.last_loaded).getTime())
      if(cacheLastUpdated > serverLastUpdated){
        var cachedCommands = currentBoard.getCommands()
        this.canvas.drawEntireBoard(cachedCommands);
        var ack = this.onAdditionalBoardData
        var boardId = currentBoard.getId()
        this.remoteService.getAdditionalBoardData(boardId, ack)
      } else {
        this.remoteService.getBoardData(currentBoard.getId(), this.onBoardDataReceived);
      }
      this.prevArrowVisible(true);
    }).bind(this)



    /**
     * Takes an json array of two boards, where is 2nd is
     * the board that is being switched too and the 1st is
     * the one that comes before it.  IF the 1st one has
     * board_id == -1 then that signifies that there is no
     * previous board and that the left arrow button should
     * be hidden to contrain the user from attempting to
     * go to a left board when one does not exist.
     * @param  {json} boards is a json array of boards.
     */
    this.onPreviousBoardRecieved = (function(jsonBoards){
      var boards = JSON.parse(jsonBoards);
      if(boards.length != 2 || isNaN(boards[1].board_id)){
        throw new Error('onPreviousBoardRecieved() expects JSON array of length 2 as input.');
      }
      if(this.boards.isEmpty()){
        throw new Error("Can't set previous board without its reference existing somewhere in the board set.");
      }
      if(boards[0].board_id == -1 && boards[1].board_id != -1){ // there is no board before this one.
        this.prevArrowVisible(false);
      }
      this.boards.setCurrentBoardById(boards[1].board_id);
      var currentBoardId = this.getCurrentBoardId();
      this.remoteService.getBoardData(currentBoardId, this.onBoardDataReceived);
    }).bind(this)



}; // end view model.

  return {
    viewModel: BlackboardViewModel,
    template: template
  }

});


define('text!auth/template.html',[],function () { return '<link rel="stylesheet" href="./styles/components/auth/style.css?v=1.4"></link>\n\n\n<div id="auth-holder" data-bind="visible:isVisible()">\n\n  <img  id="logo"\n        src="./styles/components/auth/logo.png" >\n\n    <div class="landing-page-background-image">\n    </div>\n          <img id=\'student-graph\'\n               src=\'./assets/graph.png\'></img>\n\n    <div id="signup-holder" data-bind="visible:signupPageVisible()">\n      <div class="input-holder" data-bind="visible: !activationEmailSent()">\n      <div style="position:relative">\n        <input class="auth-input" placeholder="First name" id="firstName" type="text"\n               data-bind="textInput:firstName, enterKey: signUp, hasFocus:invokeSignupFormEndowment"/>\n        <span data-bind="visible: isFirstNameValid()"  class="auth-check-mark glyphicon glyphicon-ok"></span>\n      </div>\n\n      <div id="last-name-holder" style="position:relative;">\n        <input class="auth-input" placeholder="Last name" id="lastName" type="text" data-bind="textInput:lastName, enterKey: signUp"/>\n        <span data-bind="visible: isLastNameValid()"  class="auth-check-mark glyphicon glyphicon-ok"></span>\n      </div>\n\n\n\n      <div style="position:relative;">\n\n        <input class="auth-input"\n               autocorrect="off"\n               autocapitalize="none"\n               autofocus placeholder="Email"\n               id="signup-email"\n               type="text"\n               data-bind="textInput:email, enterKey: signUp"/>\n\n\n        <span data-bind="visible: isEmailValid()"\n              class="auth-check-mark glyphicon glyphicon-ok">\n        </span>\n\n      </div>\n\n      <div style="position:relative;">\n        <input class="auth-input"\n               placeholder="Password"\n               id="password-signup"\n               type="password"\n               data-bind="textInput:password ,enterKey: signUp" />\n\n        <!-- Quick Feedback -->\n        <span data-bind="visible: isPasswordValid()"\n              class="auth-check-mark glyphicon glyphicon-ok">\n\n        </span>\n        <span id="signup-password-caution-mark"\n              data-bind="visible: !isPasswordValid() && password().length > 0">\n\n                  <div id="signup-password-callout"\n                       class="callout">\n\n                      <b id="signup-password-error-msg"\n                         class="callout-msg"\n                         data-bind="text:invalidPasswordMessage">\n\n                      </b>\n                      <b class="notch">\n                      </b>\n                  </div>\n        </span>\n      </div>\n\n      <button id="signup-btn"\n              class="auth-btn"\n              data-bind="click:signUp">\n              Signup</button>\n\n\n\n      <button\n            class="glyphicon glyphicon-menu-left back-to-login-page-button"\n            data-bind="click: goToLoginPage">\n      </button>\n\n\n      <div id="terms-and-conditions">By signing up you are agreeing to the\n          <a href="https://www.legal.palolo.ca/terms_and_conditions">\n            terms and conditions\n          </a>\n\n      </div>\n\n\n\n      </div>\n    </div>\n\n\n\n\n<!-- Login Page  -->\n\n        <div id="login-holder"\n             style="color:white"\n             data-bind="visible: loginPageVisible()">\n          <div class="input-holder">\n\n          <div style="position:relative;">\n\n\n\n\n\n\n            <input class="auth-input"\n                   autocorrect="off"\n                   autocapitalize="none"\n                   autofocus placeholder="Email"\n                   id="email"\n                   type="text"\n                   data-bind="textInput:email, enterKey: login"/>\n\n            <span data-bind="visible:  isEmailValid()"\n                  class="auth-check-mark glyphicon glyphicon-ok">\n            </span>\n\n\n\n\n          </div>\n\n          <div style="position:relative;">\n            <input class="auth-input"\n                   placeholder="Password"\n                   id="password-login"\n                   type="password"\n                   data-bind="textInput:password ,enterKey: login" />\n            <span data-bind="visible: isPasswordValid()"  class="auth-check-mark glyphicon glyphicon-ok"></span>\n\n            <!--Quick feedback  -->\n\n            <span id="login-password-caution-mark"\n                  data-bind="visible: !isPasswordValid() && password().length > 0"\n                  class="caution-mark glyphicon glyphicon-exclamation-sign">\n\n                      <div id="login-password-callout"\n                           class="callout">\n\n                          <b id="login-password-error-msg"\n                             class="callout-msg"\n                             data-bind="text:invalidPasswordMessage">\n\n                          </b>\n                          <b class="notch">\n                          </b>\n                      </div>\n            </span>\n\n          </div>\n\n          <button id="login-btn"\n                  class="auth-btn"\n                  data-bind="click:login"\n                  >Login</button>\n\n\n          <div id="or-signup">or</div>\n          <button\n                id="signup-button"\n                data-bind="click:goToSignupPage">\n          Signup\n          </button>\n          </div>\n\n\n        </div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        <div id="signup-spinner"\n             class="middelize"\n             data-bind=visible:spinner()>\n            <div class="big-loader"></div>\n        </div>\n\n\n <!-- Activation Email Sent!  -->\n        <div id="email-sent-page"\n             data-bind="visible: activationEmailSentPageVisible()"\n             class="middelize">\n\n          <div id="activation-email-sent-msg">\n            Activation email sent.\n          </div>\n          <div id="activation-email-sent-instructions">\n            Please check your email to complete\n            your account activation.\n          </div>\n        </div>\n\n\n\n\n        <!-- Password reset stuff. -->\n        <div data-bind="visible:errorMessage().length > 0">\n              <div class="error-msg"\n                   data-bind="text:errorMessage">\n              </div>\n              <div class="auth-clickable"\n                   data-bind="click:goToPasswordResetState">\n                   reset password\n                </div>\n        </div>\n\n\n\n\n        <!-- Password Reset Page -->\n\n            <div id="password-reset-holder"\n                  style="color:white"\n                  data-bind="visible:resetPasswordVisible()">\n\n              <div class="input-holder">\n              <div style="position:relative;">\n                <input class="auth-input"\n                       autocorrect="off"\n                       autocapitalize="none"\n                       autofocus placeholder="Email"\n                       id="reset-email"\n                       type="text"\n                       data-bind="textInput:email"/>\n\n                <span data-bind="visible:  isEmailValid()"\n                      class="auth-check-mark glyphicon glyphicon-ok">\n                </span>\n              </div>\n\n\n\n              <button id="send-reset-email-btn"\n                      class="auth-btn"\n                      data-bind="click:submitResetEmail"\n                      >Submit</button>\n\n              <button\n                    id="password-reset-page-back-button"\n                    class="glyphicon glyphicon-menu-left back-to-login-page-button"\n                    data-bind="click:goToLoginPage"\n                    data-toggle="tooltip"\n                    title="Back">\n              </button>\n              </div>\n              <div class="error-msg"\n                   data-bind="text:malformedEmailError">\n              </div>\n            </div>\n\n\n            <!--  Email Sent! -->\n            <div\n                 data-bind="visible: resetPasswordEmailSentPageVisible()"\n                 class="middelize">\n\n              <div id="activation-email-sent-msg">\n                Reset email sent.\n              </div>\n              <div id="activation-email-sent-instructions">\n                Check your email to complete\n                resetting your password.\n              </div>\n            </div>\n\n\n\n\n            <!-- <div id="conformity-banner"> Over 250 registered York Students.</div> -->\n            <div id=\'affilation\'>Not affiliated with York University</div>\n    </div>\n\n</div>\n';});

 define('auth/AuthRemoteService',['ActiveRemoteService'],
function(ActiveRemoteService){

  var AuthRemoteService = function(){

    Object.setPrototypeOf(this, new ActiveRemoteService());

    this.constructor = AuthRemoteService;
    this.constructor.name = "AuthRemoteService";
    this.getConstructorName = function(){
      return "AuthRemoteService";
    }

    this.setMicroServer('auth');
    this.setPath('Auth.php');
    this.setPort('');


      /**
        expects json return which contains
        the userId and token.
      */
      this.checkIfCurrentTokenIsValid = function(){
        var token = this.getAccessToken();
        if(typeof this.onTokenAnalyzed != 'function'){
          throw new Error('Callback has not been set.');
        }
        if(!token || token == 'null'){
          this.onTokenAnalyzed(false);
        }
        var url  = this.getServerURL();
        $.ajax({
            type:'POST',
            url:url,
            withCredentials: true,
            data:{
              action:'verifyToken',
              token:token
            },
            success:this.onTokenAnalyzed,
            error:function(err){
              console.log(err);
            }
          })
      } // end function.


      this.registerOnTokenVerified = function(callback){
        if(typeof callback != 'function'){
          throw new Error('callback must be function.');
        }
        this.onTokenAnalyzed = callback;
      }



  }


  return AuthRemoteService;
})
;

define('auth/states/AuthState',[],
function(){

  function AuthState(context){

    if(!context){

      throw new Error('context must be injected into authstate, but it is undefined');
    }
    else if(!context.triggerUpdate){

      throw new Error('context needs triggerUpdate function');
    }

    // move this state data into its own class!
    this.activationEmailSent = false;
    this.authServer = null;
    this.context = context;
    this.email = "";
    this.errorMessage = "";
    this.localErrorMessage = {
      passwordError:"",
      wrongEmail:""
    }
    this.firstName = '';
    this.MIN_PASSWORD_LENGTH = 8;
    this.isVisible = true;
    this.isEmailValid = false;
    this.isPasswordValid = false;
    this.lastName = '';
    this.password = "";
    this.spinner = false;
    this.endowSignupForm = false;


    this.getConstructorName = function(){
      throw new Error("getConstructorName must be implemented in a subclass.");
    }


    this.validateRemoteService = function(remoteService){

      if(!remoteService || remoteService.getConstructorName() != "AuthRemoteService"){
        throw new Error("AuthRemoteService must be injected.");
      }
    }


    this.signUp = function(){
      throw new Error('cant signup when your not on the signup screen');
    }

    this.login = function(){
      throw new Error('cant execute abstract login function');
    }


    this.submitResetEmail = function(){
      throw new Error('cant execute abstract submitResetEmail function');
    }

    this.isFirstNameValid = false;



     this.validateEmail = function(email){
       var regex = /^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+\s*$/;
       var isValidEmail = regex.test(email);
       var isAYorkUniversityEmail = /.*yorku\.ca/.test(email);
       if(isValidEmail == false || isAYorkUniversityEmail == false){
         this.isEmailValid = false;
       }
       else{
         this.isEmailValid = true;
       }
     }
     this.validateEmail = this.validateEmail.bind(this);

     this.setEmail = function(email){
       this.validateEmail(email);
       this.email = email;
     }

     this.validatePassword = function(callback){
       var self = this;
       return function(password){
         var numRegex = /\d/;
         var whiteSpaceRegex = /\s/;
         var alphaRegex = /[a-zA-Z]/;
        if(password.length < self.MIN_PASSWORD_LENGTH){
           callback('Password is too short.');
         }
         else if(!alphaRegex.test(password)){
           callback('Password must have at least 1 letter.');
         }
         else if(!numRegex.test(password)){
           callback('Password must have at least one number.');
         }
         else if(whiteSpaceRegex.test(password)){
           callback('Password can\'t have any spaces.');
         }
         else{
           callback('success');
         }
       }
     }
     this.validatePassword = this.validatePassword.bind(this);

     this.passwordValidateCallback = function(msg){
         if(msg == 'success'){
              this.isPasswordValid = true;
         }
         else{
            this.isPasswordValid = false;

            this.localErrorMessage.passwordError = msg;
         }
     }

     this.passwordValidateCallback = this.passwordValidateCallback.bind(this);

      this.setPassword = function(password){
        this.validatePassword(this.passwordValidateCallback)(password);
        this.password = password;
      }

      // sets the next state of this state.
      // i.e: when this state transitions to the next state,
      // this is the state that is transitioned too.
      this.setNextState = function(state){
          if(Object.getPrototypeOf(state).constructor.name !== 'AuthState'){
            throw new Error('State must be a decendant of AuthState');
          }
          this._nextState = state;
      }

      this.goToNextState = function(){
      }
};

  return AuthState;

}); // end define.
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */


define('auth/states/SignupState',['auth/states/AuthState'],

function(AuthState){

  function SignupState(context, remoteService){


    Object.setPrototypeOf(this,new AuthState(context));

    this.validateRemoteService(remoteService);
    this.isVisible = true;
    this.endowSignupForm = true;
    this.remoteService = remoteService;
    this.constructor = SignupState;

    this.getConstructorName = function(){
      return "SignupState";
    }



    // unique too this state.
    this.EXPECTED_SIGNUP_RESPONSE = 'Activation email sent.';

    this.nameRegex = /^[a-zA-Z]{2,}$/

    this.activationEmailSent = false;
    this.firstName = "";
    this.isFirstNameValid = false;
    this.lastName = "";





    this.validateFirstName = function(name){

        var isValid = this.nameRegex.test(name);
        if(!isValid){
          this.isFirstNameValid = false;
        }
        else{
          this.isFirstNameValid = true;
        }
    }
    this.validateFirstName = this.validateFirstName.bind(this);

    this.setFirstName = function(name){
      this.validateFirstName(name);
    }



    this.validateLastName = function(name){
      var isValid = this.nameRegex.test(name);
      if(!isValid){
        this.isLastNameValid = false;
      }
      else{
        this.isLastNameValid = true;
      }
    }
    this.validateLastName = this.validateLastName.bind(this);

    this.setLastName = function(name){
      this.validateLastName(name);
      this.lastName = name;
    }








    this.signUp = function(){

      this.spinner = true;

      var creds =   {

            action:'createNewUser',
            first:this.firstName,
            last:this.lastName,
            email:this.email,
            password:this.password
        }



        $.ajax({
              type:'POST',
              url:this.remoteService.getServerURL(),
              crossDomain: true,
              data:creds,
              success:this.onSignupCallback
            })
        this.context.triggerUpdate();
    }

    this.signUp = this.signUp.bind(this);

    // this.signUpObject =




    this.onSignupCallback = function(response){

      this.spinner = false;

      var decoded = JSON.parse(response);

      if(decoded === this.EXPECTED_SIGNUP_RESPONSE){

        this.activationEmailSent = true;

      }
      else{

        this.activationEmailSent = false;
        this.errorMessage = decoded;
      }

      this.context.triggerUpdate();
    }
    this.onSignupCallback = this.onSignupCallback.bind(this);






}; // end SignupState constructor.


  return SignupState;


}); // end define.
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */


define('auth/states/LoginState',['auth/states/AuthState'],

function(AuthState){

  function LoginState(context,remoteService){



    Object.setPrototypeOf(this,new AuthState(context));
    this.validateRemoteService(remoteService);
    this.remoteService = remoteService;
    this.constructor = LoginState;
    this.getConstructorName = function(){
      return "LoginState";
    }
    this.isVisible = true;

    this.login = function(){
    var obj =   {
          action:'login',
          email:this.email,
          password:this.password
      }
      this.email = ''
      this.password = ''
      this.context.triggerUpdate()
      $.ajax({
            type:'POST',
            url:this.remoteService.getServerURL(),
            withCredentials: true,
            data:obj,
            success:this.onLoginCallback,
            error:this.onLoginError
          })

    }

    this.login = this.login.bind(this);



    this.onLoginCallback = function(response){
      this.spinner = false;
      try{
        this.context.onTokenAnalyzed(response);
        this.context.triggerUpdate();
      }
      catch(err){
        console.log(err);
      }
    }
    this.onLoginCallback = this.onLoginCallback.bind(this);



    this.onLoginError = function(err){
      this.spinner = false;
      this.errorMessage = err.responseText;
      this.context.triggerUpdate();
    }
    this.onLoginError = this.onLoginError.bind(this);

}; // end LoginState constructor.

  return LoginState;
}); // end define.
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */


define('auth/states/SentResetEmailState',['auth/states/AuthState'],

function(AuthState){

  function SentResetEmailState(context,remoteService){



    Object.setPrototypeOf(this,new AuthState(context));

    this.validateRemoteService(remoteService);

    this.remoteService = remoteService;

    this.constructor = SentResetEmailState;

    this.getConstructorName = function(){
      return "SentResetEmailState";
    }

    this.isVisible = true;




}; // end SentResetEmailState constructor.


  return SentResetEmailState;


}); // end define.
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */


define('auth/states/ActivationEmailSentState',['auth/states/AuthState'],

function(AuthState){

  function ActivationEmailSentState(context,remoteService){



    Object.setPrototypeOf(this,new AuthState(context));
    this.validateRemoteService(remoteService);
    this.remoteService = remoteService;
    this.constructor = ActivationEmailSentState;

    this.getConstructorName = function(){
      return "ActivationEmailSentState";
    }
    this.isVisible = true;
    // override.
    this.activationEmailSent = true;



}; // end ActivationEmailSentState constructor.


  return ActivationEmailSentState;


}); // end define.
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */


define('auth/states/PasswordResetState',['auth/states/AuthState'],

function(AuthState){

  function PasswordResetState(context,remoteService){

    Object.setPrototypeOf(this,new AuthState(context));
    this.validateRemoteService(remoteService);
    this.remoteService = remoteService;
    this.constructor = PasswordResetState;

    this.getConstructorName = function(){
      return "PasswordResetState";
    }
    /**
     * To be performed when the response from the server is recieved.
     * on 200 OK responses only.
     */
    this.onResetPasswordCallback = function(jsonResponse){
      var response = JSON.parse(jsonResponse);
      console.log(response);
      if(response == 'success'){
        this.spinner = false;
        this.context.gotoSentResetEmailState();
      }
    }
    this.onResetPasswordCallback = this.onResetPasswordCallback.bind(this);

    /**
     * Handles what happens if the response status isn't 200.
     */
    this.onResetPasswordError = function(xhr,b,c,testMode){
        this.spinner = false;
        console.log(xhr.responseText);
        this.localErrorMessage.wrongEmail = xhr.responseText;
        this.context.triggerUpdate();
    }
    this.onResetPasswordError = this.onResetPasswordError.bind(this);


    /**
     * Asks the server to send a password reset email to the owner
     * of the given email address.
     */
    this.submitResetEmail = function(){
      var obj = {
        action:'resetPassword',
        email:this.email
      }
      // console.log("attempting to reset password for:" + obj.email);
      $.ajax({
            type:'POST',
            url:this.remoteService.getServerURL(),
            withCredentials: true,
            data:obj,
            success:this.onResetPasswordCallback,
            error:this.onResetPasswordError
          })
        this.spinner = true;
        this.context.triggerUpdate();
    }



}; // end PasswordResetState constructor.

  return PasswordResetState;
}); // end define.
;
/**
 * the only part that knows all the auth states.
 *
 * So this is really the state transitioner.
 *
 */
define('auth/StateBuilder',['auth/states/SignupState',
        'auth/states/LoginState',
        'auth/states/SentResetEmailState',
        'auth/states/ActivationEmailSentState',
        'auth/states/PasswordResetState'],

function(SignupState,
         LoginState,
         SentResetEmailState,
         ActivationEmailSentState,
         PasswordResetState){

 var StateBuilder = function(remoteService, viewModel){


   if(!remoteService || !viewModel){

     throw new Error('Both remoteService and viewModel must be injected.');
   }

    this._context = viewModel;



    this.states = [];


    this.getContext = function(){

      return this._context;
    }



    this.getState = function(name){

      for(var i = 0; i < this.states.length; i++){

        if(this.states[i].constructor.name == name){

          return this.states[i];
        }
      }

      return null;


    }


    this.buildInitialState = function(context){

      return this.buildLoginState(context);
    }





    this.build = function(state, context){

      var cachedState = this.getState(state);
      if(cachedState){
        return cachedState;
      }

      switch(state){

        case "LoginState":
          var state = this.buildLoginState(context);
          this.states.push(state);
          return state;
        break;


        case "SignupState":
          var state = new SignupState(context,remoteService);
          this.states.push(state);
          return state;
        break;

        case "ActivationEmailSentState":
          var state = new ActivationEmailSentState(context,remoteService);
          this.states.push(state);
          return state;
        break;

        case "PasswordResetState":
          var state = new PasswordResetState(context,remoteService);
          this.states.push(state);
          return state;
        break;


        case "SentResetEmailState":
          var state = new SentResetEmailState(context,remoteService);
          this.states.push(state);
          return state;
        break;


        default:
          return this.buildLoginState(context);
        break;
      }

    }


    this.buildLoginState = function(context){

      var state = new LoginState(context,remoteService);

      this.states.push(state);

      return state;
    }


    /**
     *
     * precondition: The state already exists in the array of states.
     *
     * Switches to the next state for the given state.
     */
    this.setNextStateOf = function(state, nextState){

      state.setNextState(nextState);

    }



    /**
     *   Foces the context to switch to the
     *   next state from the current state.
     *
     * e.g: if the current state is the login state
     * then it transitions to the signup state.
     */
    this.goToNextState = function(){

        //
        // var currentState = this._context.state();
        //
        // this._context.state(currentState.getNextState());
    }



};

  return StateBuilder;

}); // end define.
;
/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */


define('auth/AuthViewModel',['jquery',
        'ko',
        'dispatcher/Dispatcher',
        'text!auth/template.html',
        'auth/AuthRemoteService',
        'auth/StateBuilder'],
function($,
         ko,
         Dispatcher,
         template,
         AuthRemoteService,
         StateBuilder){

  function AuthViewModel(params, componentInfo){


    this.isVisible = ko.observable(false).extend({notify:'always'});
    this.authState = ko.observable('anonymous');
    this.dis = new Dispatcher();
    this._remoteService = new AuthRemoteService();
    this.stateBuilder = new StateBuilder(this._remoteService, this);
    this.errorTimeout = 8000;
    this._userId = -1;



    this.setUserId = (function(id){
      if(!id || isNaN(id) || id < 1){
        throw new Error('id must be a postive integer.');
      }
      this._userId = id;
    }).bind(this)

    this.dispatchAuth = (function(state){
      if(state === 'authenticated'){
          this.dis.dispatch('authState', {
            id:this._userId,
            state:state
          });
      }
    }).bind(this)
    this.authStateSubscription = this.authState.subscribe(this.dispatchAuth);


    this.onLogout = (function(testMode){
      this._remoteService.deleteToken();
      // this._remoteService.checkIfCurrentTokenIsValid();
      if(!testMode){
        location.reload();
      }
    }).bind(this)
    this.dis.reg('logout',this.onLogout);


    /**
     * Whenever an attribute of a state changes that
     * is not an observable, this must be called.
     */
    this.triggerUpdate = function()  {
      this.state.valueHasMutated();
    }
    this.triggerUpdate = this.triggerUpdate.bind(this);

    var initialState = this.stateBuilder.buildInitialState(this);
    this.state = ko.observable(initialState);


    this.activationEmailSent = ko.computed(function(){
      var isSent = this.state().activationEmailSent;
      if(isSent){
        this.goToActivationEmailSentPage();
      }
      return isSent;
    },this).extend({notify:'always'});


    this.onTokenAnalyzed = function(json){
      try{
        var idTokenPair = JSON.parse(json);
        if(!idTokenPair || Array.isArray(idTokenPair) === false){
          this.isVisible(true);
          this._remoteService.deleteToken();
          this.authState('anonymous');
        }
        else{  // token is valid.

          var userId = idTokenPair[0];
          this.setUserId(userId);

          var token = idTokenPair[1];
          this._remoteService.setAccessToken(token);

          this.authState('authenticated');
          this.isVisible(false);
        }
      }
      catch(err){
        console.log(err);
      }
    }
    this.onTokenAnalyzed = this.onTokenAnalyzed.bind(this);



    this.email = ko.computed({
      read:function(){
          return this.state().email;
      },
      write:function(newEmail){
          this.state().setEmail(newEmail);
          // have to force the update because
          // on the State instance, email is
          // not an observable.
          this.state.valueHasMutated();
      },
      owner:this
    }).extend({ notify: 'always' });





    this.errorMessage = ko.computed({
      read:function(){
        return this.state().errorMessage;
      },
      write:function(value){
        this.state().errorMessage = value;
      },
      owner:this
    }).extend({notify:'always'});





    this.timerDone = true;

    this.clearErrorCallback = function(){
      this.errorMessage('');
      this.triggerUpdate();
      this.timerDone = true;
    }
    this.clearErrorCallback = this.clearErrorCallback.bind(this);


    this.errorSubscribeCallback = function() {

      if(this.timerDone){
        this.timerDone = false;
        setTimeout(this.clearErrorCallback,this.errorTimeout);
      }
    }

    this.errorSubscribeCallback = this.errorSubscribeCallback.bind(this);
    this.errorMessage.subscribe(this.errorSubscribeCallback);





    this.firstName = ko.computed({
      read:function(){
        return this.state().firstName;
      },
      write:function(value){
        this.state().firstName = value;
      },

      owner: this
    }).extend({notify:'always'});




    this.isEmailValid = ko.computed({
      read:function(){
        return this.state().isEmailValid;
      },
      write:function(value){
        this.state().isEmailValid = value;
      },
      owner:this
    });

    this.isFirstNameValid = ko.computed(function() {
      return this.state().isFirstNameValid;
    },this).extend({notify:'always'});


    this.isLastNameValid = ko.computed(function() {
      return this.state().isLastNameValid;
    },this);



    this.lastName = ko.computed({
      read:function(){
          return this.state().lastName;
      },
      write: function(value){
        this.state().lastName = value;
      }
    },this).extend({notify:'always'});


    this.login = function() {
      this.state().login();
    }



    this.loginPageVisible = ko.computed({
      read:function(){
          return this.state().getConstructorName() == "LoginState" && false == this.activationEmailSent();
      },
      write: function(value){

      },
      owner:this

    }).extend({notify:'always'});


    this.resetPasswordVisible = ko.computed({

      read:function(){

        return this.state().constructor.name == "PasswordResetState";
      },
      write: function(value){

      },
      owner:this
    }).extend({notify:'always'});




    this.resetPasswordEmailSentPageVisible = ko.computed({

      read:function(){
        return this.state().constructor.name == "SentResetEmailState";
      },
      write: function(value){

      },
      owner:this
    }).extend({notify:'always'});




    this.password = ko.computed({
        read:function(){
          return this.state().password;
        },
        write:  function(password){
          this.state().setPassword(password);
          this.state.valueHasMutated();
        },
        owner:this
    })




    this.signUp = function() {
      this.state().signUp();
    }


    this.signupPageVisible =  ko.computed(function() {

      return this.state().constructor.name == "SignupState";
    },this);


    this.injectSignupPageCallback = function(callback){

      this.signupPageVisible.subscribe(callback);
    }




    this.submitResetEmail =  function(){
      this.state().submitResetEmail();
    }


    this.spinner = ko.computed(function() {
      return this.state().spinner;
    },this);



    this.activationEmailSentPageVisible = ko.computed(function(){
      return this.state().constructor.name == "ActivationEmailSentState";
    },this);




    this.isPasswordValid = ko.computed(function() {
        return this.state().isPasswordValid;
    },this).extend({notify:'always'});



    this.invalidPasswordMessage = ko.computed(function(){
      return this.state().localErrorMessage.passwordError;
    },this).extend({notify:'always'});


    this.malformedEmailError = ko.computed(function(){
      return this.state().localErrorMessage.wrongEmail;

    },this).extend({notify:'always'});

    this.invokeSignupFormEndowment = ko.computed(function(){
      return this.state().endowSignupForm;
    },this);


 // make a whole other object whose responsibility is transitions.
// just get it working then refactor the design!

    this.goToSignupPage = function() {
      this.state(this.stateBuilder.build("SignupState",this));
    }

    this.goToActivationEmailSentPage = function(){
      this.state(this.stateBuilder.build("ActivationEmailSentState", this));
    }

    this.goToLoginPage = function() {
      this.state(this.stateBuilder.build("LoginState",this));
      // this.signupPageVisible(false);
    }


    this.goToPasswordResetState = function(){
      this.state(this.stateBuilder.build("PasswordResetState",this));
    }


    this.gotoSentResetEmailState = function(){
      this.state(this.stateBuilder.build("SentResetEmailState",this));
    }
    this._remoteService.registerOnTokenVerified(this.onTokenAnalyzed);
    this._remoteService.checkIfCurrentTokenIsValid();
}; // end AuthViewModel constructor.


return {
    viewModel: AuthViewModel,
    template :template
};


}); // end define.
;

define('text!environment/template.html',[],function () { return '\n\n<link rel="stylesheet"\n      href="./styles/components/environment/style.css">\n\n<div  id="connection-lost-alert"\n      data-bind="visible:showConnectionLost()">\n  <div>Internet Disconnected</div>\n</div>\n\n\n<div id="no-mobile-holder"\n     data-bind="visible:showDeviceNotSupportedMessage()">\n  <div id="no-mobile-message">\n    <div>Sorry this website is not mobile friendly.</div>\n    <img  id="no-mobile-math-joke"\n          src="https://i.pinimg.com/originals/6f/a2/b3/6fa2b37c7165c9cdc061b6b1f599f543.jpg">\n    </img>\n    <div id="desktop-laptop-prompt">\n          Please try again on your laptop or desktop computer.\n    </div>\n  </div>\n</div>\n';});

/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
define('environment/Component',['ko',
        'dispatcher/Dispatcher',
        'text!environment/template.html'],
function(ko,
         Dispatcher,
         template){

  function InternetHeartBeatViewModel(params, componentInfo){

    this.dis = new Dispatcher();
    this.showConnectionLost = ko.observable(false);
    this.showDeviceNotSupportedMessage = ko.observable(false);
    this.MIN_WIDTH = 500;

    this.onAuthUpdate = (function(update){
      if(update.state == 'authenticated'){
        this.isSupportedDevice() ? this.showDeviceNotSupportedMessage(false) : this.showDeviceNotSupportedMessage(false);
      }
    }).bind(this)
    this.authStateId = this.dis.reg('authState', this.onAuthUpdate);

    this.onOffline = function(){
      this.showConnectionLost(true);
    }
    this.onOffline = this.onOffline.bind(this);
    window.addEventListener('offline',this.onOffline);

    this.onOnline = function(){
      this.showConnectionLost(false);
    }
    this.onOnline = this.onOnline.bind(this);
    window.addEventListener('online', this.onOnline);

    this.getWindowWidth = function(){
      return window.innerWidth;
    }

    this.isSupportedDevice = function() {
      var device = navigator.userAgent;
      var width = this.getWindowWidth();
      // console.log('innerWidth:' + width);

     if(device.match(/iPod/i)){
        return false;
      }
      else if(width < this.MIN_WIDTH){
        return false;
      }
     else {
        return true;
      }
    }

};

return {
    viewModel: InternetHeartBeatViewModel,
    template :template
};


}); // end define.
;

define('text!search/template.html',[],function () { return '<link rel="stylesheet"\n      href="./styles/components/search/style.css?v=2.3">\n</link>\n\n<div id="search-bar-holder"\n     data-bind="visible:isVisible()">\n\n     <div class="search-holder">\n\n\n         <input class="search-bar"\n                type="text"\n                autoComplete="off"\n                placeholder="Search people or courses"\n                data-bind="textInput:query">\n         </input>\n\n         <!-- spinner -->\n         <span  id="pal-list-spinner"\n                 data-bind="visible:isSpinnerVisible()">\n           <div  class="screen-center-outer">\n            <div class="screen-center-inner">\n               <div class="small-spinner">\n               </div>\n            </div>\n          </div>\n         </span>\n\n         <button type="button"\n                 id="search-button"\n                 class="btn search-button">\n            <span class="glyphicon glyphicon-search">\n            </span>\n          </button>\n\n          <div class=\'search-result-header\' data-bind="visible:coursesFound().length > 0"> Courses </div>\n         <ul class="course-code-search-results"\n             data-bind="visible:coursesFound().length > 0,\n                        foreach:coursesFound">\n\n           <li class="course-code-search-result"\n               data-bind="click:$parent.selectCourse">\n               <span data-bind="text:course_code + \' Section \' + section_letter + \' - \' + description + \' - \' + first + \' \' + last"></span>\n           </li>\n         </ul>\n\n         <div class=\'search-result-header\' data-bind="visible:peopleFound().length > 0"> People </div>\n         <ul class="course-code-search-results"\n             data-bind="visible:peopleFound().length > 0,\n                        foreach:peopleFound">\n\n           <li class="course-code-search-result"\n               data-bind="click:$parent.selectPerson">\n               <img class=\'person-result-img\' data-bind=\'attr:{src:getSmallPhotoURL()}\'></img>\n               <span data-bind="text:getFirst() + \' \' + getLast()"></span>\n               <span class=\'role\' data-bind=\'text:getRole()\'>\n           </li>\n         </ul>\n\n\n\n         <!-- <div id="recent-search-holder"\n              data-bind="visible:recentSearches().length > 0">\n           <div style="width:fit-content;">\n             <div id="recent-searches-title">\n               Recent Searches\n             </div>\n             <ul class="course-code-search-results"\n                 data-bind="foreach:recentSearches, complementClick:clearHistoryResults">\n               <li class="course-code-search-result"\n                   data-bind="click:$parent.selectCourse">\n                   <div data-bind="text:course_code + \' \' + section_letter + \' \' + description, "></div>\n               </li>\n             </ul>\n         </div> -->\n\n         </div>\n\n\n         <div  id="search-match-message"\n               data-bind="visible:peopleFound().length == 0 && coursesFound().length == 0 && query().length > 2">\n               No matches found.\n         </div>\n\n\n     </div>\n\n\n\n</div>\n';});

define('people-models/Stranger',['people-models/Person'],
function(Person){

  var Stranger = function(raw, host){
    Object.setPrototypeOf(this, new Person(raw, host));
    this.constructor = Stranger;

    this.getConstructorName = function(){
      return 'Stranger'
    }

    this.isAddable = function(){
      return true
    }
  }

  Stranger.getRaw = function(){
      return Person.getRaw();
    }

  Stranger.getFake = function(){
    var classmate = Person.getRaw()
    var host = 'host';
    return new Stranger(classmate, host);
  }


  return Stranger;

});

define('search/SearchRemoteService',['ActiveRemoteService',
        'dispatcher/Dispatcher',
        'people-models/PersonCollection',
        'people-models/Person',
        'people-models/Stranger'],
function(ActiveRemoteService,
        Dispatcher,
        PersonCollection,
        Person,
        Stranger){


var SearchRemoteService = function(){

    this.constructor = SearchRemoteService;
    Object.setPrototypeOf(this,new ActiveRemoteService());
    this.setMicroServer("search");
    this.dis = new Dispatcher()

    this.onSelectedGroupId = (function(grpId){
      var url = this.getServerURL() + '/selectedCourse'
      $.ajax({
        url:url,
        type:'post',
        data:{
          courseId:grpId
        },
        beforeSend:this.setAuthorizationHeader,
        success:function(){
          console.log('updated course.')
        },
        error:this.onError
      })
    }).bind(this)
    this.dis.reg('selectedGroupId', this.onSelectedGroupId)

    this.onQueryCourse = (function(queryObj){
      var course = queryObj.query
      var grpId = queryObj.grpId
      var url = this.getServerURL() + '/queryCourse?query=' + course + '&grpId=' + grpId
      $.ajax({
        url:url,
        type:'get',
        beforeSend:this.setAuthorizationHeader,
        success:this.onCoursesFound,
        error:this.onError
      })
    }).bind(this)
    this.queryCourseId = this.dis.reg('queryCourse',this.onQueryCourse)


    this.onCoursesFound = (function(courses){
      this.dis.dispatch('coursesFound', courses)
    }).bind(this)

    this.onQueryName = (function(name){
      var url = this.getServerURL() + '/queryName?query=' + name
      $.ajax({
        url:url,
        type:'get',
        beforeSend:this.setAuthorizationHeader,
        success:this.onPeopleFound,
        error:this.onError
      })
    }).bind(this)
    this.queryNameId = this.dis.reg('queryName',this.onQueryName)


    /**
      pre: None of the people are already pals.
    */
    this.onPeopleFound = (function(people){
      var c = new PersonCollection()
      var host = this.getServerURL()
      for(var i = 0; i < people.length; i++){
        var p = new Stranger(people[i],host)
        c.add(p)
      }
      this.dis.dispatch('peopleFound',c)
    }).bind(this)



    this.onError = (function(err){
      console.log(err)
      alert('Sorry this feature is not working at the moment.')
    }).bind(this)

}

return SearchRemoteService;
})
;
define('search/SearchStore',['dispatcher/Dispatcher',
        'abstract-interfaces/Store',
        'search/SearchRemoteService',
        'people-models/PersonCollection'],
function(Dispatcher,
         Store,
         SearchRemoteService,
         PersonCollection){

   var instance = null;
   var SearchStore  = function(){

     new SearchRemoteService()

     Object.setPrototypeOf(this, new Store());
     this.dis = new Dispatcher();
     this.visible = false
     this.peopleFound = new PersonCollection()
     this.currentGroup = null
     this.coursesFound = []

     this.onClearResults = (function(){
       this.coursesFound = []
       this.peopleFound = new PersonCollection()
       this.pub()
     }).bind(this)
     this.dis.reg('clearResults',this.onClearResults)

     this.getCoursesFound = function(){
       return this.coursesFound
     }

     this.onCoursesFound = (function(courses){
       this.coursesFound = courses
       this.pub()
     }).bind(this)
     this.dis.reg('coursesFound',this.onCoursesFound)


     this.getCurrentGroupId = function(){
       if(this.currentGroup)
          return this.currentGroup.getId()
        else
          return null
     }

     this.onCourseGroup = (function(g){
       if(g && g.isGroup && g.isGroup())
          this.currentGroup = g
     }).bind(this)
     this.dis.reg('groupInfo',this.onCourseGroup)

     this.onFocusPerson = (function(){
       this.currentGroup = null
       this.pub()
     }).bind(this)
     this.dis.reg('focusPerson',this.onFocusPerson)

     this.onClearPeopleFound = (function(){
       this.peopleFound = null
       this.pub()
     }).bind(this)
     this.clearPeopleId = this.dis.reg('clearPeopleFound',this.onClearPeopleFound)

     this.onPeopleFound = (function(people){
       this.peopleFound = people
       this.pub()
     }).bind(this)
     this.peopleFoundId = this.dis.reg('peopleFound',this.onPeopleFound)

     this.getPeopleFound = function(){
       if(this.peopleFound){
         return this.peopleFound.toArray()
       }
       else
          return []
     }


     this.isVisible = function(){
       return this.visible
     }

     this.setVisible = function(){
       this.visible = true
     }

     this.onAuth = (function(u){
      u.state == 'authenticated' ? this.visible = true : this.visible = false
      this.pub()
    }).bind(this)
     this.dis.reg('authState', this.onAuth);

  } // end

    return {
      getInstance:function(){
        if(!instance){
          instance = new SearchStore();
        }
        return instance;
      },
      getNew:function(){
        return new SearchStore();
      }
    }
  })
;

define('search/Component',['ko',
        'text!search/template.html',
        'dispatcher/Dispatcher',
        'search/SearchStore'],

function(ko,
         template,
         Dispatcher,
         Store){

  var MIN_QUERY_LENGTH = 3
  function ViewModel(params, componentInfo){

    this.dis = new Dispatcher();
    this.store = Store.getInstance()
    this.query = ko.observable('')
    this.isSpinnerVisible = ko.observable(false)
    this.coursesFound = ko.observableArray([])
    this.peopleFound = ko.observableArray([])
    this.isVisible = ko.observable(false)

    this.onStore = (function(){
      this.isVisible(this.store.isVisible())
      this.coursesFound(this.store.getCoursesFound())
      this.peopleFound(this.store.getPeopleFound())
    }).bind(this)
    this.store.sub(this.onStore)

    this.selectPerson = (function(p, e){
      this.dis.dispatch('focusPerson',p)
      this.dis.dispatch('clearResults')
      this.query('')
    }).bind(this)


    this.onTyping = (function(text){
      if(text.length >= MIN_QUERY_LENGTH){
        var grpId = this.store.getCurrentGroupId()
        this.dis.dispatch('queryCourse',{query:text, grpId:grpId})
        this.dis.dispatch('queryName',text)
      }
      else if(text.length == MIN_QUERY_LENGTH - 1){
        this.dis.dispatch('clearResults')
      }
    }).bind(this)
    this.query.subscribe(this.onTyping)

    this.selectCourse = (function(course){
      var grpId = course.group_id
      this.dis.dispatch('selectedGroupId',grpId)
      this.clearResults()
    }).bind(this)

    this.clearResults = (function(){
      this.query('')
      this.dis.dispatch('clearResults')
    }).bind(this)


  }; // end viewModel.



  return {
    viewModel: ViewModel,
    template : template
  }


});


define('text!course-groups/template.html',[],function () { return '\n<link rel="stylesheet" href="./styles/components/course-groups/style.css?v=2.1"></link>\n\n  <div id="course-groups-holder">\n\n      <div id=\'school-group-title\'\n          data-bind=\'click:openNews,\n                     css: {"selected-group" : newsSelected() }\'>\n                     YorkU News\n      </div>\n      <!-- ko if:courses().length > 0 -->\n\n      <div id=\'course-groups-title\'>Course Groups</div>\n      <ul id=\'course-groups-list\' data-bind=\'foreach:courses\'>\n        <li class=\'course-group-li\'\n            data-bind="attr:{title:getCourseDescription()},\n                       text:getDept() + getCourseCode() + getSectionLetter(),\n                       click:$parent.selectCourseGroup,\n                       css: { \'selected-group\': $parent.currentCourseGroup() != null && $parent.currentCourseGroup().getId() == getId() }">\n\n        </li>\n\n      </ul>\n      <!-- /ko -->\n  </div>\n';});

define('course-groups/GroupsStore',['dispatcher/Dispatcher',
        'abstract-interfaces/Store',
        'course/models/CourseGroup'],
function(Dispatcher,
         Store,
         CourseGroup){


   var instance = null;
   var GroupStore  = function(){

     Object.setPrototypeOf(this, new Store())
     this.dis = new Dispatcher()
     this.groupViewVisible = false
     this.courseGroups = []
     this.selectedGroup = null
     this.newsSelected = true

     this.isNewsViewVisible = function(){
       return this.newsSelected
     }


     // pre: selectedGroup is not already in the courseGroups list.
     this.onGroupJoined = (function(groupId){
       if(this.selectedGroup && this.selectedGroup.getId() == groupId){
         this.courseGroups.push(this.selectedGroup)
         this.pub()
       }
     }).bind(this)
     this.dis.reg('groupJoined',this.onGroupJoined)


     this.getSelectedGroup = function(){
       return this.selectedGroup
     }

     this.onGroupLeft = (function(groupId){
       var index = -1
       for(var i = 0; i < this.courseGroups.length; i++){
         var g = this.courseGroups[i]
         if(g.getId() == groupId){
           index = i
           break
         }
       }
       if(index >= 0) {
         this.courseGroups.splice(index, 1)
         this.pub()
       }
     }).bind(this)
     this.dis.reg('courseLeft', this.onGroupLeft)


     this.onOpenNews = (function(){
       this.groupViewVisible = false
       this.newsSelected = true
       this.pub()
     }).bind(this)
     this.dis.reg('openNews',this.onOpenNews)

     this.isGroupViewVisible = function(){
       return this.groupViewVisible
     }

     this.onGroupInfo = (function(group){
       this.selectedGroup = group
       this.groupViewVisible = true
       this.newsSelected = false
       this.pub()
     }).bind(this)
     this.dis.reg('groupInfo',this.onGroupInfo)


     this.onFocusPerson = (function(){
       this.groupViewVisible = false
       this.pub()
     }).bind(this)
     this.dis.reg('focusPerson',this.onFocusPerson)

     this.getMyCourseGroups = function(){
       return this.courseGroups
     }

     this.onMyCourseGroups = (function(groups){
       this.courseGroups = groups
       this.pub()
     }).bind(this)
     this.dis.reg('myCourseGroups',this.onMyCourseGroups)


  } // end

    return {
      getInstance:function(){
        if(!instance){
          instance = new GroupStore();
        }
        return instance;
      },
      getNew:function(){
        return new GroupStore();
      }
    }
  })
;

define('course-groups/Component',['ko',
        'text!course-groups/template.html',
        'dispatcher/Dispatcher',
        'course-groups/GroupsStore',
        'course/models/CourseGroup'],

function(ko,
         template,
         Dispatcher,
         Store,
        CourseGroup){

  function ViewModel(){

    this.dis = new Dispatcher();
    this.store = Store.getInstance();
    this.courses = ko.observableArray([])
    this.newsSelected = ko.observable(false)
    this.currentCourseGroup = ko.observable(null)

    this.onStore = (function(){
      this.newsSelected(this.store.isNewsViewVisible())
      this.courses(this.store.getMyCourseGroups())
      this.store.isGroupViewVisible() ? null : this.currentCourseGroup(null)
    }).bind(this)
    this.store.sub(this.onStore)

    this.openNews = (function(){
      this.dis.dispatch('openNews')
    }).bind(this)

    this.selectCourseGroup = (function(cg){
      this.currentCourseGroup(cg)
      if(cg) this.dis.dispatch('selectedGroupId',cg.getId())
    }).bind(this)

  }

  return {
    viewModel: ViewModel,
    template : template
  }


});


define('text!new-pal-list/template.html',[],function () { return '<link rel="stylesheet" href="./styles/components/person-panel/new-pal-list.css?v=1">\n\n  <ul id="new-pal-list" data-bind="foreach:newPals">\n    <li class="pal-row"  data-bind="css:{\'pal-row-selected\':$parent.selectedPal() != null && $parent.selectedPal().getId() == getId() && $parent.selectedPal().getId() >=0}, click:$parent.palClicked">\n      <i\n           class="pal-list-notification"\n           data-bind="visible:isNew()">\n           <i class="arrow-left">\n           </i>\n           You have a new friend!\n       </i>\n\n       <span class="pal-presence">\n         <i class="pal-last-seen centerize"\n            data-bind="visible:isPresent() == false, text:getLastSeen()">\n         </i>\n         <i class="dot presence-dot centerize"\n            data-bind="visible:isPresent()">\n          </i>\n       </span>\n       <img class="pal-img"\n            data-bind="attr:{src: getSmallPhotoURL()}">\n       </img>\n       <span class="pal-name-holder">\n         <span class="pal-name"\n               data-bind="text:getFirst() + \' \' + getLast()">\n         </span>\n       </span>\n\n    </li>\n\n\n  </ul>\n';});


define('new-pal-list/Component',['ko',
        'text!new-pal-list/template.html',
        'dispatcher/Dispatcher',
        'people-models/NullPerson',
        'people-store/PeopleStore'],

function(ko,
         template,
         Dispatcher,
         NullPerson,
         Store){

  function ViewModel(){

    this.dis = new Dispatcher();
    this.store = Store.getInstance();
    this.newPals = ko.observableArray([]);
    this.selectedPal = ko.observable(null);

    this.onStore = (function(){
      var pals = this.store.getNewPals().toArray()
      this.newPals(pals)
    }).bind(this)
    this.store.sub(this.onStore)

    this.palClicked = (function(p){
      this.selectedPal(p)
      this.dis.dispatch('focusPerson',p)
    }).bind(this)


  } // end view model.

  return {
    viewModel: ViewModel,
    template : template
  }


});


define('text!pal-list/template.html',[],function () { return '<link rel="stylesheet" href="./styles/components/person-panel/pal-list.css?v=3.1">\n<div id="pal-holder">\n  <span data-bind="visible:isSpinnerVisible()">\n    <div  class="screen-center-outer">\n     <div class="screen-center-inner">\n        <div class="small-spinner">\n        </div>\n     </div>\n   </div>\n  </span>\n  <div id="no-pals-message"\n        data-bind="visible:palCount() < 1">\n    No friends yet.\n    <div id="great-job">Great job! <span class="glyphicon glyphicon-thumbs-up"></span></div>\n  </div>\n      <!-- ko if: selectedPal() != null -->\n  <div id=\'pal-list-header\'>\n    <div>Friends</div>\n\n  </div>\n\n  <new-pal-list></new-pal-list>\n\n  <ul id="pal-list"\n      data-bind="foreach:pals">\n\n    <li class="pal-row"\n        data-bind="css:{\'pal-row-selected\':$parent.selectedPal().getId() == getId() && $parent.selectedPal().getId() >=0}, click:$parent.palClicked">\n\n      <span class="pal-presence">\n        <i class="pal-last-seen centerize"\n           data-bind="visible:isPresent() == false, text:getLastSeen()">\n        </i>\n        <i class="dot presence-dot centerize"\n           data-bind="visible:isPresent()">\n         </i>\n      </span>\n      <img class="pal-img"\n           data-bind="attr:{src: getSmallPhotoURL()}">\n      </img>\n      <span class="pal-name-holder">\n        <span class="pal-name"\n              data-bind="text:getFirst() + \' \' + getLast()">\n        </span>\n      </span>\n    </li>\n\n  </ul>\n        <!-- /ko -->\n</div>\n';});


define('pal-list/Component',['ko',
        'text!pal-list/template.html',
        'dispatcher/Dispatcher',
        'people-models/Pal',
        'people-store/PeopleStore'],

function(ko,
         template,
         Dispatcher,
         Pal,
         Store){

  function ViewModel(){

    this.dis = new Dispatcher();
    this.store = Store.getInstance();
    this.pals = ko.observableArray([]);
    this.selectedPal = ko.observable(null);
    this.palCount = ko.observable(0)
    this.isSpinnerVisible = ko.observable(false)


    this.onStoreUpdate = (function(){
      this.isSpinnerVisible(this.store.isSpinnerVisible())
      this.palCount(this.store.getPalCount())
      this.pals(this.store.getPalList().toArray());
      this.selectedPal(this.store.getFocusedPerson())
    }).bind(this)
    this.store.sub(this.onStoreUpdate);

    this.palClicked = (function(pal){
      this.selectedPal(pal);
      this.dis.dispatch('focusPerson',pal);
    }).bind(this)

  } // end view model.

  return {
    viewModel: ViewModel,
    template : template
  }


});


define('text!pal-request-list/template.html',[],function () { return '<link rel="stylesheet" href="./styles/components/person-panel/pal-request-list.css?v=1.0">\n<div id="pal-request-list-holder">\n    <ul data-bind="foreach:requests" id="pal-request-list">\n      <li class="pal-request-row">\n\n        <span>\n          <div class="pal-img-request-holder">\n            <img class="pal-img"\n                 data-bind="attr:{src: getSmallPhotoURL()}, click:$parent.faceClicked">\n            </img>\n          </div>\n\n          <span class="pal-request-name-holder">\n            <span class="pal-request-name"\n                  data-bind="text:getFirst() + \' \' + getLast()">\n            </span>\n          </span>\n\n          <div class="pal-request-title">\n              wants to be your friend.\n          </div>\n\n        </span>\n\n        <span class="pal-request-button-holder">\n            <div>\n              <button data-bind="click:$parent.acceptRequest">\n                  accept\n              </button>\n              <button data-bind="click:$parent.denyRequest">\n                  deny\n              </button>\n            </div>\n        </span>\n\n\n\n\n      </li>\n    </ul>\n</div>\n';});


define('pal-request-list/Component',['ko',
        'text!pal-request-list/template.html',
        'dispatcher/Dispatcher',
        'people-models/Person',
        'people-store/PeopleStore'],

function(ko,
         template,
         Dispatcher,
         Person,
         Store){

  function ViewModel(){

    this.dis = new Dispatcher();
    this.store = Store.getInstance();
    this.requests = ko.observableArray([]);


    this.onStoreUpdate = function(){
      var requests = this.store.getPalRequests();
      this.requests(requests);
    }
    this.onStoreUpdate = this.onStoreUpdate.bind(this);
    this.store.sub(this.onStoreUpdate);


    this.acceptRequest = function(person){
      this.dis.dispatch('acceptRequest', person);
    }
    this.acceptRequest = this.acceptRequest.bind(this);

    this.denyRequest = function(person){
      this.dis.dispatch('denyRequest', person);
    }
    this.denyRequest = this.denyRequest.bind(this);

    this.faceClicked  = function(classmate){
      this.dis.dispatch('focusPerson', classmate);
    }
    this.faceClicked = this.faceClicked.bind(this);


  } // end view model.

  return {
    viewModel: ViewModel,
    template : template
  }


});


define('text!people-popups/template.html',[],function () { return '\n<link rel="stylesheet"\n      href="./styles/components/person-panel/people-popups.css?v=2.1">\n\n<i id="pal-request-sent"\n   data-bind="visible:isPalRequestSentVisible()">\n  Friend request sent.\n</i>\n';});

/**
 * @license Proprietary - Please do not steal our hard work.
 * @Author: Christopher H. Kerley
 * @Last modified time: 2019-08-24
 * @Copyright: Palolo Education Inc. 2020
 */
define('people-popups/Component',['ko',
        'dispatcher/Dispatcher',
        'text!people-popups/template.html',
        'people-store/PeopleStore'],
function(ko,
         Dispatcher,
         template,
         PeopleStore){

  function ViewModel(params,componentInfo){

    this.dis = new Dispatcher();
    this.store = PeopleStore.getInstance();
    this.isPalRequestSentVisible = ko.observable(false);

    this.onStoreUpdated = function(){
      this.isPalRequestSentVisible(this.store.isPalRequestSent());
    }
    this.onStoreUpdated = this.onStoreUpdated.bind(this);
    this.store.sub(this.onStoreUpdated);

  }; // end viewModel.

  return {
    viewModel: ViewModel,
    template : template
  }

});


// Note that requirejs is used when you want to
// 'exports' of a module to be passed as an argument to a function.
//  not the module themselves.  For example if code like this appears.
/**


in the module,  then use require,  otherwise use define.
*/
requirejs.config({
    paths: {
        'stripe' : 'https://js.stripe.com/v3?noext',
        'twilio-video' : 'https://media.twiliocdn.com/sdk/js/video/releases/2.4.0/twilio-video.min'
    }
});



require(['stripe','twilio-video'], function (stripe) {


    requirejs(['ko',
               'enterKey',
               'complementClick',
               'sliderValue',
               'RootViewModel'],

    function(ko,
             enterKey,
             complementClick,
             sliderValue,
             RootViewModel){
      ko.applyBindings(new RootViewModel());
    });

});

define("/var/www/palolo/src/main.js", function(){});

